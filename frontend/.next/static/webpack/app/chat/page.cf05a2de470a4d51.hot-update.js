"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/chat/page",{

/***/ "(app-pages-browser)/./src/app/lib/auth.ts":
/*!*****************************!*\
  !*** ./src/app/lib/auth.ts ***!
  \*****************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   authFetch: function() { return /* binding */ authFetch; },\n/* harmony export */   getAuthUser: function() { return /* binding */ getAuthUser; },\n/* harmony export */   getToken: function() { return /* binding */ getToken; },\n/* harmony export */   isAuthenticated: function() { return /* binding */ isAuthenticated; },\n/* harmony export */   removeToken: function() { return /* binding */ removeToken; },\n/* harmony export */   setToken: function() { return /* binding */ setToken; }\n/* harmony export */ });\n// Authentication utility functions\n// Store token in localStorage\nconst setToken = (token)=>{\n    if (true) {\n        localStorage.setItem(\"auth_token\", token);\n    }\n};\n// Get token from localStorage\nconst getToken = ()=>{\n    if (true) {\n        return localStorage.getItem(\"auth_token\");\n    }\n    return null;\n};\n// Remove token from localStorage\nconst removeToken = ()=>{\n    if (true) {\n        localStorage.removeItem(\"auth_token\");\n    }\n};\n// Check if user is authenticated\nconst isAuthenticated = ()=>{\n    const token = getToken();\n    return !!token;\n};\n// Get authenticated user from token\nconst getAuthUser = ()=>{\n    const token = getToken();\n    if (!token) return null;\n    try {\n        // Decode JWT token (simple decode, not verification)\n        const base64Url = token.split(\".\")[1];\n        const base64 = base64Url.replace(/-/g, \"+\").replace(/_/g, \"/\");\n        const jsonPayload = decodeURIComponent(atob(base64).split(\"\").map((c)=>\"%\" + (\"00\" + c.charCodeAt(0).toString(16)).slice(-2)).join(\"\"));\n        const payload = JSON.parse(jsonPayload);\n        console.log(\"Decoded JWT payload:\", payload); // Debug log to see the actual payload structure\n        // Return user object with consistent structure for frontend components\n        // Try different possible locations for the name field\n        const userName = payload.name || payload.username || payload.displayName || \"\";\n        console.log(\"Extracted user name:\", userName);\n        return {\n            id: payload.sub,\n            name: userName || \"Unknown\",\n            email: payload.email,\n            role: payload.role\n        };\n    } catch (error) {\n        console.error(\"Error decoding token:\", error);\n        removeToken(); // Remove invalid token\n        return null;\n    }\n};\n// Create authenticated fetch function that includes the token\nconst authFetch = async function(url) {\n    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n    const token = getToken();\n    // Create a proper Headers object\n    const headers = new Headers(options.headers);\n    headers.set(\"Content-Type\", \"application/json\");\n    if (token) {\n        headers.set(\"Authorization\", \"Bearer \".concat(token));\n    }\n    return fetch(url, {\n        ...options,\n        headers\n    });\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9hcHAvbGliL2F1dGgudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUEsbUNBQW1DO0FBRW5DLDhCQUE4QjtBQUN2QixNQUFNQSxXQUFXLENBQUNDO0lBQ3ZCLElBQUksSUFBa0IsRUFBYTtRQUNqQ0MsYUFBYUMsT0FBTyxDQUFDLGNBQWNGO0lBQ3JDO0FBQ0YsRUFBRTtBQUVGLDhCQUE4QjtBQUN2QixNQUFNRyxXQUFXO0lBQ3RCLElBQUksSUFBa0IsRUFBYTtRQUNqQyxPQUFPRixhQUFhRyxPQUFPLENBQUM7SUFDOUI7SUFDQSxPQUFPO0FBQ1QsRUFBRTtBQUVGLGlDQUFpQztBQUMxQixNQUFNQyxjQUFjO0lBQ3pCLElBQUksSUFBa0IsRUFBYTtRQUNqQ0osYUFBYUssVUFBVSxDQUFDO0lBQzFCO0FBQ0YsRUFBRTtBQUVGLGlDQUFpQztBQUMxQixNQUFNQyxrQkFBa0I7SUFDN0IsTUFBTVAsUUFBUUc7SUFDZCxPQUFPLENBQUMsQ0FBQ0g7QUFDWCxFQUFFO0FBRUYsb0NBQW9DO0FBQzdCLE1BQU1RLGNBQWM7SUFDekIsTUFBTVIsUUFBUUc7SUFDZCxJQUFJLENBQUNILE9BQU8sT0FBTztJQUVuQixJQUFJO1FBQ0YscURBQXFEO1FBQ3JELE1BQU1TLFlBQVlULE1BQU1VLEtBQUssQ0FBQyxJQUFJLENBQUMsRUFBRTtRQUNyQyxNQUFNQyxTQUFTRixVQUFVRyxPQUFPLENBQUMsTUFBTSxLQUFLQSxPQUFPLENBQUMsTUFBTTtRQUMxRCxNQUFNQyxjQUFjQyxtQkFDbEJDLEtBQUtKLFFBQ0ZELEtBQUssQ0FBQyxJQUNOTSxHQUFHLENBQUMsQ0FBQ0MsSUFBTSxNQUFNLENBQUMsT0FBT0EsRUFBRUMsVUFBVSxDQUFDLEdBQUdDLFFBQVEsQ0FBQyxHQUFFLEVBQUdDLEtBQUssQ0FBQyxDQUFDLElBQzlEQyxJQUFJLENBQUM7UUFHVixNQUFNQyxVQUFVQyxLQUFLQyxLQUFLLENBQUNYO1FBQzNCWSxRQUFRQyxHQUFHLENBQUMsd0JBQXdCSixVQUFVLGdEQUFnRDtRQUU5Rix1RUFBdUU7UUFDdkUsc0RBQXNEO1FBQ3RELE1BQU1LLFdBQVdMLFFBQVFNLElBQUksSUFBSU4sUUFBUU8sUUFBUSxJQUFJUCxRQUFRUSxXQUFXLElBQUk7UUFDNUVMLFFBQVFDLEdBQUcsQ0FBQyx3QkFBd0JDO1FBRXBDLE9BQU87WUFDTEksSUFBSVQsUUFBUVUsR0FBRztZQUNmSixNQUFNRCxZQUFZO1lBQ2xCTSxPQUFPWCxRQUFRVyxLQUFLO1lBQ3BCQyxNQUFNWixRQUFRWSxJQUFJO1FBQ3BCO0lBQ0YsRUFBRSxPQUFPQyxPQUFPO1FBQ2RWLFFBQVFVLEtBQUssQ0FBQyx5QkFBeUJBO1FBQ3ZDOUIsZUFBZSx1QkFBdUI7UUFDdEMsT0FBTztJQUNUO0FBQ0YsRUFBRTtBQUVGLDhEQUE4RDtBQUN2RCxNQUFNK0IsWUFBWSxlQUFPQztRQUFhQywyRUFBdUIsQ0FBQztJQUNuRSxNQUFNdEMsUUFBUUc7SUFFZCxpQ0FBaUM7SUFDakMsTUFBTW9DLFVBQVUsSUFBSUMsUUFBUUYsUUFBUUMsT0FBTztJQUMzQ0EsUUFBUUUsR0FBRyxDQUFDLGdCQUFnQjtJQUU1QixJQUFJekMsT0FBTztRQUNUdUMsUUFBUUUsR0FBRyxDQUFDLGlCQUFpQixVQUFnQixPQUFOekM7SUFDekM7SUFFQSxPQUFPMEMsTUFBTUwsS0FBSztRQUNoQixHQUFHQyxPQUFPO1FBQ1ZDO0lBQ0Y7QUFDRixFQUFFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9hcHAvbGliL2F1dGgudHM/MDA4MyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBBdXRoZW50aWNhdGlvbiB1dGlsaXR5IGZ1bmN0aW9uc1xuXG4vLyBTdG9yZSB0b2tlbiBpbiBsb2NhbFN0b3JhZ2VcbmV4cG9ydCBjb25zdCBzZXRUb2tlbiA9ICh0b2tlbjogc3RyaW5nKTogdm9pZCA9PiB7XG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKCdhdXRoX3Rva2VuJywgdG9rZW4pO1xuICB9XG59O1xuXG4vLyBHZXQgdG9rZW4gZnJvbSBsb2NhbFN0b3JhZ2VcbmV4cG9ydCBjb25zdCBnZXRUb2tlbiA9ICgpOiBzdHJpbmcgfCBudWxsID0+IHtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIGxvY2FsU3RvcmFnZS5nZXRJdGVtKCdhdXRoX3Rva2VuJyk7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59O1xuXG4vLyBSZW1vdmUgdG9rZW4gZnJvbSBsb2NhbFN0b3JhZ2VcbmV4cG9ydCBjb25zdCByZW1vdmVUb2tlbiA9ICgpOiB2b2lkID0+IHtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oJ2F1dGhfdG9rZW4nKTtcbiAgfVxufTtcblxuLy8gQ2hlY2sgaWYgdXNlciBpcyBhdXRoZW50aWNhdGVkXG5leHBvcnQgY29uc3QgaXNBdXRoZW50aWNhdGVkID0gKCk6IGJvb2xlYW4gPT4ge1xuICBjb25zdCB0b2tlbiA9IGdldFRva2VuKCk7XG4gIHJldHVybiAhIXRva2VuO1xufTtcblxuLy8gR2V0IGF1dGhlbnRpY2F0ZWQgdXNlciBmcm9tIHRva2VuXG5leHBvcnQgY29uc3QgZ2V0QXV0aFVzZXIgPSAoKTogYW55ID0+IHtcbiAgY29uc3QgdG9rZW4gPSBnZXRUb2tlbigpO1xuICBpZiAoIXRva2VuKSByZXR1cm4gbnVsbDtcbiAgXG4gIHRyeSB7XG4gICAgLy8gRGVjb2RlIEpXVCB0b2tlbiAoc2ltcGxlIGRlY29kZSwgbm90IHZlcmlmaWNhdGlvbilcbiAgICBjb25zdCBiYXNlNjRVcmwgPSB0b2tlbi5zcGxpdCgnLicpWzFdO1xuICAgIGNvbnN0IGJhc2U2NCA9IGJhc2U2NFVybC5yZXBsYWNlKC8tL2csICcrJykucmVwbGFjZSgvXy9nLCAnLycpO1xuICAgIGNvbnN0IGpzb25QYXlsb2FkID0gZGVjb2RlVVJJQ29tcG9uZW50KFxuICAgICAgYXRvYihiYXNlNjQpXG4gICAgICAgIC5zcGxpdCgnJylcbiAgICAgICAgLm1hcCgoYykgPT4gJyUnICsgKCcwMCcgKyBjLmNoYXJDb2RlQXQoMCkudG9TdHJpbmcoMTYpKS5zbGljZSgtMikpXG4gICAgICAgIC5qb2luKCcnKVxuICAgICk7XG4gICAgXG4gICAgY29uc3QgcGF5bG9hZCA9IEpTT04ucGFyc2UoanNvblBheWxvYWQpO1xuICAgIGNvbnNvbGUubG9nKCdEZWNvZGVkIEpXVCBwYXlsb2FkOicsIHBheWxvYWQpOyAvLyBEZWJ1ZyBsb2cgdG8gc2VlIHRoZSBhY3R1YWwgcGF5bG9hZCBzdHJ1Y3R1cmVcbiAgICBcbiAgICAvLyBSZXR1cm4gdXNlciBvYmplY3Qgd2l0aCBjb25zaXN0ZW50IHN0cnVjdHVyZSBmb3IgZnJvbnRlbmQgY29tcG9uZW50c1xuICAgIC8vIFRyeSBkaWZmZXJlbnQgcG9zc2libGUgbG9jYXRpb25zIGZvciB0aGUgbmFtZSBmaWVsZFxuICAgIGNvbnN0IHVzZXJOYW1lID0gcGF5bG9hZC5uYW1lIHx8IHBheWxvYWQudXNlcm5hbWUgfHwgcGF5bG9hZC5kaXNwbGF5TmFtZSB8fCAnJztcbiAgICBjb25zb2xlLmxvZygnRXh0cmFjdGVkIHVzZXIgbmFtZTonLCB1c2VyTmFtZSk7XG4gICAgXG4gICAgcmV0dXJuIHtcbiAgICAgIGlkOiBwYXlsb2FkLnN1YixcbiAgICAgIG5hbWU6IHVzZXJOYW1lIHx8ICdVbmtub3duJyxcbiAgICAgIGVtYWlsOiBwYXlsb2FkLmVtYWlsLFxuICAgICAgcm9sZTogcGF5bG9hZC5yb2xlXG4gICAgfTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBkZWNvZGluZyB0b2tlbjonLCBlcnJvcik7XG4gICAgcmVtb3ZlVG9rZW4oKTsgLy8gUmVtb3ZlIGludmFsaWQgdG9rZW5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufTtcblxuLy8gQ3JlYXRlIGF1dGhlbnRpY2F0ZWQgZmV0Y2ggZnVuY3Rpb24gdGhhdCBpbmNsdWRlcyB0aGUgdG9rZW5cbmV4cG9ydCBjb25zdCBhdXRoRmV0Y2ggPSBhc3luYyAodXJsOiBzdHJpbmcsIG9wdGlvbnM6IFJlcXVlc3RJbml0ID0ge30pOiBQcm9taXNlPFJlc3BvbnNlPiA9PiB7XG4gIGNvbnN0IHRva2VuID0gZ2V0VG9rZW4oKTtcbiAgXG4gIC8vIENyZWF0ZSBhIHByb3BlciBIZWFkZXJzIG9iamVjdFxuICBjb25zdCBoZWFkZXJzID0gbmV3IEhlYWRlcnMob3B0aW9ucy5oZWFkZXJzKTtcbiAgaGVhZGVycy5zZXQoJ0NvbnRlbnQtVHlwZScsICdhcHBsaWNhdGlvbi9qc29uJyk7XG4gIFxuICBpZiAodG9rZW4pIHtcbiAgICBoZWFkZXJzLnNldCgnQXV0aG9yaXphdGlvbicsIGBCZWFyZXIgJHt0b2tlbn1gKTtcbiAgfVxuICBcbiAgcmV0dXJuIGZldGNoKHVybCwge1xuICAgIC4uLm9wdGlvbnMsXG4gICAgaGVhZGVycyxcbiAgfSk7XG59O1xuIl0sIm5hbWVzIjpbInNldFRva2VuIiwidG9rZW4iLCJsb2NhbFN0b3JhZ2UiLCJzZXRJdGVtIiwiZ2V0VG9rZW4iLCJnZXRJdGVtIiwicmVtb3ZlVG9rZW4iLCJyZW1vdmVJdGVtIiwiaXNBdXRoZW50aWNhdGVkIiwiZ2V0QXV0aFVzZXIiLCJiYXNlNjRVcmwiLCJzcGxpdCIsImJhc2U2NCIsInJlcGxhY2UiLCJqc29uUGF5bG9hZCIsImRlY29kZVVSSUNvbXBvbmVudCIsImF0b2IiLCJtYXAiLCJjIiwiY2hhckNvZGVBdCIsInRvU3RyaW5nIiwic2xpY2UiLCJqb2luIiwicGF5bG9hZCIsIkpTT04iLCJwYXJzZSIsImNvbnNvbGUiLCJsb2ciLCJ1c2VyTmFtZSIsIm5hbWUiLCJ1c2VybmFtZSIsImRpc3BsYXlOYW1lIiwiaWQiLCJzdWIiLCJlbWFpbCIsInJvbGUiLCJlcnJvciIsImF1dGhGZXRjaCIsInVybCIsIm9wdGlvbnMiLCJoZWFkZXJzIiwiSGVhZGVycyIsInNldCIsImZldGNoIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/app/lib/auth.ts\n"));

/***/ })

});