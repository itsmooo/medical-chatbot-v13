"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@react-pdf+fns@3.1.2";
exports.ids = ["vendor-chunks/@react-pdf+fns@3.1.2"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/@react-pdf+fns@3.1.2/node_modules/@react-pdf/fns/lib/index.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/.pnpm/@react-pdf+fns@3.1.2/node_modules/@react-pdf/fns/lib/index.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   adjust: () => (/* binding */ adjust),\n/* harmony export */   asyncCompose: () => (/* binding */ asyncCompose),\n/* harmony export */   capitalize: () => (/* binding */ capitalize),\n/* harmony export */   castArray: () => (/* binding */ castArray),\n/* harmony export */   compose: () => (/* binding */ compose),\n/* harmony export */   dropLast: () => (/* binding */ dropLast),\n/* harmony export */   evolve: () => (/* binding */ evolve),\n/* harmony export */   get: () => (/* binding */ get),\n/* harmony export */   isNil: () => (/* binding */ isNil),\n/* harmony export */   last: () => (/* binding */ last),\n/* harmony export */   mapValues: () => (/* binding */ mapValues),\n/* harmony export */   matchPercent: () => (/* binding */ matchPercent),\n/* harmony export */   omit: () => (/* binding */ omit),\n/* harmony export */   parseFloat: () => (/* binding */ parseFloat$1),\n/* harmony export */   pick: () => (/* binding */ pick),\n/* harmony export */   repeat: () => (/* binding */ repeat),\n/* harmony export */   reverse: () => (/* binding */ reverse),\n/* harmony export */   upperFirst: () => (/* binding */ upperFirst),\n/* harmony export */   without: () => (/* binding */ without)\n/* harmony export */ });\n/**\n * Applies a function to the value at the given index of an array\n *\n * @param index\n * @param fn\n * @param collection\n * @returns Copy of the array with the element at the given index replaced with the result of the function application.\n */\nconst adjust = (index, fn, collection) => {\n    if (index >= 0 && index >= collection.length)\n        return collection;\n    if (index < 0 && Math.abs(index) > collection.length)\n        return collection;\n    const i = index < 0 ? collection.length + index : index;\n    return Object.assign([], collection, { [i]: fn(collection[i]) });\n};\n\n/* eslint-disable no-await-in-loop */\n/**\n * Performs right-to-left function composition with async functions support\n *\n * @param fns - Functions\n * @returns Composed function\n */\nconst asyncCompose = (...fns) => async (value, ...args) => {\n    let result = value;\n    const reversedFns = fns.slice().reverse();\n    for (let i = 0; i < reversedFns.length; i += 1) {\n        const fn = reversedFns[i];\n        result = await fn(result, ...args);\n    }\n    return result;\n};\n\n/**\n * Capitalize first letter of each word\n *\n * @param value - Any string\n * @returns Capitalized string\n */\nconst capitalize = (value) => {\n    if (!value)\n        return value;\n    return value.replace(/(^|\\s)\\S/g, (l) => l.toUpperCase());\n};\n\n/**\n * Casts value to array\n *\n * @template T - The type of the value.\n * @param value - The value to cast into an array.\n * @returns An array containing the given value.\n */\nconst castArray = (value) => {\n    return Array.isArray(value) ? value : [value];\n};\n\n/**\n * Performs right-to-left function composition\n *\n * @param fns - Functions\n * @returns Composed function\n */\nconst compose = (...fns) => (value, ...args) => {\n    let result = value;\n    const reversedFns = fns.slice().reverse();\n    for (let i = 0; i < reversedFns.length; i += 1) {\n        const fn = reversedFns[i];\n        result = fn(result, ...args);\n    }\n    return result;\n};\n\n/**\n * Drops the last element from an array.\n *\n * @template T\n * @param  array - The array to drop the last element from\n * @returns - The new array with the last element dropped\n */\nconst dropLast = (array) => array.slice(0, array.length - 1);\n\n/**\n * Applies a set of transformations to an object and returns a new object with the transformed values.\n *\n * @template T\n * @param transformations - The transformations to apply.\n * @param object - The object to transform.\n * @returns The transformed object.\n */\nfunction evolve(transformations, object) {\n    const result = {};\n    const keys = Object.keys(object);\n    for (let i = 0; i < keys.length; i += 1) {\n        const key = keys[i];\n        const transformation = transformations[key];\n        if (typeof transformation === 'function') {\n            result[key] = transformation(object[key]);\n        }\n        else {\n            result[key] = object[key];\n        }\n    }\n    return result;\n}\n\n/**\n * Checks if a value is null or undefined.\n *\n * @template T - The type of the value.\n * @param value - The value to check\n * @returns True if the value is null or undefined, false otherwise\n */\nconst isNil = (value) => value === null || value === undefined;\n\n/**\n * Retrieves the value at a given path from an object.\n *\n * @param target - The object to retrieve the value from.\n * @param path - The path of the value to retrieve.\n * @param defaultValue - The default value to return if the path does not exist.\n * @returns The value at the given path, or the default value if the path does not exist.\n */\nconst get = (target, path, defaultValue) => {\n    if (isNil(target))\n        return defaultValue;\n    const _path = castArray(path);\n    let result = target;\n    for (let i = 0; i < _path.length; i += 1) {\n        if (isNil(result))\n            return undefined;\n        result = result[_path[i]];\n    }\n    return isNil(result) ? defaultValue : result;\n};\n\nfunction last(value) {\n    return value === '' ? '' : value[value.length - 1];\n}\n\n/**\n * Maps over the values of an object and applies a function to each value.\n *\n * @param object - The object to map over\n * @param fn - The function to apply to each value\n * @returns A new object with the mapped values\n */\nconst mapValues = (object, fn) => {\n    const entries = Object.entries(object);\n    const acc = {};\n    return entries.reduce((acc, [key, value], index) => {\n        acc[key] = fn(value, key, index);\n        return acc;\n    }, acc);\n};\n\nconst isPercent = (value) => /((-)?\\d+\\.?\\d*)%/g.exec(`${value}`);\n/**\n * Get percentage value of input\n *\n * @param value\n * @returns Percent value (if matches)\n */\nconst matchPercent = (value) => {\n    const match = isPercent(value);\n    if (match) {\n        const f = parseFloat(match[1]);\n        const percent = f / 100;\n        return { percent, value: f };\n    }\n    return null;\n};\n\n/**\n * Creates a new object by omitting specified keys from the original object.\n *\n * @param keys - The key or keys to omit\n * @param object - The original object\n * @returns The new object without the omitted keys\n */\nconst omit = (keys, object) => {\n    const _keys = castArray(keys);\n    const copy = Object.assign({}, object);\n    _keys.forEach((key) => {\n        delete copy[key];\n    });\n    return copy;\n};\n\n/**\n * Picks the specified keys from an object and returns a new object with only those keys.\n *\n * @param keys - The keys to pick from the object\n * @param object - The object to pick the keys from\n * @returns A new object with only the picked keys\n */\nconst pick = (keys, obj) => {\n    const result = {};\n    for (let i = 0; i < keys.length; i += 1) {\n        const key = keys[i];\n        if (key in obj)\n            result[key] = obj[key];\n    }\n    return result;\n};\n\n/**\n * Repeats an element a specified number of times.\n *\n * @template T\n * @param element - Element to be repeated\n * @param length - Number of times to repeat element\n * @returns Repeated elements\n */\nconst repeat = (element, length = 0) => {\n    const result = new Array(length);\n    for (let i = 0; i < length; i += 1) {\n        result[i] = element;\n    }\n    return result;\n};\n\n/**\n * Reverses the list\n *\n * @template T\n * @param list - List to be reversed\n * @returns Reversed list\n */\nconst reverse = (list) => Array.prototype.slice.call(list, 0).reverse();\n\n/**\n * Capitalize first letter of string\n *\n * @param value - String\n * @returns Capitalized string\n */\nconst upperFirst = (value) => {\n    if (!value)\n        return value;\n    return value.charAt(0).toUpperCase() + value.slice(1);\n};\n\n/**\n * Returns a new array with all the values from the original array that are not present in the keys array.\n *\n * @param keys - The keys to pick from the object\n * @param array - Array to filter the values from\n * @returns A new array with without the omitted values\n */\nconst without = (keys, array) => {\n    const result = [];\n    for (let i = 0; i < array.length; i += 1) {\n        const value = array[i];\n        if (!keys.includes(value))\n            result.push(value);\n    }\n    return result;\n};\n\n/**\n * Parse a string or number to a float\n *\n * @param value - String or number\n * @returns Parsed float\n */\nconst parseFloat$1 = (value) => {\n    return typeof value === 'string' ? Number.parseFloat(value) : value;\n};\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQHJlYWN0LXBkZitmbnNAMy4xLjIvbm9kZV9tb2R1bGVzL0ByZWFjdC1wZGYvZm5zL2xpYi9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyx3QkFBd0I7QUFDbkU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isd0JBQXdCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isd0JBQXdCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGlCQUFpQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUEseURBQXlELE1BQU07QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsaUJBQWlCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixZQUFZO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRTJNIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZGlzZWFzZS1wcmVkaWN0aW9uLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzLy5wbnBtL0ByZWFjdC1wZGYrZm5zQDMuMS4yL25vZGVfbW9kdWxlcy9AcmVhY3QtcGRmL2Zucy9saWIvaW5kZXguanM/YzExNSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEFwcGxpZXMgYSBmdW5jdGlvbiB0byB0aGUgdmFsdWUgYXQgdGhlIGdpdmVuIGluZGV4IG9mIGFuIGFycmF5XG4gKlxuICogQHBhcmFtIGluZGV4XG4gKiBAcGFyYW0gZm5cbiAqIEBwYXJhbSBjb2xsZWN0aW9uXG4gKiBAcmV0dXJucyBDb3B5IG9mIHRoZSBhcnJheSB3aXRoIHRoZSBlbGVtZW50IGF0IHRoZSBnaXZlbiBpbmRleCByZXBsYWNlZCB3aXRoIHRoZSByZXN1bHQgb2YgdGhlIGZ1bmN0aW9uIGFwcGxpY2F0aW9uLlxuICovXG5jb25zdCBhZGp1c3QgPSAoaW5kZXgsIGZuLCBjb2xsZWN0aW9uKSA9PiB7XG4gICAgaWYgKGluZGV4ID49IDAgJiYgaW5kZXggPj0gY29sbGVjdGlvbi5sZW5ndGgpXG4gICAgICAgIHJldHVybiBjb2xsZWN0aW9uO1xuICAgIGlmIChpbmRleCA8IDAgJiYgTWF0aC5hYnMoaW5kZXgpID4gY29sbGVjdGlvbi5sZW5ndGgpXG4gICAgICAgIHJldHVybiBjb2xsZWN0aW9uO1xuICAgIGNvbnN0IGkgPSBpbmRleCA8IDAgPyBjb2xsZWN0aW9uLmxlbmd0aCArIGluZGV4IDogaW5kZXg7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oW10sIGNvbGxlY3Rpb24sIHsgW2ldOiBmbihjb2xsZWN0aW9uW2ldKSB9KTtcbn07XG5cbi8qIGVzbGludC1kaXNhYmxlIG5vLWF3YWl0LWluLWxvb3AgKi9cbi8qKlxuICogUGVyZm9ybXMgcmlnaHQtdG8tbGVmdCBmdW5jdGlvbiBjb21wb3NpdGlvbiB3aXRoIGFzeW5jIGZ1bmN0aW9ucyBzdXBwb3J0XG4gKlxuICogQHBhcmFtIGZucyAtIEZ1bmN0aW9uc1xuICogQHJldHVybnMgQ29tcG9zZWQgZnVuY3Rpb25cbiAqL1xuY29uc3QgYXN5bmNDb21wb3NlID0gKC4uLmZucykgPT4gYXN5bmMgKHZhbHVlLCAuLi5hcmdzKSA9PiB7XG4gICAgbGV0IHJlc3VsdCA9IHZhbHVlO1xuICAgIGNvbnN0IHJldmVyc2VkRm5zID0gZm5zLnNsaWNlKCkucmV2ZXJzZSgpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmV2ZXJzZWRGbnMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgY29uc3QgZm4gPSByZXZlcnNlZEZuc1tpXTtcbiAgICAgICAgcmVzdWx0ID0gYXdhaXQgZm4ocmVzdWx0LCAuLi5hcmdzKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogQ2FwaXRhbGl6ZSBmaXJzdCBsZXR0ZXIgb2YgZWFjaCB3b3JkXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gQW55IHN0cmluZ1xuICogQHJldHVybnMgQ2FwaXRhbGl6ZWQgc3RyaW5nXG4gKi9cbmNvbnN0IGNhcGl0YWxpemUgPSAodmFsdWUpID0+IHtcbiAgICBpZiAoIXZhbHVlKVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgcmV0dXJuIHZhbHVlLnJlcGxhY2UoLyhefFxccylcXFMvZywgKGwpID0+IGwudG9VcHBlckNhc2UoKSk7XG59O1xuXG4vKipcbiAqIENhc3RzIHZhbHVlIHRvIGFycmF5XG4gKlxuICogQHRlbXBsYXRlIFQgLSBUaGUgdHlwZSBvZiB0aGUgdmFsdWUuXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gY2FzdCBpbnRvIGFuIGFycmF5LlxuICogQHJldHVybnMgQW4gYXJyYXkgY29udGFpbmluZyB0aGUgZ2l2ZW4gdmFsdWUuXG4gKi9cbmNvbnN0IGNhc3RBcnJheSA9ICh2YWx1ZSkgPT4ge1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KHZhbHVlKSA/IHZhbHVlIDogW3ZhbHVlXTtcbn07XG5cbi8qKlxuICogUGVyZm9ybXMgcmlnaHQtdG8tbGVmdCBmdW5jdGlvbiBjb21wb3NpdGlvblxuICpcbiAqIEBwYXJhbSBmbnMgLSBGdW5jdGlvbnNcbiAqIEByZXR1cm5zIENvbXBvc2VkIGZ1bmN0aW9uXG4gKi9cbmNvbnN0IGNvbXBvc2UgPSAoLi4uZm5zKSA9PiAodmFsdWUsIC4uLmFyZ3MpID0+IHtcbiAgICBsZXQgcmVzdWx0ID0gdmFsdWU7XG4gICAgY29uc3QgcmV2ZXJzZWRGbnMgPSBmbnMuc2xpY2UoKS5yZXZlcnNlKCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZXZlcnNlZEZucy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBjb25zdCBmbiA9IHJldmVyc2VkRm5zW2ldO1xuICAgICAgICByZXN1bHQgPSBmbihyZXN1bHQsIC4uLmFyZ3MpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBEcm9wcyB0aGUgbGFzdCBlbGVtZW50IGZyb20gYW4gYXJyYXkuXG4gKlxuICogQHRlbXBsYXRlIFRcbiAqIEBwYXJhbSAgYXJyYXkgLSBUaGUgYXJyYXkgdG8gZHJvcCB0aGUgbGFzdCBlbGVtZW50IGZyb21cbiAqIEByZXR1cm5zIC0gVGhlIG5ldyBhcnJheSB3aXRoIHRoZSBsYXN0IGVsZW1lbnQgZHJvcHBlZFxuICovXG5jb25zdCBkcm9wTGFzdCA9IChhcnJheSkgPT4gYXJyYXkuc2xpY2UoMCwgYXJyYXkubGVuZ3RoIC0gMSk7XG5cbi8qKlxuICogQXBwbGllcyBhIHNldCBvZiB0cmFuc2Zvcm1hdGlvbnMgdG8gYW4gb2JqZWN0IGFuZCByZXR1cm5zIGEgbmV3IG9iamVjdCB3aXRoIHRoZSB0cmFuc2Zvcm1lZCB2YWx1ZXMuXG4gKlxuICogQHRlbXBsYXRlIFRcbiAqIEBwYXJhbSB0cmFuc2Zvcm1hdGlvbnMgLSBUaGUgdHJhbnNmb3JtYXRpb25zIHRvIGFwcGx5LlxuICogQHBhcmFtIG9iamVjdCAtIFRoZSBvYmplY3QgdG8gdHJhbnNmb3JtLlxuICogQHJldHVybnMgVGhlIHRyYW5zZm9ybWVkIG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gZXZvbHZlKHRyYW5zZm9ybWF0aW9ucywgb2JqZWN0KSB7XG4gICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGNvbnN0IGtleSA9IGtleXNbaV07XG4gICAgICAgIGNvbnN0IHRyYW5zZm9ybWF0aW9uID0gdHJhbnNmb3JtYXRpb25zW2tleV07XG4gICAgICAgIGlmICh0eXBlb2YgdHJhbnNmb3JtYXRpb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHJlc3VsdFtrZXldID0gdHJhbnNmb3JtYXRpb24ob2JqZWN0W2tleV0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0W2tleV0gPSBvYmplY3Rba2V5XTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBhIHZhbHVlIGlzIG51bGwgb3IgdW5kZWZpbmVkLlxuICpcbiAqIEB0ZW1wbGF0ZSBUIC0gVGhlIHR5cGUgb2YgdGhlIHZhbHVlLlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGNoZWNrXG4gKiBAcmV0dXJucyBUcnVlIGlmIHRoZSB2YWx1ZSBpcyBudWxsIG9yIHVuZGVmaW5lZCwgZmFsc2Ugb3RoZXJ3aXNlXG4gKi9cbmNvbnN0IGlzTmlsID0gKHZhbHVlKSA9PiB2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkO1xuXG4vKipcbiAqIFJldHJpZXZlcyB0aGUgdmFsdWUgYXQgYSBnaXZlbiBwYXRoIGZyb20gYW4gb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB0YXJnZXQgLSBUaGUgb2JqZWN0IHRvIHJldHJpZXZlIHRoZSB2YWx1ZSBmcm9tLlxuICogQHBhcmFtIHBhdGggLSBUaGUgcGF0aCBvZiB0aGUgdmFsdWUgdG8gcmV0cmlldmUuXG4gKiBAcGFyYW0gZGVmYXVsdFZhbHVlIC0gVGhlIGRlZmF1bHQgdmFsdWUgdG8gcmV0dXJuIGlmIHRoZSBwYXRoIGRvZXMgbm90IGV4aXN0LlxuICogQHJldHVybnMgVGhlIHZhbHVlIGF0IHRoZSBnaXZlbiBwYXRoLCBvciB0aGUgZGVmYXVsdCB2YWx1ZSBpZiB0aGUgcGF0aCBkb2VzIG5vdCBleGlzdC5cbiAqL1xuY29uc3QgZ2V0ID0gKHRhcmdldCwgcGF0aCwgZGVmYXVsdFZhbHVlKSA9PiB7XG4gICAgaWYgKGlzTmlsKHRhcmdldCkpXG4gICAgICAgIHJldHVybiBkZWZhdWx0VmFsdWU7XG4gICAgY29uc3QgX3BhdGggPSBjYXN0QXJyYXkocGF0aCk7XG4gICAgbGV0IHJlc3VsdCA9IHRhcmdldDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IF9wYXRoLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGlmIChpc05pbChyZXN1bHQpKVxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgcmVzdWx0ID0gcmVzdWx0W19wYXRoW2ldXTtcbiAgICB9XG4gICAgcmV0dXJuIGlzTmlsKHJlc3VsdCkgPyBkZWZhdWx0VmFsdWUgOiByZXN1bHQ7XG59O1xuXG5mdW5jdGlvbiBsYXN0KHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSAnJyA/ICcnIDogdmFsdWVbdmFsdWUubGVuZ3RoIC0gMV07XG59XG5cbi8qKlxuICogTWFwcyBvdmVyIHRoZSB2YWx1ZXMgb2YgYW4gb2JqZWN0IGFuZCBhcHBsaWVzIGEgZnVuY3Rpb24gdG8gZWFjaCB2YWx1ZS5cbiAqXG4gKiBAcGFyYW0gb2JqZWN0IC0gVGhlIG9iamVjdCB0byBtYXAgb3ZlclxuICogQHBhcmFtIGZuIC0gVGhlIGZ1bmN0aW9uIHRvIGFwcGx5IHRvIGVhY2ggdmFsdWVcbiAqIEByZXR1cm5zIEEgbmV3IG9iamVjdCB3aXRoIHRoZSBtYXBwZWQgdmFsdWVzXG4gKi9cbmNvbnN0IG1hcFZhbHVlcyA9IChvYmplY3QsIGZuKSA9PiB7XG4gICAgY29uc3QgZW50cmllcyA9IE9iamVjdC5lbnRyaWVzKG9iamVjdCk7XG4gICAgY29uc3QgYWNjID0ge307XG4gICAgcmV0dXJuIGVudHJpZXMucmVkdWNlKChhY2MsIFtrZXksIHZhbHVlXSwgaW5kZXgpID0+IHtcbiAgICAgICAgYWNjW2tleV0gPSBmbih2YWx1ZSwga2V5LCBpbmRleCk7XG4gICAgICAgIHJldHVybiBhY2M7XG4gICAgfSwgYWNjKTtcbn07XG5cbmNvbnN0IGlzUGVyY2VudCA9ICh2YWx1ZSkgPT4gLygoLSk/XFxkK1xcLj9cXGQqKSUvZy5leGVjKGAke3ZhbHVlfWApO1xuLyoqXG4gKiBHZXQgcGVyY2VudGFnZSB2YWx1ZSBvZiBpbnB1dFxuICpcbiAqIEBwYXJhbSB2YWx1ZVxuICogQHJldHVybnMgUGVyY2VudCB2YWx1ZSAoaWYgbWF0Y2hlcylcbiAqL1xuY29uc3QgbWF0Y2hQZXJjZW50ID0gKHZhbHVlKSA9PiB7XG4gICAgY29uc3QgbWF0Y2ggPSBpc1BlcmNlbnQodmFsdWUpO1xuICAgIGlmIChtYXRjaCkge1xuICAgICAgICBjb25zdCBmID0gcGFyc2VGbG9hdChtYXRjaFsxXSk7XG4gICAgICAgIGNvbnN0IHBlcmNlbnQgPSBmIC8gMTAwO1xuICAgICAgICByZXR1cm4geyBwZXJjZW50LCB2YWx1ZTogZiB9O1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBvYmplY3QgYnkgb21pdHRpbmcgc3BlY2lmaWVkIGtleXMgZnJvbSB0aGUgb3JpZ2luYWwgb2JqZWN0LlxuICpcbiAqIEBwYXJhbSBrZXlzIC0gVGhlIGtleSBvciBrZXlzIHRvIG9taXRcbiAqIEBwYXJhbSBvYmplY3QgLSBUaGUgb3JpZ2luYWwgb2JqZWN0XG4gKiBAcmV0dXJucyBUaGUgbmV3IG9iamVjdCB3aXRob3V0IHRoZSBvbWl0dGVkIGtleXNcbiAqL1xuY29uc3Qgb21pdCA9IChrZXlzLCBvYmplY3QpID0+IHtcbiAgICBjb25zdCBfa2V5cyA9IGNhc3RBcnJheShrZXlzKTtcbiAgICBjb25zdCBjb3B5ID0gT2JqZWN0LmFzc2lnbih7fSwgb2JqZWN0KTtcbiAgICBfa2V5cy5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgZGVsZXRlIGNvcHlba2V5XTtcbiAgICB9KTtcbiAgICByZXR1cm4gY29weTtcbn07XG5cbi8qKlxuICogUGlja3MgdGhlIHNwZWNpZmllZCBrZXlzIGZyb20gYW4gb2JqZWN0IGFuZCByZXR1cm5zIGEgbmV3IG9iamVjdCB3aXRoIG9ubHkgdGhvc2Uga2V5cy5cbiAqXG4gKiBAcGFyYW0ga2V5cyAtIFRoZSBrZXlzIHRvIHBpY2sgZnJvbSB0aGUgb2JqZWN0XG4gKiBAcGFyYW0gb2JqZWN0IC0gVGhlIG9iamVjdCB0byBwaWNrIHRoZSBrZXlzIGZyb21cbiAqIEByZXR1cm5zIEEgbmV3IG9iamVjdCB3aXRoIG9ubHkgdGhlIHBpY2tlZCBrZXlzXG4gKi9cbmNvbnN0IHBpY2sgPSAoa2V5cywgb2JqKSA9PiB7XG4gICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGNvbnN0IGtleSA9IGtleXNbaV07XG4gICAgICAgIGlmIChrZXkgaW4gb2JqKVxuICAgICAgICAgICAgcmVzdWx0W2tleV0gPSBvYmpba2V5XTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogUmVwZWF0cyBhbiBlbGVtZW50IGEgc3BlY2lmaWVkIG51bWJlciBvZiB0aW1lcy5cbiAqXG4gKiBAdGVtcGxhdGUgVFxuICogQHBhcmFtIGVsZW1lbnQgLSBFbGVtZW50IHRvIGJlIHJlcGVhdGVkXG4gKiBAcGFyYW0gbGVuZ3RoIC0gTnVtYmVyIG9mIHRpbWVzIHRvIHJlcGVhdCBlbGVtZW50XG4gKiBAcmV0dXJucyBSZXBlYXRlZCBlbGVtZW50c1xuICovXG5jb25zdCByZXBlYXQgPSAoZWxlbWVudCwgbGVuZ3RoID0gMCkgPT4ge1xuICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBBcnJheShsZW5ndGgpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgcmVzdWx0W2ldID0gZWxlbWVudDtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogUmV2ZXJzZXMgdGhlIGxpc3RcbiAqXG4gKiBAdGVtcGxhdGUgVFxuICogQHBhcmFtIGxpc3QgLSBMaXN0IHRvIGJlIHJldmVyc2VkXG4gKiBAcmV0dXJucyBSZXZlcnNlZCBsaXN0XG4gKi9cbmNvbnN0IHJldmVyc2UgPSAobGlzdCkgPT4gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwobGlzdCwgMCkucmV2ZXJzZSgpO1xuXG4vKipcbiAqIENhcGl0YWxpemUgZmlyc3QgbGV0dGVyIG9mIHN0cmluZ1xuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFN0cmluZ1xuICogQHJldHVybnMgQ2FwaXRhbGl6ZWQgc3RyaW5nXG4gKi9cbmNvbnN0IHVwcGVyRmlyc3QgPSAodmFsdWUpID0+IHtcbiAgICBpZiAoIXZhbHVlKVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgcmV0dXJuIHZhbHVlLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgdmFsdWUuc2xpY2UoMSk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgYSBuZXcgYXJyYXkgd2l0aCBhbGwgdGhlIHZhbHVlcyBmcm9tIHRoZSBvcmlnaW5hbCBhcnJheSB0aGF0IGFyZSBub3QgcHJlc2VudCBpbiB0aGUga2V5cyBhcnJheS5cbiAqXG4gKiBAcGFyYW0ga2V5cyAtIFRoZSBrZXlzIHRvIHBpY2sgZnJvbSB0aGUgb2JqZWN0XG4gKiBAcGFyYW0gYXJyYXkgLSBBcnJheSB0byBmaWx0ZXIgdGhlIHZhbHVlcyBmcm9tXG4gKiBAcmV0dXJucyBBIG5ldyBhcnJheSB3aXRoIHdpdGhvdXQgdGhlIG9taXR0ZWQgdmFsdWVzXG4gKi9cbmNvbnN0IHdpdGhvdXQgPSAoa2V5cywgYXJyYXkpID0+IHtcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gYXJyYXlbaV07XG4gICAgICAgIGlmICgha2V5cy5pbmNsdWRlcyh2YWx1ZSkpXG4gICAgICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIFBhcnNlIGEgc3RyaW5nIG9yIG51bWJlciB0byBhIGZsb2F0XG4gKlxuICogQHBhcmFtIHZhbHVlIC0gU3RyaW5nIG9yIG51bWJlclxuICogQHJldHVybnMgUGFyc2VkIGZsb2F0XG4gKi9cbmNvbnN0IHBhcnNlRmxvYXQkMSA9ICh2YWx1ZSkgPT4ge1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnID8gTnVtYmVyLnBhcnNlRmxvYXQodmFsdWUpIDogdmFsdWU7XG59O1xuXG5leHBvcnQgeyBhZGp1c3QsIGFzeW5jQ29tcG9zZSwgY2FwaXRhbGl6ZSwgY2FzdEFycmF5LCBjb21wb3NlLCBkcm9wTGFzdCwgZXZvbHZlLCBnZXQsIGlzTmlsLCBsYXN0LCBtYXBWYWx1ZXMsIG1hdGNoUGVyY2VudCwgb21pdCwgcGFyc2VGbG9hdCQxIGFzIHBhcnNlRmxvYXQsIHBpY2ssIHJlcGVhdCwgcmV2ZXJzZSwgdXBwZXJGaXJzdCwgd2l0aG91dCB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@react-pdf+fns@3.1.2/node_modules/@react-pdf/fns/lib/index.js\n");

/***/ })

};
;