"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@react-pdf+png-js@3.0.0";
exports.ids = ["vendor-chunks/@react-pdf+png-js@3.0.0"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/@react-pdf+png-js@3.0.0/node_modules/@react-pdf/png-js/lib/png-js.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@react-pdf+png-js@3.0.0/node_modules/@react-pdf/png-js/lib/png-js.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ PNG)\n/* harmony export */ });\n/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! fs */ \"fs\");\n/* harmony import */ var zlib__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! zlib */ \"zlib\");\n\n\n\nclass PNG {\n  static decode(path, fn) {\n    {\n      return fs__WEBPACK_IMPORTED_MODULE_0__.readFile(path, (err, file) => {\n        const png = new PNG(file);\n        return png.decode(pixels => fn(pixels));\n      });\n    }\n  }\n  static load(path) {\n    {\n      const file = fs__WEBPACK_IMPORTED_MODULE_0__.readFileSync(path);\n      return new PNG(file);\n    }\n  }\n  constructor(data) {\n    let i;\n    this.data = data;\n    this.pos = 8; // Skip the default header\n\n    this.palette = [];\n    this.imgData = [];\n    this.transparency = {};\n    this.text = {};\n    while (true) {\n      const chunkSize = this.readUInt32();\n      let section = '';\n      for (i = 0; i < 4; i++) {\n        section += String.fromCharCode(this.data[this.pos++]);\n      }\n      switch (section) {\n        case 'IHDR':\n          // we can grab  interesting values from here (like width, height, etc)\n          this.width = this.readUInt32();\n          this.height = this.readUInt32();\n          this.bits = this.data[this.pos++];\n          this.colorType = this.data[this.pos++];\n          this.compressionMethod = this.data[this.pos++];\n          this.filterMethod = this.data[this.pos++];\n          this.interlaceMethod = this.data[this.pos++];\n          break;\n        case 'PLTE':\n          this.palette = this.read(chunkSize);\n          break;\n        case 'IDAT':\n          for (i = 0; i < chunkSize; i++) {\n            this.imgData.push(this.data[this.pos++]);\n          }\n          break;\n        case 'tRNS':\n          // This chunk can only occur once and it must occur after the\n          // PLTE chunk and before the IDAT chunk.\n          this.transparency = {};\n          switch (this.colorType) {\n            case 3:\n              // Indexed color, RGB. Each byte in this chunk is an alpha for\n              // the palette index in the PLTE (\"palette\") chunk up until the\n              // last non-opaque entry. Set up an array, stretching over all\n              // palette entries which will be 0 (opaque) or 1 (transparent).\n              this.transparency.indexed = this.read(chunkSize);\n              var short = 255 - this.transparency.indexed.length;\n              if (short > 0) {\n                for (i = 0; i < short; i++) {\n                  this.transparency.indexed.push(255);\n                }\n              }\n              break;\n            case 0:\n              // Greyscale. Corresponding to entries in the PLTE chunk.\n              // Grey is two bytes, range 0 .. (2 ^ bit-depth) - 1\n              this.transparency.grayscale = this.read(chunkSize)[0];\n              break;\n            case 2:\n              // True color with proper alpha channel.\n              this.transparency.rgb = this.read(chunkSize);\n              break;\n          }\n          break;\n        case 'tEXt':\n          var text = this.read(chunkSize);\n          var index = text.indexOf(0);\n          var key = String.fromCharCode.apply(String, text.slice(0, index));\n          this.text[key] = String.fromCharCode.apply(String, text.slice(index + 1));\n          break;\n        case 'IEND':\n          // we've got everything we need!\n          switch (this.colorType) {\n            case 0:\n            case 3:\n            case 4:\n              this.colors = 1;\n              break;\n            case 2:\n            case 6:\n              this.colors = 3;\n              break;\n          }\n          this.hasAlphaChannel = [4, 6].includes(this.colorType);\n          var colors = this.colors + (this.hasAlphaChannel ? 1 : 0);\n          this.pixelBitlength = this.bits * colors;\n          switch (this.colors) {\n            case 1:\n              this.colorSpace = 'DeviceGray';\n              break;\n            case 3:\n              this.colorSpace = 'DeviceRGB';\n              break;\n          }\n          this.imgData = Buffer.from(this.imgData);\n          return;\n        default:\n          // unknown (or unimportant) section, skip it\n          this.pos += chunkSize;\n      }\n      this.pos += 4; // Skip the CRC\n\n      if (this.pos > this.data.length) {\n        throw new Error('Incomplete or corrupt PNG file');\n      }\n    }\n  }\n  read(bytes) {\n    const result = new Array(bytes);\n    for (let i = 0; i < bytes; i++) {\n      result[i] = this.data[this.pos++];\n    }\n    return result;\n  }\n  readUInt32() {\n    const b1 = this.data[this.pos++] << 24;\n    const b2 = this.data[this.pos++] << 16;\n    const b3 = this.data[this.pos++] << 8;\n    const b4 = this.data[this.pos++];\n    return b1 | b2 | b3 | b4;\n  }\n  readUInt16() {\n    const b1 = this.data[this.pos++] << 8;\n    const b2 = this.data[this.pos++];\n    return b1 | b2;\n  }\n  decodePixels(fn) {\n    return zlib__WEBPACK_IMPORTED_MODULE_1__.inflate(this.imgData, (err, data) => {\n      if (err) throw err;\n      var pos = 0;\n      const {\n        width,\n        height\n      } = this;\n      var pixelBytes = this.pixelBitlength / 8;\n      const pixels = Buffer.alloc(width * height * pixelBytes);\n      function pass(x0, y0, dx, dy, singlePass) {\n        if (singlePass === void 0) {\n          singlePass = false;\n        }\n        const w = Math.ceil((width - x0) / dx);\n        const h = Math.ceil((height - y0) / dy);\n        const scanlineLength = pixelBytes * w;\n        const buffer = singlePass ? pixels : Buffer.alloc(scanlineLength * h);\n        let row = 0;\n        let c = 0;\n        while (row < h && pos < data.length) {\n          var byte;\n          var col;\n          var i;\n          var left;\n          var upper;\n          switch (data[pos++]) {\n            case 0:\n              // None\n              for (i = 0; i < scanlineLength; i++) {\n                buffer[c++] = data[pos++];\n              }\n              break;\n            case 1:\n              // Sub\n              for (i = 0; i < scanlineLength; i++) {\n                byte = data[pos++];\n                left = i < pixelBytes ? 0 : buffer[c - pixelBytes];\n                buffer[c++] = (byte + left) % 256;\n              }\n              break;\n            case 2:\n              // Up\n              for (i = 0; i < scanlineLength; i++) {\n                byte = data[pos++];\n                col = (i - i % pixelBytes) / pixelBytes;\n                upper = row && buffer[(row - 1) * scanlineLength + col * pixelBytes + i % pixelBytes];\n                buffer[c++] = (upper + byte) % 256;\n              }\n              break;\n            case 3:\n              // Average\n              for (i = 0; i < scanlineLength; i++) {\n                byte = data[pos++];\n                col = (i - i % pixelBytes) / pixelBytes;\n                left = i < pixelBytes ? 0 : buffer[c - pixelBytes];\n                upper = row && buffer[(row - 1) * scanlineLength + col * pixelBytes + i % pixelBytes];\n                buffer[c++] = (byte + Math.floor((left + upper) / 2)) % 256;\n              }\n              break;\n            case 4:\n              // Paeth\n              for (i = 0; i < scanlineLength; i++) {\n                var paeth;\n                var upperLeft;\n                byte = data[pos++];\n                col = (i - i % pixelBytes) / pixelBytes;\n                left = i < pixelBytes ? 0 : buffer[c - pixelBytes];\n                if (row === 0) {\n                  upper = upperLeft = 0;\n                } else {\n                  upper = buffer[(row - 1) * scanlineLength + col * pixelBytes + i % pixelBytes];\n                  upperLeft = col && buffer[(row - 1) * scanlineLength + (col - 1) * pixelBytes + i % pixelBytes];\n                }\n                const p = left + upper - upperLeft;\n                const pa = Math.abs(p - left);\n                const pb = Math.abs(p - upper);\n                const pc = Math.abs(p - upperLeft);\n                if (pa <= pb && pa <= pc) {\n                  paeth = left;\n                } else if (pb <= pc) {\n                  paeth = upper;\n                } else {\n                  paeth = upperLeft;\n                }\n                buffer[c++] = (byte + paeth) % 256;\n              }\n              break;\n            default:\n              throw new Error(`Invalid filter algorithm: ${data[pos - 1]}`);\n          }\n          if (!singlePass) {\n            let pixelsPos = ((y0 + row * dy) * width + x0) * pixelBytes;\n            let bufferPos = row * scanlineLength;\n            for (i = 0; i < w; i++) {\n              for (let j = 0; j < pixelBytes; j++) pixels[pixelsPos++] = buffer[bufferPos++];\n              pixelsPos += (dx - 1) * pixelBytes;\n            }\n          }\n          row++;\n        }\n      }\n      if (this.interlaceMethod === 1) {\n        /*\n          1 6 4 6 2 6 4 6\n          7 7 7 7 7 7 7 7\n          5 6 5 6 5 6 5 6\n          7 7 7 7 7 7 7 7\n          3 6 4 6 3 6 4 6\n          7 7 7 7 7 7 7 7\n          5 6 5 6 5 6 5 6\n          7 7 7 7 7 7 7 7\n        */\n        pass(0, 0, 8, 8); // 1\n        pass(4, 0, 8, 8); // 2\n        pass(0, 4, 4, 8); // 3\n        pass(2, 0, 4, 4); // 4\n        pass(0, 2, 2, 4); // 5\n        pass(1, 0, 2, 2); // 6\n        pass(0, 1, 1, 2); // 7\n      } else {\n        pass(0, 0, 1, 1, true);\n      }\n      return fn(pixels);\n    });\n  }\n  decodePalette() {\n    const {\n      palette\n    } = this;\n    const {\n      length\n    } = palette;\n    const transparency = this.transparency.indexed || [];\n    const ret = Buffer.alloc(transparency.length + length);\n    let pos = 0;\n    let c = 0;\n    for (let i = 0; i < length; i += 3) {\n      var left;\n      ret[pos++] = palette[i];\n      ret[pos++] = palette[i + 1];\n      ret[pos++] = palette[i + 2];\n      ret[pos++] = (left = transparency[c++]) != null ? left : 255;\n    }\n    return ret;\n  }\n  copyToImageData(imageData, pixels) {\n    let j;\n    var k;\n    let {\n      colors\n    } = this;\n    let palette = null;\n    let alpha = this.hasAlphaChannel;\n    if (this.palette.length) {\n      palette = this._decodedPalette || (this._decodedPalette = this.decodePalette());\n      colors = 4;\n      alpha = true;\n    }\n    const data = imageData.data || imageData;\n    const {\n      length\n    } = data;\n    const input = palette || pixels;\n    let i = j = 0;\n    if (colors === 1) {\n      while (i < length) {\n        k = palette ? pixels[i / 4] * 4 : j;\n        const v = input[k++];\n        data[i++] = v;\n        data[i++] = v;\n        data[i++] = v;\n        data[i++] = alpha ? input[k++] : 255;\n        j = k;\n      }\n    } else {\n      while (i < length) {\n        k = palette ? pixels[i / 4] * 4 : j;\n        data[i++] = input[k++];\n        data[i++] = input[k++];\n        data[i++] = input[k++];\n        data[i++] = alpha ? input[k++] : 255;\n        j = k;\n      }\n    }\n  }\n  decode(fn) {\n    const ret = Buffer.alloc(this.width * this.height * 4);\n    return this.decodePixels(pixels => {\n      this.copyToImageData(ret, pixels);\n      return fn(ret);\n    });\n  }\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQHJlYWN0LXBkZitwbmctanNAMy4wLjAvbm9kZV9tb2R1bGVzL0ByZWFjdC1wZGYvcG5nLWpzL2xpYi9wbmctanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQW9CO0FBQ0k7O0FBRXhCO0FBQ0E7QUFDQTtBQUNBLGFBQWEsd0NBQVc7QUFDeEI7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiw0Q0FBZTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7O0FBRWxCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLE9BQU87QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixlQUFlO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFdBQVc7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCOztBQUVyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixXQUFXO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHlDQUFZO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLG9CQUFvQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLG9CQUFvQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixvQkFBb0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixvQkFBb0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLG9CQUFvQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJELGNBQWM7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsT0FBTztBQUMvQiw4QkFBOEIsZ0JBQWdCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUIsMEJBQTBCO0FBQzFCLDBCQUEwQjtBQUMxQiwwQkFBMEI7QUFDMUIsMEJBQTBCO0FBQzFCLDBCQUEwQjtBQUMxQiwwQkFBMEI7QUFDMUIsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFlBQVk7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUUwQiIsInNvdXJjZXMiOlsid2VicGFjazovL2Rpc2Vhc2UtcHJlZGljdGlvbi1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy8ucG5wbS9AcmVhY3QtcGRmK3BuZy1qc0AzLjAuMC9ub2RlX21vZHVsZXMvQHJlYWN0LXBkZi9wbmctanMvbGliL3BuZy1qcy5qcz84NTE2Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBmcyBmcm9tICdmcyc7XG5pbXBvcnQgemxpYiBmcm9tICd6bGliJztcblxuY2xhc3MgUE5HIHtcbiAgc3RhdGljIGRlY29kZShwYXRoLCBmbikge1xuICAgIHtcbiAgICAgIHJldHVybiBmcy5yZWFkRmlsZShwYXRoLCAoZXJyLCBmaWxlKSA9PiB7XG4gICAgICAgIGNvbnN0IHBuZyA9IG5ldyBQTkcoZmlsZSk7XG4gICAgICAgIHJldHVybiBwbmcuZGVjb2RlKHBpeGVscyA9PiBmbihwaXhlbHMpKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBzdGF0aWMgbG9hZChwYXRoKSB7XG4gICAge1xuICAgICAgY29uc3QgZmlsZSA9IGZzLnJlYWRGaWxlU3luYyhwYXRoKTtcbiAgICAgIHJldHVybiBuZXcgUE5HKGZpbGUpO1xuICAgIH1cbiAgfVxuICBjb25zdHJ1Y3RvcihkYXRhKSB7XG4gICAgbGV0IGk7XG4gICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICB0aGlzLnBvcyA9IDg7IC8vIFNraXAgdGhlIGRlZmF1bHQgaGVhZGVyXG5cbiAgICB0aGlzLnBhbGV0dGUgPSBbXTtcbiAgICB0aGlzLmltZ0RhdGEgPSBbXTtcbiAgICB0aGlzLnRyYW5zcGFyZW5jeSA9IHt9O1xuICAgIHRoaXMudGV4dCA9IHt9O1xuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICBjb25zdCBjaHVua1NpemUgPSB0aGlzLnJlYWRVSW50MzIoKTtcbiAgICAgIGxldCBzZWN0aW9uID0gJyc7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgNDsgaSsrKSB7XG4gICAgICAgIHNlY3Rpb24gKz0gU3RyaW5nLmZyb21DaGFyQ29kZSh0aGlzLmRhdGFbdGhpcy5wb3MrK10pO1xuICAgICAgfVxuICAgICAgc3dpdGNoIChzZWN0aW9uKSB7XG4gICAgICAgIGNhc2UgJ0lIRFInOlxuICAgICAgICAgIC8vIHdlIGNhbiBncmFiICBpbnRlcmVzdGluZyB2YWx1ZXMgZnJvbSBoZXJlIChsaWtlIHdpZHRoLCBoZWlnaHQsIGV0YylcbiAgICAgICAgICB0aGlzLndpZHRoID0gdGhpcy5yZWFkVUludDMyKCk7XG4gICAgICAgICAgdGhpcy5oZWlnaHQgPSB0aGlzLnJlYWRVSW50MzIoKTtcbiAgICAgICAgICB0aGlzLmJpdHMgPSB0aGlzLmRhdGFbdGhpcy5wb3MrK107XG4gICAgICAgICAgdGhpcy5jb2xvclR5cGUgPSB0aGlzLmRhdGFbdGhpcy5wb3MrK107XG4gICAgICAgICAgdGhpcy5jb21wcmVzc2lvbk1ldGhvZCA9IHRoaXMuZGF0YVt0aGlzLnBvcysrXTtcbiAgICAgICAgICB0aGlzLmZpbHRlck1ldGhvZCA9IHRoaXMuZGF0YVt0aGlzLnBvcysrXTtcbiAgICAgICAgICB0aGlzLmludGVybGFjZU1ldGhvZCA9IHRoaXMuZGF0YVt0aGlzLnBvcysrXTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnUExURSc6XG4gICAgICAgICAgdGhpcy5wYWxldHRlID0gdGhpcy5yZWFkKGNodW5rU2l6ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ0lEQVQnOlxuICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBjaHVua1NpemU7IGkrKykge1xuICAgICAgICAgICAgdGhpcy5pbWdEYXRhLnB1c2godGhpcy5kYXRhW3RoaXMucG9zKytdKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3RSTlMnOlxuICAgICAgICAgIC8vIFRoaXMgY2h1bmsgY2FuIG9ubHkgb2NjdXIgb25jZSBhbmQgaXQgbXVzdCBvY2N1ciBhZnRlciB0aGVcbiAgICAgICAgICAvLyBQTFRFIGNodW5rIGFuZCBiZWZvcmUgdGhlIElEQVQgY2h1bmsuXG4gICAgICAgICAgdGhpcy50cmFuc3BhcmVuY3kgPSB7fTtcbiAgICAgICAgICBzd2l0Y2ggKHRoaXMuY29sb3JUeXBlKSB7XG4gICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgIC8vIEluZGV4ZWQgY29sb3IsIFJHQi4gRWFjaCBieXRlIGluIHRoaXMgY2h1bmsgaXMgYW4gYWxwaGEgZm9yXG4gICAgICAgICAgICAgIC8vIHRoZSBwYWxldHRlIGluZGV4IGluIHRoZSBQTFRFIChcInBhbGV0dGVcIikgY2h1bmsgdXAgdW50aWwgdGhlXG4gICAgICAgICAgICAgIC8vIGxhc3Qgbm9uLW9wYXF1ZSBlbnRyeS4gU2V0IHVwIGFuIGFycmF5LCBzdHJldGNoaW5nIG92ZXIgYWxsXG4gICAgICAgICAgICAgIC8vIHBhbGV0dGUgZW50cmllcyB3aGljaCB3aWxsIGJlIDAgKG9wYXF1ZSkgb3IgMSAodHJhbnNwYXJlbnQpLlxuICAgICAgICAgICAgICB0aGlzLnRyYW5zcGFyZW5jeS5pbmRleGVkID0gdGhpcy5yZWFkKGNodW5rU2l6ZSk7XG4gICAgICAgICAgICAgIHZhciBzaG9ydCA9IDI1NSAtIHRoaXMudHJhbnNwYXJlbmN5LmluZGV4ZWQubGVuZ3RoO1xuICAgICAgICAgICAgICBpZiAoc2hvcnQgPiAwKSB7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHNob3J0OyBpKyspIHtcbiAgICAgICAgICAgICAgICAgIHRoaXMudHJhbnNwYXJlbmN5LmluZGV4ZWQucHVzaCgyNTUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgLy8gR3JleXNjYWxlLiBDb3JyZXNwb25kaW5nIHRvIGVudHJpZXMgaW4gdGhlIFBMVEUgY2h1bmsuXG4gICAgICAgICAgICAgIC8vIEdyZXkgaXMgdHdvIGJ5dGVzLCByYW5nZSAwIC4uICgyIF4gYml0LWRlcHRoKSAtIDFcbiAgICAgICAgICAgICAgdGhpcy50cmFuc3BhcmVuY3kuZ3JheXNjYWxlID0gdGhpcy5yZWFkKGNodW5rU2l6ZSlbMF07XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAvLyBUcnVlIGNvbG9yIHdpdGggcHJvcGVyIGFscGhhIGNoYW5uZWwuXG4gICAgICAgICAgICAgIHRoaXMudHJhbnNwYXJlbmN5LnJnYiA9IHRoaXMucmVhZChjaHVua1NpemUpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3RFWHQnOlxuICAgICAgICAgIHZhciB0ZXh0ID0gdGhpcy5yZWFkKGNodW5rU2l6ZSk7XG4gICAgICAgICAgdmFyIGluZGV4ID0gdGV4dC5pbmRleE9mKDApO1xuICAgICAgICAgIHZhciBrZXkgPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZywgdGV4dC5zbGljZSgwLCBpbmRleCkpO1xuICAgICAgICAgIHRoaXMudGV4dFtrZXldID0gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsIHRleHQuc2xpY2UoaW5kZXggKyAxKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ0lFTkQnOlxuICAgICAgICAgIC8vIHdlJ3ZlIGdvdCBldmVyeXRoaW5nIHdlIG5lZWQhXG4gICAgICAgICAgc3dpdGNoICh0aGlzLmNvbG9yVHlwZSkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICB0aGlzLmNvbG9ycyA9IDE7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICB0aGlzLmNvbG9ycyA9IDM7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLmhhc0FscGhhQ2hhbm5lbCA9IFs0LCA2XS5pbmNsdWRlcyh0aGlzLmNvbG9yVHlwZSk7XG4gICAgICAgICAgdmFyIGNvbG9ycyA9IHRoaXMuY29sb3JzICsgKHRoaXMuaGFzQWxwaGFDaGFubmVsID8gMSA6IDApO1xuICAgICAgICAgIHRoaXMucGl4ZWxCaXRsZW5ndGggPSB0aGlzLmJpdHMgKiBjb2xvcnM7XG4gICAgICAgICAgc3dpdGNoICh0aGlzLmNvbG9ycykge1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICB0aGlzLmNvbG9yU3BhY2UgPSAnRGV2aWNlR3JheSc7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICB0aGlzLmNvbG9yU3BhY2UgPSAnRGV2aWNlUkdCJztcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuaW1nRGF0YSA9IEJ1ZmZlci5mcm9tKHRoaXMuaW1nRGF0YSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIC8vIHVua25vd24gKG9yIHVuaW1wb3J0YW50KSBzZWN0aW9uLCBza2lwIGl0XG4gICAgICAgICAgdGhpcy5wb3MgKz0gY2h1bmtTaXplO1xuICAgICAgfVxuICAgICAgdGhpcy5wb3MgKz0gNDsgLy8gU2tpcCB0aGUgQ1JDXG5cbiAgICAgIGlmICh0aGlzLnBvcyA+IHRoaXMuZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbmNvbXBsZXRlIG9yIGNvcnJ1cHQgUE5HIGZpbGUnKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmVhZChieXRlcykge1xuICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBBcnJheShieXRlcyk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBieXRlczsgaSsrKSB7XG4gICAgICByZXN1bHRbaV0gPSB0aGlzLmRhdGFbdGhpcy5wb3MrK107XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgcmVhZFVJbnQzMigpIHtcbiAgICBjb25zdCBiMSA9IHRoaXMuZGF0YVt0aGlzLnBvcysrXSA8PCAyNDtcbiAgICBjb25zdCBiMiA9IHRoaXMuZGF0YVt0aGlzLnBvcysrXSA8PCAxNjtcbiAgICBjb25zdCBiMyA9IHRoaXMuZGF0YVt0aGlzLnBvcysrXSA8PCA4O1xuICAgIGNvbnN0IGI0ID0gdGhpcy5kYXRhW3RoaXMucG9zKytdO1xuICAgIHJldHVybiBiMSB8IGIyIHwgYjMgfCBiNDtcbiAgfVxuICByZWFkVUludDE2KCkge1xuICAgIGNvbnN0IGIxID0gdGhpcy5kYXRhW3RoaXMucG9zKytdIDw8IDg7XG4gICAgY29uc3QgYjIgPSB0aGlzLmRhdGFbdGhpcy5wb3MrK107XG4gICAgcmV0dXJuIGIxIHwgYjI7XG4gIH1cbiAgZGVjb2RlUGl4ZWxzKGZuKSB7XG4gICAgcmV0dXJuIHpsaWIuaW5mbGF0ZSh0aGlzLmltZ0RhdGEsIChlcnIsIGRhdGEpID0+IHtcbiAgICAgIGlmIChlcnIpIHRocm93IGVycjtcbiAgICAgIHZhciBwb3MgPSAwO1xuICAgICAgY29uc3Qge1xuICAgICAgICB3aWR0aCxcbiAgICAgICAgaGVpZ2h0XG4gICAgICB9ID0gdGhpcztcbiAgICAgIHZhciBwaXhlbEJ5dGVzID0gdGhpcy5waXhlbEJpdGxlbmd0aCAvIDg7XG4gICAgICBjb25zdCBwaXhlbHMgPSBCdWZmZXIuYWxsb2Mod2lkdGggKiBoZWlnaHQgKiBwaXhlbEJ5dGVzKTtcbiAgICAgIGZ1bmN0aW9uIHBhc3MoeDAsIHkwLCBkeCwgZHksIHNpbmdsZVBhc3MpIHtcbiAgICAgICAgaWYgKHNpbmdsZVBhc3MgPT09IHZvaWQgMCkge1xuICAgICAgICAgIHNpbmdsZVBhc3MgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB3ID0gTWF0aC5jZWlsKCh3aWR0aCAtIHgwKSAvIGR4KTtcbiAgICAgICAgY29uc3QgaCA9IE1hdGguY2VpbCgoaGVpZ2h0IC0geTApIC8gZHkpO1xuICAgICAgICBjb25zdCBzY2FubGluZUxlbmd0aCA9IHBpeGVsQnl0ZXMgKiB3O1xuICAgICAgICBjb25zdCBidWZmZXIgPSBzaW5nbGVQYXNzID8gcGl4ZWxzIDogQnVmZmVyLmFsbG9jKHNjYW5saW5lTGVuZ3RoICogaCk7XG4gICAgICAgIGxldCByb3cgPSAwO1xuICAgICAgICBsZXQgYyA9IDA7XG4gICAgICAgIHdoaWxlIChyb3cgPCBoICYmIHBvcyA8IGRhdGEubGVuZ3RoKSB7XG4gICAgICAgICAgdmFyIGJ5dGU7XG4gICAgICAgICAgdmFyIGNvbDtcbiAgICAgICAgICB2YXIgaTtcbiAgICAgICAgICB2YXIgbGVmdDtcbiAgICAgICAgICB2YXIgdXBwZXI7XG4gICAgICAgICAgc3dpdGNoIChkYXRhW3BvcysrXSkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAvLyBOb25lXG4gICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBzY2FubGluZUxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgYnVmZmVyW2MrK10gPSBkYXRhW3BvcysrXTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgLy8gU3ViXG4gICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBzY2FubGluZUxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgYnl0ZSA9IGRhdGFbcG9zKytdO1xuICAgICAgICAgICAgICAgIGxlZnQgPSBpIDwgcGl4ZWxCeXRlcyA/IDAgOiBidWZmZXJbYyAtIHBpeGVsQnl0ZXNdO1xuICAgICAgICAgICAgICAgIGJ1ZmZlcltjKytdID0gKGJ5dGUgKyBsZWZ0KSAlIDI1NjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgLy8gVXBcbiAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHNjYW5saW5lTGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBieXRlID0gZGF0YVtwb3MrK107XG4gICAgICAgICAgICAgICAgY29sID0gKGkgLSBpICUgcGl4ZWxCeXRlcykgLyBwaXhlbEJ5dGVzO1xuICAgICAgICAgICAgICAgIHVwcGVyID0gcm93ICYmIGJ1ZmZlclsocm93IC0gMSkgKiBzY2FubGluZUxlbmd0aCArIGNvbCAqIHBpeGVsQnl0ZXMgKyBpICUgcGl4ZWxCeXRlc107XG4gICAgICAgICAgICAgICAgYnVmZmVyW2MrK10gPSAodXBwZXIgKyBieXRlKSAlIDI1NjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgLy8gQXZlcmFnZVxuICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgc2NhbmxpbmVMZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGJ5dGUgPSBkYXRhW3BvcysrXTtcbiAgICAgICAgICAgICAgICBjb2wgPSAoaSAtIGkgJSBwaXhlbEJ5dGVzKSAvIHBpeGVsQnl0ZXM7XG4gICAgICAgICAgICAgICAgbGVmdCA9IGkgPCBwaXhlbEJ5dGVzID8gMCA6IGJ1ZmZlcltjIC0gcGl4ZWxCeXRlc107XG4gICAgICAgICAgICAgICAgdXBwZXIgPSByb3cgJiYgYnVmZmVyWyhyb3cgLSAxKSAqIHNjYW5saW5lTGVuZ3RoICsgY29sICogcGl4ZWxCeXRlcyArIGkgJSBwaXhlbEJ5dGVzXTtcbiAgICAgICAgICAgICAgICBidWZmZXJbYysrXSA9IChieXRlICsgTWF0aC5mbG9vcigobGVmdCArIHVwcGVyKSAvIDIpKSAlIDI1NjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgLy8gUGFldGhcbiAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHNjYW5saW5lTGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgcGFldGg7XG4gICAgICAgICAgICAgICAgdmFyIHVwcGVyTGVmdDtcbiAgICAgICAgICAgICAgICBieXRlID0gZGF0YVtwb3MrK107XG4gICAgICAgICAgICAgICAgY29sID0gKGkgLSBpICUgcGl4ZWxCeXRlcykgLyBwaXhlbEJ5dGVzO1xuICAgICAgICAgICAgICAgIGxlZnQgPSBpIDwgcGl4ZWxCeXRlcyA/IDAgOiBidWZmZXJbYyAtIHBpeGVsQnl0ZXNdO1xuICAgICAgICAgICAgICAgIGlmIChyb3cgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgIHVwcGVyID0gdXBwZXJMZWZ0ID0gMDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgdXBwZXIgPSBidWZmZXJbKHJvdyAtIDEpICogc2NhbmxpbmVMZW5ndGggKyBjb2wgKiBwaXhlbEJ5dGVzICsgaSAlIHBpeGVsQnl0ZXNdO1xuICAgICAgICAgICAgICAgICAgdXBwZXJMZWZ0ID0gY29sICYmIGJ1ZmZlclsocm93IC0gMSkgKiBzY2FubGluZUxlbmd0aCArIChjb2wgLSAxKSAqIHBpeGVsQnl0ZXMgKyBpICUgcGl4ZWxCeXRlc107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHAgPSBsZWZ0ICsgdXBwZXIgLSB1cHBlckxlZnQ7XG4gICAgICAgICAgICAgICAgY29uc3QgcGEgPSBNYXRoLmFicyhwIC0gbGVmdCk7XG4gICAgICAgICAgICAgICAgY29uc3QgcGIgPSBNYXRoLmFicyhwIC0gdXBwZXIpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHBjID0gTWF0aC5hYnMocCAtIHVwcGVyTGVmdCk7XG4gICAgICAgICAgICAgICAgaWYgKHBhIDw9IHBiICYmIHBhIDw9IHBjKSB7XG4gICAgICAgICAgICAgICAgICBwYWV0aCA9IGxlZnQ7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChwYiA8PSBwYykge1xuICAgICAgICAgICAgICAgICAgcGFldGggPSB1cHBlcjtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgcGFldGggPSB1cHBlckxlZnQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJ1ZmZlcltjKytdID0gKGJ5dGUgKyBwYWV0aCkgJSAyNTY7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgZmlsdGVyIGFsZ29yaXRobTogJHtkYXRhW3BvcyAtIDFdfWApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIXNpbmdsZVBhc3MpIHtcbiAgICAgICAgICAgIGxldCBwaXhlbHNQb3MgPSAoKHkwICsgcm93ICogZHkpICogd2lkdGggKyB4MCkgKiBwaXhlbEJ5dGVzO1xuICAgICAgICAgICAgbGV0IGJ1ZmZlclBvcyA9IHJvdyAqIHNjYW5saW5lTGVuZ3RoO1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHc7IGkrKykge1xuICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHBpeGVsQnl0ZXM7IGorKykgcGl4ZWxzW3BpeGVsc1BvcysrXSA9IGJ1ZmZlcltidWZmZXJQb3MrK107XG4gICAgICAgICAgICAgIHBpeGVsc1BvcyArPSAoZHggLSAxKSAqIHBpeGVsQnl0ZXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJvdysrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5pbnRlcmxhY2VNZXRob2QgPT09IDEpIHtcbiAgICAgICAgLypcbiAgICAgICAgICAxIDYgNCA2IDIgNiA0IDZcbiAgICAgICAgICA3IDcgNyA3IDcgNyA3IDdcbiAgICAgICAgICA1IDYgNSA2IDUgNiA1IDZcbiAgICAgICAgICA3IDcgNyA3IDcgNyA3IDdcbiAgICAgICAgICAzIDYgNCA2IDMgNiA0IDZcbiAgICAgICAgICA3IDcgNyA3IDcgNyA3IDdcbiAgICAgICAgICA1IDYgNSA2IDUgNiA1IDZcbiAgICAgICAgICA3IDcgNyA3IDcgNyA3IDdcbiAgICAgICAgKi9cbiAgICAgICAgcGFzcygwLCAwLCA4LCA4KTsgLy8gMVxuICAgICAgICBwYXNzKDQsIDAsIDgsIDgpOyAvLyAyXG4gICAgICAgIHBhc3MoMCwgNCwgNCwgOCk7IC8vIDNcbiAgICAgICAgcGFzcygyLCAwLCA0LCA0KTsgLy8gNFxuICAgICAgICBwYXNzKDAsIDIsIDIsIDQpOyAvLyA1XG4gICAgICAgIHBhc3MoMSwgMCwgMiwgMik7IC8vIDZcbiAgICAgICAgcGFzcygwLCAxLCAxLCAyKTsgLy8gN1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGFzcygwLCAwLCAxLCAxLCB0cnVlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmbihwaXhlbHMpO1xuICAgIH0pO1xuICB9XG4gIGRlY29kZVBhbGV0dGUoKSB7XG4gICAgY29uc3Qge1xuICAgICAgcGFsZXR0ZVxuICAgIH0gPSB0aGlzO1xuICAgIGNvbnN0IHtcbiAgICAgIGxlbmd0aFxuICAgIH0gPSBwYWxldHRlO1xuICAgIGNvbnN0IHRyYW5zcGFyZW5jeSA9IHRoaXMudHJhbnNwYXJlbmN5LmluZGV4ZWQgfHwgW107XG4gICAgY29uc3QgcmV0ID0gQnVmZmVyLmFsbG9jKHRyYW5zcGFyZW5jeS5sZW5ndGggKyBsZW5ndGgpO1xuICAgIGxldCBwb3MgPSAwO1xuICAgIGxldCBjID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAzKSB7XG4gICAgICB2YXIgbGVmdDtcbiAgICAgIHJldFtwb3MrK10gPSBwYWxldHRlW2ldO1xuICAgICAgcmV0W3BvcysrXSA9IHBhbGV0dGVbaSArIDFdO1xuICAgICAgcmV0W3BvcysrXSA9IHBhbGV0dGVbaSArIDJdO1xuICAgICAgcmV0W3BvcysrXSA9IChsZWZ0ID0gdHJhbnNwYXJlbmN5W2MrK10pICE9IG51bGwgPyBsZWZ0IDogMjU1O1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9XG4gIGNvcHlUb0ltYWdlRGF0YShpbWFnZURhdGEsIHBpeGVscykge1xuICAgIGxldCBqO1xuICAgIHZhciBrO1xuICAgIGxldCB7XG4gICAgICBjb2xvcnNcbiAgICB9ID0gdGhpcztcbiAgICBsZXQgcGFsZXR0ZSA9IG51bGw7XG4gICAgbGV0IGFscGhhID0gdGhpcy5oYXNBbHBoYUNoYW5uZWw7XG4gICAgaWYgKHRoaXMucGFsZXR0ZS5sZW5ndGgpIHtcbiAgICAgIHBhbGV0dGUgPSB0aGlzLl9kZWNvZGVkUGFsZXR0ZSB8fCAodGhpcy5fZGVjb2RlZFBhbGV0dGUgPSB0aGlzLmRlY29kZVBhbGV0dGUoKSk7XG4gICAgICBjb2xvcnMgPSA0O1xuICAgICAgYWxwaGEgPSB0cnVlO1xuICAgIH1cbiAgICBjb25zdCBkYXRhID0gaW1hZ2VEYXRhLmRhdGEgfHwgaW1hZ2VEYXRhO1xuICAgIGNvbnN0IHtcbiAgICAgIGxlbmd0aFxuICAgIH0gPSBkYXRhO1xuICAgIGNvbnN0IGlucHV0ID0gcGFsZXR0ZSB8fCBwaXhlbHM7XG4gICAgbGV0IGkgPSBqID0gMDtcbiAgICBpZiAoY29sb3JzID09PSAxKSB7XG4gICAgICB3aGlsZSAoaSA8IGxlbmd0aCkge1xuICAgICAgICBrID0gcGFsZXR0ZSA/IHBpeGVsc1tpIC8gNF0gKiA0IDogajtcbiAgICAgICAgY29uc3QgdiA9IGlucHV0W2srK107XG4gICAgICAgIGRhdGFbaSsrXSA9IHY7XG4gICAgICAgIGRhdGFbaSsrXSA9IHY7XG4gICAgICAgIGRhdGFbaSsrXSA9IHY7XG4gICAgICAgIGRhdGFbaSsrXSA9IGFscGhhID8gaW5wdXRbaysrXSA6IDI1NTtcbiAgICAgICAgaiA9IGs7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHdoaWxlIChpIDwgbGVuZ3RoKSB7XG4gICAgICAgIGsgPSBwYWxldHRlID8gcGl4ZWxzW2kgLyA0XSAqIDQgOiBqO1xuICAgICAgICBkYXRhW2krK10gPSBpbnB1dFtrKytdO1xuICAgICAgICBkYXRhW2krK10gPSBpbnB1dFtrKytdO1xuICAgICAgICBkYXRhW2krK10gPSBpbnB1dFtrKytdO1xuICAgICAgICBkYXRhW2krK10gPSBhbHBoYSA/IGlucHV0W2srK10gOiAyNTU7XG4gICAgICAgIGogPSBrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBkZWNvZGUoZm4pIHtcbiAgICBjb25zdCByZXQgPSBCdWZmZXIuYWxsb2ModGhpcy53aWR0aCAqIHRoaXMuaGVpZ2h0ICogNCk7XG4gICAgcmV0dXJuIHRoaXMuZGVjb2RlUGl4ZWxzKHBpeGVscyA9PiB7XG4gICAgICB0aGlzLmNvcHlUb0ltYWdlRGF0YShyZXQsIHBpeGVscyk7XG4gICAgICByZXR1cm4gZm4ocmV0KTtcbiAgICB9KTtcbiAgfVxufVxuXG5leHBvcnQgeyBQTkcgYXMgZGVmYXVsdCB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@react-pdf+png-js@3.0.0/node_modules/@react-pdf/png-js/lib/png-js.js\n");

/***/ })

};
;