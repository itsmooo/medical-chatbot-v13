"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@react-pdf+layout@4.4.0";
exports.ids = ["vendor-chunks/@react-pdf+layout@4.4.0"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/@react-pdf+layout@4.4.0/node_modules/@react-pdf/layout/lib/index.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@react-pdf+layout@4.4.0/node_modules/@react-pdf/layout/lib/index.js ***!
  \************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ layout)\n/* harmony export */ });\n/* harmony import */ var _react_pdf_fns__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @react-pdf/fns */ \"(ssr)/./node_modules/.pnpm/@react-pdf+fns@3.1.2/node_modules/@react-pdf/fns/lib/index.js\");\n/* harmony import */ var _react_pdf_primitives__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @react-pdf/primitives */ \"(ssr)/./node_modules/.pnpm/@react-pdf+primitives@4.1.1/node_modules/@react-pdf/primitives/lib/index.js\");\n/* harmony import */ var _react_pdf_stylesheet__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @react-pdf/stylesheet */ \"(ssr)/./node_modules/.pnpm/@react-pdf+stylesheet@6.1.0/node_modules/@react-pdf/stylesheet/lib/index.js\");\n/* harmony import */ var _react_pdf_textkit__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @react-pdf/textkit */ \"(ssr)/./node_modules/.pnpm/@react-pdf+textkit@6.0.0/node_modules/@react-pdf/textkit/lib/textkit.js\");\n/* harmony import */ var yoga_layout_load__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! yoga-layout/load */ \"(ssr)/./node_modules/.pnpm/yoga-layout@3.2.1/node_modules/yoga-layout/dist/src/load.js\");\n/* harmony import */ var emoji_regex__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! emoji-regex */ \"(ssr)/./node_modules/.pnpm/emoji-regex@10.4.0/node_modules/emoji-regex/index.js\");\n/* harmony import */ var _react_pdf_image__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @react-pdf/image */ \"(ssr)/./node_modules/.pnpm/@react-pdf+image@3.0.3/node_modules/@react-pdf/image/lib/index.js\");\n\n\n\n\n\n\n\n\n\n/**\n * Apply transformation to text string\n *\n * @param {string} text\n * @param {string} transformation type\n * @returns {string} transformed text\n */\nconst transformText = (text, transformation) => {\n    switch (transformation) {\n        case 'uppercase':\n            return text.toUpperCase();\n        case 'lowercase':\n            return text.toLowerCase();\n        case 'capitalize':\n            return (0,_react_pdf_fns__WEBPACK_IMPORTED_MODULE_0__.capitalize)(text);\n        case 'upperfirst':\n            return (0,_react_pdf_fns__WEBPACK_IMPORTED_MODULE_0__.upperFirst)(text);\n        default:\n            return text;\n    }\n};\n\nconst isTspan = (node) => node.type === _react_pdf_primitives__WEBPACK_IMPORTED_MODULE_1__.Tspan;\nconst isTextInstance$4 = (node) => node.type === _react_pdf_primitives__WEBPACK_IMPORTED_MODULE_1__.TextInstance;\nconst engines$1 = {\n    bidi: _react_pdf_textkit__WEBPACK_IMPORTED_MODULE_3__.bidi,\n    linebreaker: _react_pdf_textkit__WEBPACK_IMPORTED_MODULE_3__.linebreaker,\n    justification: _react_pdf_textkit__WEBPACK_IMPORTED_MODULE_3__.justification,\n    textDecoration: _react_pdf_textkit__WEBPACK_IMPORTED_MODULE_3__.textDecoration,\n    scriptItemizer: _react_pdf_textkit__WEBPACK_IMPORTED_MODULE_3__.scriptItemizer,\n    wordHyphenation: _react_pdf_textkit__WEBPACK_IMPORTED_MODULE_3__.wordHyphenation,\n    fontSubstitution: _react_pdf_textkit__WEBPACK_IMPORTED_MODULE_3__.fontSubstitution,\n};\nconst engine$1 = (0,_react_pdf_textkit__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(engines$1);\nconst getFragments$1 = (fontStore, instance) => {\n    if (!instance)\n        return [{ string: '' }];\n    const fragments = [];\n    const { fill = 'black', fontFamily = 'Helvetica', fontWeight, fontStyle, fontSize = 18, textDecorationColor, textDecorationStyle, textTransform, opacity, } = instance.props;\n    const _textDecoration = instance.props.textDecoration;\n    const fontFamilies = typeof fontFamily === 'string' ? [fontFamily] : [...(fontFamily || [])];\n    // Fallback font\n    fontFamilies.push('Helvetica');\n    const font = fontFamilies.map((fontFamilyName) => {\n        const opts = { fontFamily: fontFamilyName, fontWeight, fontStyle };\n        const obj = fontStore.getFont(opts);\n        return obj?.data;\n    });\n    const attributes = {\n        font,\n        opacity,\n        fontSize,\n        color: fill,\n        underlineStyle: textDecorationStyle,\n        underline: _textDecoration === 'underline' ||\n            _textDecoration === 'underline line-through' ||\n            _textDecoration === 'line-through underline',\n        underlineColor: textDecorationColor || fill,\n        strike: _textDecoration === 'line-through' ||\n            _textDecoration === 'underline line-through' ||\n            _textDecoration === 'line-through underline',\n        strikeStyle: textDecorationStyle,\n        strikeColor: textDecorationColor || fill,\n    };\n    for (let i = 0; i < instance.children.length; i += 1) {\n        const child = instance.children[i];\n        if (isTextInstance$4(child)) {\n            fragments.push({\n                string: transformText(child.value, textTransform),\n                attributes,\n            });\n        }\n        else if (child) {\n            fragments.push(...getFragments$1(fontStore, child));\n        }\n    }\n    return fragments;\n};\nconst getAttributedString$1 = (fontStore, instance) => (0,_react_pdf_textkit__WEBPACK_IMPORTED_MODULE_3__.fromFragments)(getFragments$1(fontStore, instance));\nconst AlmostInfinity = 999999999999;\nconst shrinkWhitespaceFactor = { before: -0.5, after: -0.5 };\nconst layoutTspan = (fontStore) => (node, xOffset) => {\n    const attributedString = getAttributedString$1(fontStore, node);\n    const x = node.props.x === undefined ? xOffset : node.props.x;\n    const y = node.props?.y || 0;\n    const container = { x, y, width: AlmostInfinity, height: AlmostInfinity };\n    const hyphenationCallback = node.props.hyphenationCallback ||\n        fontStore?.getHyphenationCallback() ||\n        null;\n    const layoutOptions = { hyphenationCallback, shrinkWhitespaceFactor };\n    const lines = engine$1(attributedString, container, layoutOptions).flat();\n    return Object.assign({}, node, { lines });\n};\n// Consecutive TSpan elements should be joined with a space\nconst joinTSpanLines = (node) => {\n    const children = node.children.map((child, index) => {\n        if (!isTspan(child))\n            return child;\n        const textInstance = child.children[0];\n        if (child.props.x === undefined &&\n            index < node.children.length - 1 &&\n            textInstance?.value) {\n            return Object.assign({}, child, {\n                children: [{ ...textInstance, value: `${textInstance.value} ` }],\n            });\n        }\n        return child;\n    }, []);\n    return Object.assign({}, node, { children });\n};\nconst layoutText$1 = (fontStore, node) => {\n    if (!node.children)\n        return node;\n    let currentXOffset = node.props?.x || 0;\n    const layoutFn = layoutTspan(fontStore);\n    const joinedNode = joinTSpanLines(node);\n    const children = joinedNode.children.map((child) => {\n        const childWithLayout = layoutFn(child, currentXOffset);\n        currentXOffset += childWithLayout.lines[0].xAdvance;\n        return childWithLayout;\n    });\n    return Object.assign({}, node, { children });\n};\n\nconst isDefs = (node) => node.type === _react_pdf_primitives__WEBPACK_IMPORTED_MODULE_1__.Defs;\nconst getDefs = (node) => {\n    const children = node.children || [];\n    const defs = children.find(isDefs);\n    const values = defs?.children || [];\n    return values.reduce((acc, value) => {\n        const id = value.props?.id;\n        if (id)\n            acc[id] = value;\n        return acc;\n    }, {});\n};\n\nconst isNotDefs = (node) => node.type !== _react_pdf_primitives__WEBPACK_IMPORTED_MODULE_1__.Defs;\nconst detachDefs = (node) => {\n    if (!node.children)\n        return node;\n    const children = node.children.filter(isNotDefs);\n    return Object.assign({}, node, { children });\n};\nconst URL_REGEX = /url\\(['\"]?#([^'\"]+)['\"]?\\)/;\nconst replaceDef = (defs, value) => {\n    if (!value)\n        return undefined;\n    if (!URL_REGEX.test(value))\n        return value;\n    const match = value.match(URL_REGEX);\n    return defs[match[1]];\n};\nconst parseNodeDefs = (defs) => (node) => {\n    const props = node.props;\n    const fill = `fill` in props ? replaceDef(defs, props?.fill) : undefined;\n    const clipPath = `clipPath` in props\n        ? replaceDef(defs, props?.clipPath)\n        : undefined;\n    const newProps = Object.assign({}, node.props, { fill, clipPath });\n    const children = node.children\n        ? node.children.map(parseNodeDefs(defs))\n        : undefined;\n    return Object.assign({}, node, { props: newProps, children });\n};\nconst parseDefs = (root) => {\n    if (!root.children)\n        return root;\n    const defs = getDefs(root);\n    const children = root.children.map(parseNodeDefs(defs));\n    return Object.assign({}, root, { children });\n};\nconst replaceDefs = (node) => {\n    return detachDefs(parseDefs(node));\n};\n\nconst parseViewbox = (value) => {\n    if (!value)\n        return null;\n    if (typeof value !== 'string')\n        return value;\n    const values = value.split(/[,\\s]+/).map(_react_pdf_fns__WEBPACK_IMPORTED_MODULE_0__.parseFloat);\n    if (values.length !== 4)\n        return null;\n    return { minX: values[0], minY: values[1], maxX: values[2], maxY: values[3] };\n};\n\nconst getContainer$1 = (node) => {\n    const viewbox = parseViewbox(node.props.viewBox);\n    if (viewbox) {\n        return { width: viewbox.maxX, height: viewbox.maxY };\n    }\n    if (node.props.width && node.props.height) {\n        return {\n            width: (0,_react_pdf_fns__WEBPACK_IMPORTED_MODULE_0__.parseFloat)(node.props.width),\n            height: (0,_react_pdf_fns__WEBPACK_IMPORTED_MODULE_0__.parseFloat)(node.props.height),\n        };\n    }\n    return { width: 0, height: 0 };\n};\n\nconst BASE_SVG_INHERITED_PROPS = [\n    'x',\n    'y',\n    'clipPath',\n    'clipRule',\n    'opacity',\n    'fill',\n    'fillOpacity',\n    'fillRule',\n    'stroke',\n    'strokeLinecap',\n    'strokeLinejoin',\n    'strokeOpacity',\n    'strokeWidth',\n    'textAnchor',\n    'dominantBaseline',\n    'color',\n    'fontFamily',\n    'fontSize',\n    'fontStyle',\n    'fontWeight',\n    'letterSpacing',\n    'opacity',\n    'textDecoration',\n    'lineHeight',\n    'textAlign',\n    'visibility',\n    'wordSpacing',\n];\n// Do not inherit \"x\" for <tspan> elements from <text> parent\nconst TEXT_SVG_INHERITED_PROPS = (0,_react_pdf_fns__WEBPACK_IMPORTED_MODULE_0__.without)(['x'], BASE_SVG_INHERITED_PROPS);\nconst SVG_INHERITED_PROPS = {\n    [_react_pdf_primitives__WEBPACK_IMPORTED_MODULE_1__.Text]: TEXT_SVG_INHERITED_PROPS,\n};\nconst getInheritProps = (node) => {\n    const props = node.props || {};\n    const svgInheritedProps = SVG_INHERITED_PROPS[node.type] ?? BASE_SVG_INHERITED_PROPS;\n    return (0,_react_pdf_fns__WEBPACK_IMPORTED_MODULE_0__.pick)(svgInheritedProps, props);\n};\nconst inheritProps = (node) => {\n    if (!node.children)\n        return node;\n    const inheritedProps = getInheritProps(node);\n    const children = node.children.map((child) => {\n        const props = Object.assign({}, inheritedProps, child.props || {});\n        const newChild = Object.assign({}, child, { props });\n        return inheritProps(newChild);\n    });\n    return Object.assign({}, node, { children });\n};\n\nconst parseAspectRatio = (value) => {\n    if (typeof value !== 'string')\n        return value;\n    const match = value\n        .replace(/[\\s\\r\\t\\n]+/gm, ' ')\n        .replace(/^defer\\s/, '')\n        .split(' ');\n    const align = (match[0] || 'xMidYMid');\n    const meetOrSlice = (match[1] ||\n        'meet');\n    return { align, meetOrSlice };\n};\n\nconst STYLE_PROPS = [\n    'width',\n    'height',\n    'color',\n    'stroke',\n    'strokeWidth',\n    'opacity',\n    'fillOpacity',\n    'strokeOpacity',\n    'fill',\n    'fillRule',\n    'clipPath',\n    'offset',\n    'transform',\n    'strokeLinejoin',\n    'strokeLinecap',\n    'strokeDasharray',\n    'gradientUnits',\n    'gradientTransform',\n];\nconst VERTICAL_PROPS = ['y', 'y1', 'y2', 'height', 'cy', 'ry'];\nconst HORIZONTAL_PROPS = ['x', 'x1', 'x2', 'width', 'cx', 'rx'];\nconst isSvg$3 = (node) => node.type === _react_pdf_primitives__WEBPACK_IMPORTED_MODULE_1__.Svg;\nconst isText$5 = (node) => node.type === _react_pdf_primitives__WEBPACK_IMPORTED_MODULE_1__.Text;\nconst isTextInstance$3 = (node) => node.type === _react_pdf_primitives__WEBPACK_IMPORTED_MODULE_1__.TextInstance;\nconst transformPercent = (container) => (props) => (0,_react_pdf_fns__WEBPACK_IMPORTED_MODULE_0__.mapValues)(props, (value, key) => {\n    const match = (0,_react_pdf_fns__WEBPACK_IMPORTED_MODULE_0__.matchPercent)(value);\n    if (match && VERTICAL_PROPS.includes(key)) {\n        return match.percent * container.height;\n    }\n    if (match && HORIZONTAL_PROPS.includes(key)) {\n        return match.percent * container.width;\n    }\n    return value;\n});\nconst parsePercent = (value) => {\n    const match = (0,_react_pdf_fns__WEBPACK_IMPORTED_MODULE_0__.matchPercent)(value);\n    return match ? match.percent : (0,_react_pdf_fns__WEBPACK_IMPORTED_MODULE_0__.parseFloat)(value);\n};\nconst parseTransform = (container) => (value) => {\n    return (0,_react_pdf_stylesheet__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(container, { transform: value }).transform;\n};\nconst parseProps = (container) => (node) => {\n    let props = transformPercent(container)(node.props);\n    props = (0,_react_pdf_fns__WEBPACK_IMPORTED_MODULE_0__.evolve)({\n        x: _react_pdf_fns__WEBPACK_IMPORTED_MODULE_0__.parseFloat,\n        x1: _react_pdf_fns__WEBPACK_IMPORTED_MODULE_0__.parseFloat,\n        x2: _react_pdf_fns__WEBPACK_IMPORTED_MODULE_0__.parseFloat,\n        y: _react_pdf_fns__WEBPACK_IMPORTED_MODULE_0__.parseFloat,\n        y1: _react_pdf_fns__WEBPACK_IMPORTED_MODULE_0__.parseFloat,\n        y2: _react_pdf_fns__WEBPACK_IMPORTED_MODULE_0__.parseFloat,\n        r: _react_pdf_fns__WEBPACK_IMPORTED_MODULE_0__.parseFloat,\n        rx: _react_pdf_fns__WEBPACK_IMPORTED_MODULE_0__.parseFloat,\n        ry: _react_pdf_fns__WEBPACK_IMPORTED_MODULE_0__.parseFloat,\n        cx: _react_pdf_fns__WEBPACK_IMPORTED_MODULE_0__.parseFloat,\n        cy: _react_pdf_fns__WEBPACK_IMPORTED_MODULE_0__.parseFloat,\n        width: _react_pdf_fns__WEBPACK_IMPORTED_MODULE_0__.parseFloat,\n        height: _react_pdf_fns__WEBPACK_IMPORTED_MODULE_0__.parseFloat,\n        offset: parsePercent,\n        fill: _react_pdf_stylesheet__WEBPACK_IMPORTED_MODULE_2__.transformColor,\n        opacity: parsePercent,\n        stroke: _react_pdf_stylesheet__WEBPACK_IMPORTED_MODULE_2__.transformColor,\n        stopOpacity: parsePercent,\n        stopColor: _react_pdf_stylesheet__WEBPACK_IMPORTED_MODULE_2__.transformColor,\n        transform: parseTransform(container),\n        gradientTransform: parseTransform(container),\n    }, props);\n    return Object.assign({}, node, { props });\n};\nconst mergeStyles$1 = (node) => {\n    const style = node.style || {};\n    const props = Object.assign({}, style, node.props);\n    return Object.assign({}, node, { props });\n};\nconst removeNoneValues = (node) => {\n    const removeNone = (value) => (value === 'none' ? null : value);\n    const props = (0,_react_pdf_fns__WEBPACK_IMPORTED_MODULE_0__.mapValues)(node.props, removeNone);\n    return Object.assign({}, node, { props });\n};\nconst pickStyleProps = (node) => {\n    const props = node.props || {};\n    const styleProps = (0,_react_pdf_fns__WEBPACK_IMPORTED_MODULE_0__.pick)(STYLE_PROPS, props);\n    const style = Object.assign({}, styleProps, node.style || {});\n    return Object.assign({}, node, { style });\n};\nconst parseSvgProps = (node) => {\n    const props = (0,_react_pdf_fns__WEBPACK_IMPORTED_MODULE_0__.evolve)({\n        width: _react_pdf_fns__WEBPACK_IMPORTED_MODULE_0__.parseFloat,\n        height: _react_pdf_fns__WEBPACK_IMPORTED_MODULE_0__.parseFloat,\n        viewBox: parseViewbox,\n        preserveAspectRatio: parseAspectRatio,\n    }, node.props);\n    return Object.assign({}, node, { props });\n};\nconst wrapBetweenTspan = (node) => ({\n    type: _react_pdf_primitives__WEBPACK_IMPORTED_MODULE_1__.Tspan,\n    props: {},\n    style: {},\n    children: [node],\n});\nconst addMissingTspan = (node) => {\n    if (!isText$5(node))\n        return node;\n    if (!node.children)\n        return node;\n    const resolveChild = (child) => isTextInstance$3(child) ? wrapBetweenTspan(child) : child;\n    const children = node.children.map(resolveChild);\n    return Object.assign({}, node, { children });\n};\nconst parseText = (fontStore) => (node) => {\n    if (isText$5(node))\n        return layoutText$1(fontStore, node);\n    if (!node.children)\n        return node;\n    const children = node.children.map(parseText(fontStore));\n    return Object.assign({}, node, { children });\n};\nconst resolveSvgNode = (container) => (0,_react_pdf_fns__WEBPACK_IMPORTED_MODULE_0__.compose)(parseProps(container), addMissingTspan, removeNoneValues, mergeStyles$1);\nconst resolveChildren = (container) => (node) => {\n    if (!node.children)\n        return node;\n    const resolveChild = (0,_react_pdf_fns__WEBPACK_IMPORTED_MODULE_0__.compose)(resolveChildren(container), resolveSvgNode(container));\n    const children = node.children.map(resolveChild);\n    return Object.assign({}, node, { children });\n};\nconst buildXLinksIndex = (node) => {\n    const idIndex = {};\n    const listToExplore = node.children?.slice(0) || [];\n    while (listToExplore.length > 0) {\n        const child = listToExplore.shift();\n        if (child.props && 'id' in child.props) {\n            idIndex[child.props.id] = child;\n        }\n        if (child.children)\n            listToExplore.push(...child.children);\n    }\n    return idIndex;\n};\nconst replaceXLinks = (node, idIndex) => {\n    if (node.props && 'xlinkHref' in node.props) {\n        const linkedNode = idIndex[node.props.xlinkHref.replace(/^#/, '')];\n        // No node to extend from\n        if (!linkedNode)\n            return node;\n        const newProps = Object.assign({}, linkedNode.props, node.props);\n        delete newProps.xlinkHref;\n        return Object.assign({}, linkedNode, { props: newProps });\n    }\n    const children = node.children?.map((child) => replaceXLinks(child, idIndex));\n    return Object.assign({}, node, { children });\n};\nconst resolveXLinks = (node) => {\n    const idIndex = buildXLinksIndex(node);\n    return replaceXLinks(node, idIndex);\n};\nconst resolveSvgRoot = (node, fontStore) => {\n    const container = getContainer$1(node);\n    return (0,_react_pdf_fns__WEBPACK_IMPORTED_MODULE_0__.compose)(replaceDefs, parseText(fontStore), parseSvgProps, pickStyleProps, inheritProps, resolveChildren(container), resolveXLinks)(node);\n};\n/**\n * Pre-process SVG nodes so they can be rendered in the next steps\n *\n * @param node - Root node\n * @param fontStore - Font store\n * @returns Root node\n */\nconst resolveSvg = (node, fontStore) => {\n    if (!('children' in node))\n        return node;\n    const resolveChild = (child) => resolveSvg(child, fontStore);\n    const root = isSvg$3(node) ? resolveSvgRoot(node, fontStore) : node;\n    const children = root.children?.map(resolveChild);\n    return Object.assign({}, root, { children });\n};\n\nlet instancePromise;\nconst loadYoga = async () => {\n    // Yoga WASM binaries must be asynchronously compiled and loaded\n    // to prevent Event emitter memory leak warnings, Yoga must be loaded only once\n    const instance = await (instancePromise ??= (0,yoga_layout_load__WEBPACK_IMPORTED_MODULE_4__.loadYoga)());\n    const config = instance.Config.create();\n    config.setPointScaleFactor(0);\n    const node = { create: () => instance.Node.createWithConfig(config) };\n    return { node };\n};\n\nconst resolveYoga = async (root) => {\n    const yoga = await loadYoga();\n    return Object.assign({}, root, { yoga });\n};\n\nconst getZIndex = (node) => node.style.zIndex;\nconst shouldSort = (node) => node.type !== _react_pdf_primitives__WEBPACK_IMPORTED_MODULE_1__.Document && node.type !== _react_pdf_primitives__WEBPACK_IMPORTED_MODULE_1__.Svg;\nconst sortZIndex = (a, b) => {\n    const za = getZIndex(a);\n    const zb = getZIndex(b);\n    if (!za && !zb)\n        return 0;\n    if (!za)\n        return 1;\n    if (!zb)\n        return -1;\n    return zb - za;\n};\n/**\n * Sort children by zIndex value\n *\n * @param node\n * @returns Node\n */\nconst resolveNodeZIndex = (node) => {\n    if (!node.children)\n        return node;\n    const sortedChildren = shouldSort(node)\n        ? node.children.sort(sortZIndex)\n        : node.children;\n    const children = sortedChildren.map(resolveNodeZIndex);\n    return Object.assign({}, node, { children });\n};\n/**\n * Sort children by zIndex value\n *\n * @param node\n * @returns Node\n */\nconst resolveZIndex = (root) => resolveNodeZIndex(root);\n\n// Caches emoji images data\nconst emojis = {};\nconst regex = emoji_regex__WEBPACK_IMPORTED_MODULE_5__();\n/**\n * When an emoji as no variations, it might still have 2 parts,\n * the canonical emoji and an empty string.\n * ex.\n *   (no color) Array.from('❤️') => [\"❤\", \"️\"]\n *   (w/ color) Array.from('👍🏿') => [\"👍\", \"🏿\"]\n *\n * The empty string needs to be removed otherwise the generated\n * url will be incorect.\n */\nconst removeVariationSelectors = (x) => x !== '️';\nconst getCodePoints = (string, withVariationSelectors = false) => Array.from(string)\n    .filter(withVariationSelectors ? () => true : removeVariationSelectors)\n    .map((char) => char.codePointAt(0).toString(16))\n    .join('-');\nconst buildEmojiUrl = (emoji, source) => {\n    if ('builder' in source) {\n        return source.builder(getCodePoints(emoji, source.withVariationSelectors));\n    }\n    const { url, format = 'png', withVariationSelectors } = source;\n    return `${url}${getCodePoints(emoji, withVariationSelectors)}.${format}`;\n};\nconst fetchEmojis = (string, source) => {\n    if (!source)\n        return [];\n    const promises = [];\n    Array.from(string.matchAll(regex)).forEach((match) => {\n        const emoji = match[0];\n        if (!emojis[emoji] || emojis[emoji].loading) {\n            const emojiUrl = buildEmojiUrl(emoji, source);\n            emojis[emoji] = { loading: true };\n            promises.push((0,_react_pdf_image__WEBPACK_IMPORTED_MODULE_6__[\"default\"])({ uri: emojiUrl }).then((image) => {\n                emojis[emoji].loading = false;\n                emojis[emoji].data = image.data;\n            }));\n        }\n    });\n    return promises;\n};\nconst embedEmojis = (fragments) => {\n    const result = [];\n    for (let i = 0; i < fragments.length; i += 1) {\n        const fragment = fragments[i];\n        let lastIndex = 0;\n        Array.from(fragment.string.matchAll(regex)).forEach((match) => {\n            const { index } = match;\n            const emoji = match[0];\n            const emojiSize = fragment.attributes.fontSize;\n            const chunk = fragment.string.slice(lastIndex, index + match[0].length);\n            // If emoji image was found, we create a new fragment with the\n            // correct attachment and object substitution character;\n            if (emojis[emoji] && emojis[emoji].data) {\n                result.push({\n                    string: chunk.replace(match[0], String.fromCharCode(0xfffc)),\n                    attributes: {\n                        ...fragment.attributes,\n                        attachment: {\n                            width: emojiSize,\n                            height: emojiSize,\n                            yOffset: Math.floor(emojiSize * 0.1),\n                            image: emojis[emoji].data,\n                        },\n                    },\n                });\n            }\n            else {\n                // If no emoji data, we try to use emojis in the font\n                result.push({\n                    string: chunk,\n                    attributes: fragment.attributes,\n                });\n            }\n            lastIndex = index + emoji.length;\n        });\n        if (lastIndex < fragment.string.length) {\n            result.push({\n                string: fragment.string.slice(lastIndex),\n                attributes: fragment.attributes,\n            });\n        }\n    }\n    return result;\n};\n\n/**\n * Get image source\n *\n * @param node - Image node\n * @returns Image src\n */\nconst getSource = (node) => {\n    if (node.props.src)\n        return node.props.src;\n    if (node.props.source)\n        return node.props.source;\n};\n\n/**\n * Resolves `src` to `@react-pdf/image` interface.\n *\n * Also it handles factories and async sources.\n *\n * @param src\n * @returns Resolved src\n */\nconst resolveSource = async (src) => {\n    const source = typeof src === 'function' ? await src() : await src;\n    return typeof source === 'string' ? { uri: source } : source;\n};\n\n/**\n * Fetches image and append data to node\n * Ideally this fn should be immutable.\n *\n * @param node\n */\nconst fetchImage = async (node) => {\n    const src = getSource(node);\n    const { cache } = node.props;\n    if (!src) {\n        console.warn(false, 'Image should receive either a \"src\" or \"source\" prop');\n        return;\n    }\n    try {\n        const source = await resolveSource(src);\n        if (!source) {\n            throw new Error(`Image's \"src\" or \"source\" prop returned ${source}`);\n        }\n        node.image = await (0,_react_pdf_image__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(source, { cache });\n        if (Buffer.isBuffer(source) || source instanceof Blob)\n            return;\n        node.image.key = 'data' in source ? source.data.toString() : source.uri;\n    }\n    catch (e) {\n        console.warn(e.message);\n    }\n};\n\nconst isImage$2 = (node) => node.type === _react_pdf_primitives__WEBPACK_IMPORTED_MODULE_1__.Image;\n/**\n * Get all asset promises that need to be resolved\n *\n * @param fontStore - Font store\n * @param node - Root node\n * @returns Asset promises\n */\nconst fetchAssets = (fontStore, node) => {\n    const promises = [];\n    const listToExplore = node.children?.slice(0) || [];\n    const emojiSource = fontStore ? fontStore.getEmojiSource() : null;\n    while (listToExplore.length > 0) {\n        const n = listToExplore.shift();\n        if (isImage$2(n)) {\n            promises.push(fetchImage(n));\n        }\n        if (fontStore && n.style?.fontFamily) {\n            const fontFamilies = (0,_react_pdf_fns__WEBPACK_IMPORTED_MODULE_0__.castArray)(n.style.fontFamily);\n            promises.push(...fontFamilies.map((fontFamily) => fontStore.load({\n                fontFamily,\n                fontStyle: n.style.fontStyle,\n                fontWeight: n.style.fontWeight,\n            })));\n        }\n        if (typeof n === 'string') {\n            promises.push(...fetchEmojis(n, emojiSource));\n        }\n        if ('value' in n && typeof n.value === 'string') {\n            promises.push(...fetchEmojis(n.value, emojiSource));\n        }\n        if (n.children) {\n            n.children.forEach((childNode) => {\n                listToExplore.push(childNode);\n            });\n        }\n    }\n    return promises;\n};\n/**\n * Fetch image, font and emoji assets in parallel.\n * Layout process will not be resumed until promise resolves.\n *\n * @param node root node\n * @param fontStore font store\n * @returns Root node\n */\nconst resolveAssets = async (node, fontStore) => {\n    const promises = fetchAssets(fontStore, node);\n    await Promise.all(promises);\n    return node;\n};\n\nconst isLink$1 = (node) => node.type === _react_pdf_primitives__WEBPACK_IMPORTED_MODULE_1__.Link;\nconst DEFAULT_LINK_STYLES = {\n    color: 'blue',\n    textDecoration: 'underline',\n};\n/**\n * Computes styles using stylesheet\n *\n * @param container\n * @param node - Document node\n * @returns Computed styles\n */\nconst computeStyle = (container, node) => {\n    let baseStyle = [node.style];\n    if (isLink$1(node)) {\n        baseStyle = Array.isArray(node.style)\n            ? [DEFAULT_LINK_STYLES, ...node.style]\n            : [DEFAULT_LINK_STYLES, node.style];\n    }\n    return (0,_react_pdf_stylesheet__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(container, baseStyle);\n};\n/**\n * Resolves node styles\n *\n * @param container\n * @returns Resolve node styles\n */\nconst resolveNodeStyles = (container) => (node) => {\n    const style = computeStyle(container, node);\n    if (!node.children)\n        return Object.assign({}, node, { style });\n    const children = node.children.map(resolveNodeStyles(container));\n    return Object.assign({}, node, { style, children });\n};\n/**\n * Resolves page styles\n *\n * @param page Document page\n * @returns Document page with resolved styles\n */\nconst resolvePageStyles = (page) => {\n    const dpi = page.props?.dpi || 72;\n    const style = page.style;\n    const width = page.box?.width || style.width;\n    const height = page.box?.height || style.height;\n    const orientation = page.props?.orientation || 'portrait';\n    const remBase = style?.fontSize || 18;\n    const container = { width, height, orientation, dpi, remBase };\n    return resolveNodeStyles(container)(page);\n};\n/**\n * Resolves document styles\n *\n * @param root - Document root\n * @returns Document root with resolved styles\n */\nconst resolveStyles = (root) => {\n    if (!root.children)\n        return root;\n    const children = root.children.map(resolvePageStyles);\n    return Object.assign({}, root, { children });\n};\n\nconst getTransformStyle = (s) => (node) => (0,_react_pdf_fns__WEBPACK_IMPORTED_MODULE_0__.isNil)(node.style?.[s]) ? '50%' : node.style?.[s] ?? null;\n/**\n * Get node origin\n *\n * @param node\n * @returns {{ left?: number, top?: number }} node origin\n */\nconst getOrigin = (node) => {\n    if (!node.box)\n        return null;\n    const { left, top, width, height } = node.box;\n    const transformOriginX = getTransformStyle('transformOriginX')(node);\n    const transformOriginY = getTransformStyle('transformOriginY')(node);\n    const percentX = (0,_react_pdf_fns__WEBPACK_IMPORTED_MODULE_0__.matchPercent)(transformOriginX);\n    const percentY = (0,_react_pdf_fns__WEBPACK_IMPORTED_MODULE_0__.matchPercent)(transformOriginY);\n    const offsetX = percentX ? width * percentX.percent : transformOriginX;\n    const offsetY = percentY ? height * percentY.percent : transformOriginY;\n    if ((0,_react_pdf_fns__WEBPACK_IMPORTED_MODULE_0__.isNil)(offsetX) || typeof offsetX === 'string')\n        throw new Error(`Invalid origin offsetX: ${offsetX}`);\n    if ((0,_react_pdf_fns__WEBPACK_IMPORTED_MODULE_0__.isNil)(offsetY) || typeof offsetY === 'string')\n        throw new Error(`Invalid origin offsetY: ${offsetY}`);\n    return { left: left + offsetX, top: top + offsetY };\n};\n\n/**\n * Resolve node origin\n *\n * @param node\n * @returns Node with origin attribute\n */\nconst resolveNodeOrigin = (node) => {\n    const origin = getOrigin(node);\n    const newNode = Object.assign({}, node, { origin });\n    if (!node.children)\n        return newNode;\n    const children = node.children.map(resolveNodeOrigin);\n    return Object.assign({}, newNode, { children });\n};\n/**\n * Resolve document origins\n *\n * @param root - Document root\n * @returns Document root\n */\nconst resolveOrigin = (root) => {\n    if (!root.children)\n        return root;\n    const children = root.children.map(resolveNodeOrigin);\n    return Object.assign({}, root, { children });\n};\n\nconst getBookmarkValue = (bookmark) => {\n    return typeof bookmark === 'string'\n        ? { title: bookmark, fit: false, expanded: false }\n        : bookmark;\n};\nconst resolveBookmarks = (node) => {\n    let refs = 0;\n    const children = (node.children || []).slice(0);\n    const listToExplore = children.map((value) => ({\n        value,\n        parent: null,\n    }));\n    while (listToExplore.length > 0) {\n        const element = listToExplore.shift();\n        if (!element)\n            break;\n        const child = element.value;\n        let parent = element.parent;\n        if (child.props && 'bookmark' in child.props) {\n            const bookmark = getBookmarkValue(child.props.bookmark);\n            const ref = refs++;\n            const newHierarchy = { ref, parent: parent?.ref, ...bookmark };\n            child.props.bookmark = newHierarchy;\n            parent = newHierarchy;\n        }\n        if (child.children) {\n            child.children.forEach((childNode) => {\n                listToExplore.push({ value: childNode, parent });\n            });\n        }\n    }\n    return node;\n};\n\nconst VALID_ORIENTATIONS = ['portrait', 'landscape'];\n/**\n * Get page orientation. Defaults to portrait\n *\n * @param page - Page object\n * @returns Page orientation\n */\nconst getOrientation = (page) => {\n    const value = page.props?.orientation || 'portrait';\n    return VALID_ORIENTATIONS.includes(value) ? value : 'portrait';\n};\n\n/**\n * Return true if page is landscape\n *\n * @param page - Page instance\n * @returns Is page landscape\n */\nconst isLandscape = (page) => getOrientation(page) === 'landscape';\n\n// Page sizes for 72dpi. 72dpi is used internally by pdfkit.\nconst PAGE_SIZES = {\n    '4A0': [4767.87, 6740.79],\n    '2A0': [3370.39, 4767.87],\n    A0: [2383.94, 3370.39],\n    A1: [1683.78, 2383.94],\n    A2: [1190.55, 1683.78],\n    A3: [841.89, 1190.55],\n    A4: [595.28, 841.89],\n    A5: [419.53, 595.28],\n    A6: [297.64, 419.53],\n    A7: [209.76, 297.64],\n    A8: [147.4, 209.76],\n    A9: [104.88, 147.4],\n    A10: [73.7, 104.88],\n    B0: [2834.65, 4008.19],\n    B1: [2004.09, 2834.65],\n    B2: [1417.32, 2004.09],\n    B3: [1000.63, 1417.32],\n    B4: [708.66, 1000.63],\n    B5: [498.9, 708.66],\n    B6: [354.33, 498.9],\n    B7: [249.45, 354.33],\n    B8: [175.75, 249.45],\n    B9: [124.72, 175.75],\n    B10: [87.87, 124.72],\n    C0: [2599.37, 3676.54],\n    C1: [1836.85, 2599.37],\n    C2: [1298.27, 1836.85],\n    C3: [918.43, 1298.27],\n    C4: [649.13, 918.43],\n    C5: [459.21, 649.13],\n    C6: [323.15, 459.21],\n    C7: [229.61, 323.15],\n    C8: [161.57, 229.61],\n    C9: [113.39, 161.57],\n    C10: [79.37, 113.39],\n    RA0: [2437.8, 3458.27],\n    RA1: [1729.13, 2437.8],\n    RA2: [1218.9, 1729.13],\n    RA3: [864.57, 1218.9],\n    RA4: [609.45, 864.57],\n    SRA0: [2551.18, 3628.35],\n    SRA1: [1814.17, 2551.18],\n    SRA2: [1275.59, 1814.17],\n    SRA3: [907.09, 1275.59],\n    SRA4: [637.8, 907.09],\n    EXECUTIVE: [521.86, 756.0],\n    FOLIO: [612.0, 936.0],\n    LEGAL: [612.0, 1008.0],\n    LETTER: [612.0, 792.0],\n    TABLOID: [792.0, 1224.0],\n    ID1: [153, 243],\n};\n/**\n * Parses scalar value in value and unit pairs\n *\n * @param value - Scalar value\n * @returns Parsed value\n */\nconst parseValue = (value) => {\n    if (typeof value === 'number')\n        return { value, unit: undefined };\n    const match = /^(-?\\d*\\.?\\d+)(in|mm|cm|pt|px)?$/g.exec(value);\n    return match\n        ? { value: parseFloat(match[1]), unit: match[2] || 'pt' }\n        : { value, unit: undefined };\n};\n/**\n * Transform given scalar value to 72dpi equivalent of size\n *\n * @param value - Styles value\n * @param inputDpi - User defined dpi\n * @returns Transformed value\n */\nconst transformUnit = (value, inputDpi) => {\n    if (!value)\n        return 0;\n    const scalar = parseValue(value);\n    const outputDpi = 72;\n    const mmFactor = (1 / 25.4) * outputDpi;\n    const cmFactor = (1 / 2.54) * outputDpi;\n    if (typeof scalar.value === 'string')\n        throw new Error(`Invalid page size: ${value}`);\n    switch (scalar.unit) {\n        case 'in':\n            return scalar.value * outputDpi;\n        case 'mm':\n            return scalar.value * mmFactor;\n        case 'cm':\n            return scalar.value * cmFactor;\n        case 'px':\n            return Math.round(scalar.value * (outputDpi / inputDpi));\n        default:\n            return scalar.value;\n    }\n};\nconst transformUnits = ({ width, height }, dpi) => ({\n    width: transformUnit(width, dpi),\n    height: transformUnit(height, dpi),\n});\n/**\n * Transforms array into size object\n *\n * @param v - Values array\n * @returns Size object with width and height\n */\nconst toSizeObject = (v) => ({\n    width: v[0],\n    height: v[1],\n});\n/**\n * Flip size object\n *\n * @param v - Size object\n * @returns Flipped size object\n */\nconst flipSizeObject = (v) => ({\n    width: v.height,\n    height: v.width,\n});\n/**\n * Returns size object from a given string\n *\n * @param v - Page size string\n * @returns Size object with width and height\n */\nconst getStringSize = (v) => {\n    return toSizeObject(PAGE_SIZES[v.toUpperCase()]);\n};\n/**\n * Returns size object from a single number\n *\n * @param n - Page size number\n * @returns Size object with width and height\n */\nconst getNumberSize = (n) => toSizeObject([n, n]);\n/**\n * Return page size in an object { width, height }\n *\n * @param page - Page node\n * @returns Size object with width and height\n */\nconst getSize = (page) => {\n    const value = page.props?.size || 'A4';\n    const dpi = page.props?.dpi || 72;\n    let size;\n    if (typeof value === 'string') {\n        size = getStringSize(value);\n    }\n    else if (Array.isArray(value)) {\n        size = transformUnits(toSizeObject(value), dpi);\n    }\n    else if (typeof value === 'number') {\n        size = transformUnits(getNumberSize(value), dpi);\n    }\n    else {\n        size = transformUnits(value, dpi);\n    }\n    return isLandscape(page) ? flipSizeObject(size) : size;\n};\n\n/**\n * Resolves page size\n *\n * @param page\n * @returns Page with resolved size in style attribute\n */\nconst resolvePageSize = (page) => {\n    const size = getSize(page);\n    const style = (0,_react_pdf_stylesheet__WEBPACK_IMPORTED_MODULE_2__.flatten)(page.style || {});\n    return { ...page, style: { ...style, ...size } };\n};\n/**\n * Resolves page sizes\n *\n * @param root  -Document root\n * @returns Document root with resolved page sizes\n */\nconst resolvePageSizes = (root) => {\n    if (!root.children)\n        return root;\n    const children = root.children.map(resolvePageSize);\n    return Object.assign({}, root, { children });\n};\n\nconst isFixed = (node) => {\n    if (!node.props)\n        return false;\n    return 'fixed' in node.props ? node.props.fixed === true : false;\n};\n\n/**\n * Get line index at given height\n *\n * @param node\n * @param height\n */\nconst lineIndexAtHeight = (node, height) => {\n    let y = 0;\n    if (!node.lines)\n        return 0;\n    for (let i = 0; i < node.lines.length; i += 1) {\n        const line = node.lines[i];\n        if (y + line.box.height > height)\n            return i;\n        y += line.box.height;\n    }\n    return node.lines.length;\n};\n\n/**\n * Get height for given text line index\n *\n * @param node\n * @param index\n */\nconst heightAtLineIndex = (node, index) => {\n    let counter = 0;\n    if (!node.lines)\n        return counter;\n    for (let i = 0; i < index; i += 1) {\n        const line = node.lines[i];\n        if (!line)\n            break;\n        counter += line.box.height;\n    }\n    return counter;\n};\n\nconst getLineBreak = (node, height) => {\n    const top = node.box?.top || 0;\n    const widows = node.props.widows || 2;\n    const orphans = node.props.orphans || 2;\n    const linesQuantity = node.lines.length;\n    const slicedLine = lineIndexAtHeight(node, height - top);\n    if (slicedLine === 0) {\n        return 0;\n    }\n    if (linesQuantity < orphans) {\n        return linesQuantity;\n    }\n    if (slicedLine < orphans || linesQuantity < orphans + widows) {\n        return 0;\n    }\n    if (linesQuantity === orphans + widows) {\n        return orphans;\n    }\n    if (linesQuantity - slicedLine < widows) {\n        return linesQuantity - widows;\n    }\n    return slicedLine;\n};\n// Also receives contentArea in case it's needed\nconst splitText = (node, height) => {\n    const slicedLineIndex = getLineBreak(node, height);\n    const currentHeight = heightAtLineIndex(node, slicedLineIndex);\n    const nextHeight = node.box.height - currentHeight;\n    const current = Object.assign({}, node, {\n        box: {\n            ...node.box,\n            height: currentHeight,\n            borderBottomWidth: 0,\n        },\n        style: {\n            ...node.style,\n            marginBottom: 0,\n            paddingBottom: 0,\n            borderBottomWidth: 0,\n            borderBottomLeftRadius: 0,\n            borderBottomRightRadius: 0,\n        },\n        lines: node.lines.slice(0, slicedLineIndex),\n    });\n    const next = Object.assign({}, node, {\n        box: {\n            ...node.box,\n            top: 0,\n            height: nextHeight,\n            borderTopWidth: 0,\n        },\n        style: {\n            ...node.style,\n            marginTop: 0,\n            paddingTop: 0,\n            borderTopWidth: 0,\n            borderTopLeftRadius: 0,\n            borderTopRightRadius: 0,\n        },\n        lines: node.lines.slice(slicedLineIndex),\n    });\n    return [current, next];\n};\n\nconst getTop$1 = (node) => node.box?.top || 0;\nconst hasFixedHeight = (node) => !(0,_react_pdf_fns__WEBPACK_IMPORTED_MODULE_0__.isNil)(node.style?.height);\nconst splitNode = (node, height) => {\n    if (!node)\n        return [null, null];\n    const nodeTop = getTop$1(node);\n    const current = Object.assign({}, node, {\n        box: {\n            ...node.box,\n            borderBottomWidth: 0,\n        },\n        style: {\n            ...node.style,\n            marginBottom: 0,\n            paddingBottom: 0,\n            borderBottomWidth: 0,\n            borderBottomLeftRadius: 0,\n            borderBottomRightRadius: 0,\n        },\n    });\n    current.style.height = height - nodeTop;\n    const nextHeight = hasFixedHeight(node)\n        ? node.box.height - (height - nodeTop)\n        : null;\n    const next = Object.assign({}, node, {\n        box: {\n            ...node.box,\n            top: 0,\n            borderTopWidth: 0,\n        },\n        style: {\n            ...node.style,\n            marginTop: 0,\n            paddingTop: 0,\n            borderTopWidth: 0,\n            borderTopLeftRadius: 0,\n            borderTopRightRadius: 0,\n        },\n    });\n    if (nextHeight) {\n        next.style.height = nextHeight;\n    }\n    return [current, next];\n};\n\nconst NON_WRAP_TYPES = [_react_pdf_primitives__WEBPACK_IMPORTED_MODULE_1__.Svg, _react_pdf_primitives__WEBPACK_IMPORTED_MODULE_1__.Note, _react_pdf_primitives__WEBPACK_IMPORTED_MODULE_1__.Image, _react_pdf_primitives__WEBPACK_IMPORTED_MODULE_1__.Canvas];\nconst getWrap = (node) => {\n    if (NON_WRAP_TYPES.includes(node.type))\n        return false;\n    if (!node.props)\n        return true;\n    return 'wrap' in node.props ? node.props.wrap : true;\n};\n\nconst getComputedPadding = (node, edge) => {\n    const { yogaNode } = node;\n    return yogaNode ? yogaNode.getComputedPadding(edge) : null;\n};\n/**\n * Get Yoga computed paddings. Zero otherwise\n *\n * @param  node\n * @returns paddings\n */\nconst getPadding = (node) => {\n    const { style, box } = node;\n    const paddingTop = getComputedPadding(node, yoga_layout_load__WEBPACK_IMPORTED_MODULE_4__.Edge.Top) ||\n        box?.paddingTop ||\n        style?.paddingTop ||\n        0;\n    const paddingRight = getComputedPadding(node, yoga_layout_load__WEBPACK_IMPORTED_MODULE_4__.Edge.Right) ||\n        box?.paddingRight ||\n        style?.paddingRight ||\n        0;\n    const paddingBottom = getComputedPadding(node, yoga_layout_load__WEBPACK_IMPORTED_MODULE_4__.Edge.Bottom) ||\n        box?.paddingBottom ||\n        style?.paddingBottom ||\n        0;\n    const paddingLeft = getComputedPadding(node, yoga_layout_load__WEBPACK_IMPORTED_MODULE_4__.Edge.Left) ||\n        box?.paddingLeft ||\n        style?.paddingLeft ||\n        0;\n    return { paddingTop, paddingRight, paddingBottom, paddingLeft };\n};\n\nconst getWrapArea = (page) => {\n    const height = page.style?.height;\n    const { paddingBottom } = getPadding(page);\n    return height - paddingBottom;\n};\n\nconst getContentArea = (page) => {\n    const height = page.style?.height;\n    const { paddingTop, paddingBottom } = getPadding(page);\n    return height - paddingBottom - paddingTop;\n};\n\nconst isString = (value) => typeof value === 'string';\nconst isNumber = (value) => typeof value === 'number';\nconst isBoolean = (value) => typeof value === 'boolean';\nconst isFragment = (value) => value && value.type === Symbol.for('react.fragment');\n/**\n * Transforms a react element instance to internal element format.\n *\n * Can return multiple instances in the case of arrays or fragments.\n *\n * @param element - React element\n * @returns Parsed React elements\n */\nconst createInstances = (element) => {\n    if (!element)\n        return [];\n    if (Array.isArray(element)) {\n        return element.reduce((acc, el) => acc.concat(createInstances(el)), []);\n    }\n    if (isBoolean(element)) {\n        return [];\n    }\n    if (isString(element) || isNumber(element)) {\n        return [{ type: _react_pdf_primitives__WEBPACK_IMPORTED_MODULE_1__.TextInstance, value: `${element}` }];\n    }\n    if (isFragment(element)) {\n        // @ts-expect-error figure out why this is complains\n        return createInstances(element.props.children);\n    }\n    if (!isString(element.type)) {\n        // @ts-expect-error figure out why this is complains\n        return createInstances(element.type(element.props));\n    }\n    const { type, props: { style = {}, children, ...props }, } = element;\n    const nextChildren = (0,_react_pdf_fns__WEBPACK_IMPORTED_MODULE_0__.castArray)(children).reduce((acc, child) => acc.concat(createInstances(child)), []);\n    return [\n        {\n            type,\n            style,\n            props,\n            children: nextChildren,\n        },\n    ];\n};\n\nconst getBreak = (node) => 'break' in node.props ? node.props.break : false;\nconst getMinPresenceAhead = (node) => 'minPresenceAhead' in node.props ? node.props.minPresenceAhead : 0;\nconst getFurthestEnd = (elements) => Math.max(...elements.map((node) => node.box.top + node.box.height));\nconst getEndOfMinPresenceAhead = (child) => {\n    return (child.box.top +\n        child.box.height +\n        child.box.marginBottom +\n        getMinPresenceAhead(child));\n};\nconst getEndOfPresence = (child, futureElements) => {\n    const afterMinPresenceAhead = getEndOfMinPresenceAhead(child);\n    const endOfFurthestFutureElement = getFurthestEnd(futureElements.filter((node) => !('fixed' in node.props)));\n    return Math.min(afterMinPresenceAhead, endOfFurthestFutureElement);\n};\nconst shouldBreak = (child, futureElements, height) => {\n    if ('fixed' in child.props)\n        return false;\n    const shouldSplit = height < child.box.top + child.box.height;\n    const canWrap = getWrap(child);\n    // Calculate the y coordinate where the desired presence of the child ends\n    const endOfPresence = getEndOfPresence(child, futureElements);\n    // If the child is already at the top of the page, breaking won't improve its presence\n    // (as long as react-pdf does not support breaking into differently sized containers)\n    const breakingImprovesPresence = child.box.top > child.box.marginTop;\n    return (getBreak(child) ||\n        (shouldSplit && !canWrap) ||\n        (!shouldSplit && endOfPresence > height && breakingImprovesPresence));\n};\n\nconst IGNORABLE_CODEPOINTS = [\n    8232, // LINE_SEPARATOR\n    8233, // PARAGRAPH_SEPARATOR\n];\nconst buildSubsetForFont = (font) => IGNORABLE_CODEPOINTS.reduce((acc, codePoint) => {\n    if (font &&\n        font.hasGlyphForCodePoint &&\n        font.hasGlyphForCodePoint(codePoint)) {\n        return acc;\n    }\n    return [...acc, String.fromCharCode(codePoint)];\n}, []);\nconst ignoreChars = (fragments) => fragments.map((fragment) => {\n    const charSubset = buildSubsetForFont(fragment.attributes.font[0]);\n    const subsetRegex = new RegExp(charSubset.join('|'));\n    return {\n        string: fragment.string.replace(subsetRegex, ''),\n        attributes: fragment.attributes,\n    };\n});\n\nconst PREPROCESSORS = [ignoreChars, embedEmojis];\nconst isImage$1 = (node) => node.type === _react_pdf_primitives__WEBPACK_IMPORTED_MODULE_1__.Image;\nconst isTextInstance$2 = (node) => node.type === _react_pdf_primitives__WEBPACK_IMPORTED_MODULE_1__.TextInstance;\n/**\n * Get textkit fragments of given node object\n *\n * @param fontStore - Font store\n * @param instance - Node\n * @param parentLink - Parent link\n * @param level - Fragment level\n * @returns Text fragments\n */\nconst getFragments = (fontStore, instance, parentLink = null, level = 0) => {\n    if (!instance)\n        return [{ string: '' }];\n    let fragments = [];\n    const { color = 'black', direction = 'ltr', fontFamily = 'Helvetica', fontWeight, fontStyle, fontSize = 18, textAlign, lineHeight, textDecoration, textDecorationColor, textDecorationStyle, textTransform, letterSpacing, textIndent, opacity, verticalAlign, } = instance.style;\n    const fontFamilies = typeof fontFamily === 'string' ? [fontFamily] : [...(fontFamily || [])];\n    // Fallback font\n    fontFamilies.push('Helvetica');\n    const font = fontFamilies.map((fontFamilyName) => {\n        const opts = { fontFamily: fontFamilyName, fontWeight, fontStyle };\n        const obj = fontStore.getFont(opts);\n        return obj?.data;\n    });\n    // Don't pass main background color to textkit. Will be rendered by the render package instead\n    const backgroundColor = level === 0 ? null : instance.style.backgroundColor;\n    const attributes = {\n        font,\n        color,\n        opacity,\n        fontSize,\n        lineHeight,\n        direction,\n        verticalAlign,\n        backgroundColor,\n        indent: textIndent,\n        characterSpacing: letterSpacing,\n        strikeStyle: textDecorationStyle,\n        underlineStyle: textDecorationStyle,\n        underline: textDecoration === 'underline' ||\n            textDecoration === 'underline line-through' ||\n            textDecoration === 'line-through underline',\n        strike: textDecoration === 'line-through' ||\n            textDecoration === 'underline line-through' ||\n            textDecoration === 'line-through underline',\n        strikeColor: textDecorationColor || color,\n        underlineColor: textDecorationColor || color,\n        // @ts-expect-error allow this props access\n        link: parentLink || instance.props?.src || instance.props?.href,\n        align: textAlign || (direction === 'rtl' ? 'right' : 'left'),\n    };\n    for (let i = 0; i < instance.children.length; i += 1) {\n        const child = instance.children[i];\n        if (isImage$1(child)) {\n            fragments.push({\n                string: String.fromCharCode(0xfffc),\n                attributes: {\n                    ...attributes,\n                    attachment: {\n                        width: (child.style.width || fontSize),\n                        height: (child.style.height || fontSize),\n                        image: child.image.data,\n                    },\n                },\n            });\n        }\n        else if (isTextInstance$2(child)) {\n            fragments.push({\n                string: transformText(child.value, textTransform),\n                attributes,\n            });\n        }\n        else if (child) {\n            fragments.push(...getFragments(fontStore, child, attributes.link, level + 1));\n        }\n    }\n    for (let i = 0; i < PREPROCESSORS.length; i += 1) {\n        const preprocessor = PREPROCESSORS[i];\n        fragments = preprocessor(fragments);\n    }\n    return fragments;\n};\n/**\n * Get textkit attributed string from text node\n *\n * @param fontStore - Font store\n * @param instance Node\n * @returns Attributed string\n */\nconst getAttributedString = (fontStore, instance) => {\n    const fragments = getFragments(fontStore, instance);\n    return (0,_react_pdf_textkit__WEBPACK_IMPORTED_MODULE_3__.fromFragments)(fragments);\n};\n\nconst engines = {\n    bidi: _react_pdf_textkit__WEBPACK_IMPORTED_MODULE_3__.bidi,\n    linebreaker: _react_pdf_textkit__WEBPACK_IMPORTED_MODULE_3__.linebreaker,\n    justification: _react_pdf_textkit__WEBPACK_IMPORTED_MODULE_3__.justification,\n    textDecoration: _react_pdf_textkit__WEBPACK_IMPORTED_MODULE_3__.textDecoration,\n    scriptItemizer: _react_pdf_textkit__WEBPACK_IMPORTED_MODULE_3__.scriptItemizer,\n    wordHyphenation: _react_pdf_textkit__WEBPACK_IMPORTED_MODULE_3__.wordHyphenation,\n    fontSubstitution: _react_pdf_textkit__WEBPACK_IMPORTED_MODULE_3__.fontSubstitution,\n};\nconst engine = (0,_react_pdf_textkit__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(engines);\nconst getMaxLines = (node) => node.style?.maxLines;\nconst getTextOverflow = (node) => node.style?.textOverflow;\n/**\n * Get layout container for specific text node\n *\n * @param {number} width\n * @param {number} height\n * @param {Object} node\n * @returns {Object} layout container\n */\nconst getContainer = (width, height, node) => {\n    const maxLines = getMaxLines(node);\n    const textOverflow = getTextOverflow(node);\n    return {\n        x: 0,\n        y: 0,\n        width,\n        maxLines,\n        height: height || Infinity,\n        truncateMode: textOverflow,\n    };\n};\n/**\n * Get text layout options for specific text node\n *\n * @param {Object} node instance\n * @returns {Object} layout options\n */\nconst getLayoutOptions = (fontStore, node) => ({\n    hyphenationPenalty: node.props.hyphenationPenalty,\n    shrinkWhitespaceFactor: { before: -0.5, after: -0.5 },\n    hyphenationCallback: node.props.hyphenationCallback ||\n        fontStore?.getHyphenationCallback() ||\n        null,\n});\n/**\n * Get text lines for given node\n *\n * @param node - Node\n * @param width - Container width\n * @param height - Container height\n * @param fontStore - Font store\n * @returns Layout lines\n */\nconst layoutText = (node, width, height, fontStore) => {\n    const attributedString = getAttributedString(fontStore, node);\n    const container = getContainer(width, height, node);\n    const options = getLayoutOptions(fontStore, node);\n    const lines = engine(attributedString, container, options);\n    return lines.reduce((acc, line) => [...acc, ...line], []);\n};\n\nconst isSvg$2 = (node) => node.type === _react_pdf_primitives__WEBPACK_IMPORTED_MODULE_1__.Svg;\nconst isText$4 = (node) => node.type === _react_pdf_primitives__WEBPACK_IMPORTED_MODULE_1__.Text;\nconst shouldIterate = (node) => !isSvg$2(node) && !isText$4(node);\nconst shouldLayoutText = (node) => isText$4(node) && !node.lines;\n/**\n * Performs text layout on text node if wasn't calculated before.\n * Text layout is usually performed on Yoga's layout process (via setMeasureFunc),\n * but we need to layout those nodes with fixed width and height.\n *\n * @param node\n * @returns Layout node\n */\nconst resolveTextLayout = (node, fontStore) => {\n    if (shouldLayoutText(node)) {\n        const width = node.box.width - (node.box.paddingRight + node.box.paddingLeft);\n        const height = node.box.height - (node.box.paddingTop + node.box.paddingBottom);\n        node.lines = layoutText(node, width, height, fontStore);\n    }\n    if (shouldIterate(node)) {\n        if (!node.children)\n            return node;\n        const mapChild = (child) => resolveTextLayout(child, fontStore);\n        const children = node.children.map(mapChild);\n        return Object.assign({}, node, { children });\n    }\n    return node;\n};\n\nconst BASE_INHERITABLE_PROPERTIES = [\n    'color',\n    'fontFamily',\n    'fontSize',\n    'fontStyle',\n    'fontWeight',\n    'letterSpacing',\n    'opacity',\n    'textDecoration',\n    'textTransform',\n    'lineHeight',\n    'textAlign',\n    'visibility',\n    'wordSpacing',\n];\nconst TEXT_INHERITABLE_PROPERTIES = [\n    ...BASE_INHERITABLE_PROPERTIES,\n    'backgroundColor',\n];\nconst isType$2 = (type) => (node) => node.type === type;\nconst isSvg$1 = isType$2(_react_pdf_primitives__WEBPACK_IMPORTED_MODULE_1__.Svg);\nconst isText$3 = isType$2(_react_pdf_primitives__WEBPACK_IMPORTED_MODULE_1__.Text);\n// Merge style values\nconst mergeValues = (styleName, value, inheritedValue) => {\n    switch (styleName) {\n        case 'textDecoration': {\n            // merge not none and not false textDecoration values to one rule\n            return [inheritedValue, value].filter((v) => v && v !== 'none').join(' ');\n        }\n        default:\n            return value;\n    }\n};\n// Merge inherited and node styles\nconst merge = (inheritedStyles, style) => {\n    const mergedStyles = { ...inheritedStyles };\n    Object.entries(style).forEach(([styleName, value]) => {\n        mergedStyles[styleName] = mergeValues(styleName, value, inheritedStyles[styleName]);\n    });\n    return mergedStyles;\n};\n/**\n * Merges styles with node\n *\n * @param inheritedStyles - Style object\n * @returns Merge styles function\n */\nconst mergeStyles = (inheritedStyles) => (node) => {\n    const style = merge(inheritedStyles, node.style || {});\n    return Object.assign({}, node, { style });\n};\n/**\n * Inherit style values from the root to the leafs\n *\n * @param node - Document root\n * @returns Document root with inheritance\n *\n */\nconst resolveInheritance = (node) => {\n    if (isSvg$1(node))\n        return node;\n    if (!('children' in node))\n        return node;\n    const inheritableProperties = isText$3(node)\n        ? TEXT_INHERITABLE_PROPERTIES\n        : BASE_INHERITABLE_PROPERTIES;\n    const inheritStyles = (0,_react_pdf_fns__WEBPACK_IMPORTED_MODULE_0__.pick)(inheritableProperties, node.style || {});\n    const resolveChild = (0,_react_pdf_fns__WEBPACK_IMPORTED_MODULE_0__.compose)(resolveInheritance, mergeStyles(inheritStyles));\n    const children = node.children.map(resolveChild);\n    return Object.assign({}, node, { children });\n};\n\nconst getComputedMargin = (node, edge) => {\n    const { yogaNode } = node;\n    return yogaNode ? yogaNode.getComputedMargin(edge) : null;\n};\n/**\n * Get Yoga computed magins. Zero otherwise\n *\n * @param node\n * @returns Margins\n */\nconst getMargin = (node) => {\n    const { style, box } = node;\n    const marginTop = getComputedMargin(node, yoga_layout_load__WEBPACK_IMPORTED_MODULE_4__.Edge.Top) ||\n        box?.marginTop ||\n        style?.marginTop ||\n        0;\n    const marginRight = getComputedMargin(node, yoga_layout_load__WEBPACK_IMPORTED_MODULE_4__.Edge.Right) ||\n        box?.marginRight ||\n        style?.marginRight ||\n        0;\n    const marginBottom = getComputedMargin(node, yoga_layout_load__WEBPACK_IMPORTED_MODULE_4__.Edge.Bottom) ||\n        box?.marginBottom ||\n        style?.marginBottom ||\n        0;\n    const marginLeft = getComputedMargin(node, yoga_layout_load__WEBPACK_IMPORTED_MODULE_4__.Edge.Left) ||\n        box?.marginLeft ||\n        style?.marginLeft ||\n        0;\n    return { marginTop, marginRight, marginBottom, marginLeft };\n};\n\n/**\n * Get Yoga computed position. Zero otherwise\n *\n * @param node\n * @returns Position\n */\nconst getPosition = (node) => {\n    const { yogaNode } = node;\n    return {\n        top: yogaNode?.getComputedTop() || 0,\n        right: yogaNode?.getComputedRight() || 0,\n        bottom: yogaNode?.getComputedBottom() || 0,\n        left: yogaNode?.getComputedLeft() || 0,\n    };\n};\n\nconst DEFAULT_DIMENSION = {\n    width: 0,\n    height: 0,\n};\n/**\n * Get Yoga computed dimensions. Zero otherwise\n *\n * @param node\n * @returns Dimensions\n */\nconst getDimension = (node) => {\n    const { yogaNode } = node;\n    if (!yogaNode)\n        return DEFAULT_DIMENSION;\n    return {\n        width: yogaNode.getComputedWidth(),\n        height: yogaNode.getComputedHeight(),\n    };\n};\n\nconst getComputedBorder = (yogaNode, edge) => (yogaNode ? yogaNode.getComputedBorder(edge) : 0);\n/**\n * Get Yoga computed border width. Zero otherwise\n *\n * @param node\n * @returns Border widths\n */\nconst getBorderWidth = (node) => {\n    const { yogaNode } = node;\n    return {\n        borderTopWidth: getComputedBorder(yogaNode, yoga_layout_load__WEBPACK_IMPORTED_MODULE_4__.Edge.Top),\n        borderRightWidth: getComputedBorder(yogaNode, yoga_layout_load__WEBPACK_IMPORTED_MODULE_4__.Edge.Right),\n        borderBottomWidth: getComputedBorder(yogaNode, yoga_layout_load__WEBPACK_IMPORTED_MODULE_4__.Edge.Bottom),\n        borderLeftWidth: getComputedBorder(yogaNode, yoga_layout_load__WEBPACK_IMPORTED_MODULE_4__.Edge.Left),\n    };\n};\n\n/**\n * Set display attribute to node's Yoga instance\n *\n * @param value - Display\n * @returns Node instance wrapper\n */\nconst setDisplay = (value) => (node) => {\n    const { yogaNode } = node;\n    if (yogaNode) {\n        yogaNode.setDisplay(value === 'none' ? yoga_layout_load__WEBPACK_IMPORTED_MODULE_4__.Display.None : yoga_layout_load__WEBPACK_IMPORTED_MODULE_4__.Display.Flex);\n    }\n    return node;\n};\n\nconst OVERFLOW = {\n    hidden: yoga_layout_load__WEBPACK_IMPORTED_MODULE_4__.Overflow.Hidden,\n    scroll: yoga_layout_load__WEBPACK_IMPORTED_MODULE_4__.Overflow.Scroll,\n};\n/**\n * Set overflow attribute to node's Yoga instance\n *\n * @param value - Overflow value\n * @returns Node instance wrapper\n */\nconst setOverflow = (value) => (node) => {\n    const { yogaNode } = node;\n    if (!(0,_react_pdf_fns__WEBPACK_IMPORTED_MODULE_0__.isNil)(value) && yogaNode) {\n        const overflow = OVERFLOW[value] || yoga_layout_load__WEBPACK_IMPORTED_MODULE_4__.Overflow.Visible;\n        yogaNode.setOverflow(overflow);\n    }\n    return node;\n};\n\nconst FLEX_WRAP = {\n    wrap: yoga_layout_load__WEBPACK_IMPORTED_MODULE_4__.Wrap.Wrap,\n    'wrap-reverse': yoga_layout_load__WEBPACK_IMPORTED_MODULE_4__.Wrap.WrapReverse,\n};\n/**\n * Set flex wrap attribute to node's Yoga instance\n *\n * @param value - Flex wrap value\n * @returns Node instance wrapper\n */\nconst setFlexWrap = (value) => (node) => {\n    const { yogaNode } = node;\n    if (yogaNode) {\n        const flexWrap = FLEX_WRAP[value] || yoga_layout_load__WEBPACK_IMPORTED_MODULE_4__.Wrap.NoWrap;\n        yogaNode.setFlexWrap(flexWrap);\n    }\n    return node;\n};\n\n/**\n * Set generic yoga attribute to node's Yoga instance, handing `auto`, edges and percentage cases\n *\n * @param attr - Property\n * @param edge - Edge\n * @returns Node instance wrapper\n */\nconst setYogaValue = (attr, edge) => (value) => (node) => {\n    const { yogaNode } = node;\n    if (!(0,_react_pdf_fns__WEBPACK_IMPORTED_MODULE_0__.isNil)(value) && yogaNode) {\n        const hasEdge = !(0,_react_pdf_fns__WEBPACK_IMPORTED_MODULE_0__.isNil)(edge);\n        const fixedMethod = `set${(0,_react_pdf_fns__WEBPACK_IMPORTED_MODULE_0__.upperFirst)(attr)}`;\n        const autoMethod = `${fixedMethod}Auto`;\n        const percentMethod = `${fixedMethod}Percent`;\n        const percent = (0,_react_pdf_fns__WEBPACK_IMPORTED_MODULE_0__.matchPercent)(value);\n        if (percent && !yogaNode[percentMethod]) {\n            throw new Error(`You can't pass percentage values to ${attr} property`);\n        }\n        if (percent) {\n            if (hasEdge) {\n                yogaNode[percentMethod]?.(edge, percent.value);\n            }\n            else {\n                yogaNode[percentMethod]?.(percent.value);\n            }\n        }\n        else if (value === 'auto') {\n            if (hasEdge) {\n                yogaNode[autoMethod]?.(edge);\n            }\n            else {\n                yogaNode[autoMethod]?.();\n            }\n        }\n        else if (hasEdge) {\n            yogaNode[fixedMethod]?.(edge, value);\n        }\n        else {\n            yogaNode[fixedMethod]?.(value);\n        }\n    }\n    return node;\n};\n\n/**\n * Set flex grow attribute to node's Yoga instance\n *\n * @param  value - Flex grow value\n * @returns Node instance wrapper\n */\nconst setFlexGrow = (value) => (node) => {\n    return setYogaValue('flexGrow')(value || 0)(node);\n};\n\n/**\n * Set flex basis attribute to node's Yoga instance\n *\n * @param flex - Basis value\n * @param node - Node instance\n * @returns Node instance\n */\nconst setFlexBasis = setYogaValue('flexBasis');\n\nconst ALIGN = {\n    'flex-start': yoga_layout_load__WEBPACK_IMPORTED_MODULE_4__.Align.FlexStart,\n    center: yoga_layout_load__WEBPACK_IMPORTED_MODULE_4__.Align.Center,\n    'flex-end': yoga_layout_load__WEBPACK_IMPORTED_MODULE_4__.Align.FlexEnd,\n    stretch: yoga_layout_load__WEBPACK_IMPORTED_MODULE_4__.Align.Stretch,\n    baseline: yoga_layout_load__WEBPACK_IMPORTED_MODULE_4__.Align.Baseline,\n    'space-between': yoga_layout_load__WEBPACK_IMPORTED_MODULE_4__.Align.SpaceBetween,\n    'space-around': yoga_layout_load__WEBPACK_IMPORTED_MODULE_4__.Align.SpaceAround,\n    'space-evenly': yoga_layout_load__WEBPACK_IMPORTED_MODULE_4__.Align.SpaceEvenly,\n};\n/**\n * Set generic align attribute to node's Yoga instance\n *\n * @param attr - Specific align property\n * @param value - Specific align value\n * @param node - Node\n * @returns Node\n */\nconst setAlign = (attr) => (value) => (node) => {\n    const { yogaNode } = node;\n    const defaultValue = attr === 'items' ? yoga_layout_load__WEBPACK_IMPORTED_MODULE_4__.Align.Stretch : yoga_layout_load__WEBPACK_IMPORTED_MODULE_4__.Align.Auto;\n    if (yogaNode) {\n        const align = ALIGN[value] || defaultValue;\n        yogaNode[`setAlign${(0,_react_pdf_fns__WEBPACK_IMPORTED_MODULE_0__.upperFirst)(attr)}`](align);\n    }\n    return node;\n};\n\n/**\n * Set align self attribute to node's Yoga instance\n *\n * @param align - Value\n * @param node - Node instance\n * @returns Node instance\n */\nconst setAlignSelf = setAlign('self');\n\n/**\n * Set align items attribute to node's Yoga instance\n *\n * @param align - Value\n * @param node - Node instance\n * @returns Node instance\n */\nconst setAlignItems = setAlign('items');\n\n/**\n * Set flex shrink attribute to node's Yoga instance\n *\n * @param value - Flex shrink value\n * @returns Node instance wrapper\n */\nconst setFlexShrink = (value) => (node) => {\n    return setYogaValue('flexShrink')(value || 1)(node);\n};\n\n/**\n * Set aspect ratio attribute to node's Yoga instance\n *\n * @param value - Ratio\n * @returns Node instance\n */\nconst setAspectRatio = (value) => (node) => {\n    const { yogaNode } = node;\n    if (!(0,_react_pdf_fns__WEBPACK_IMPORTED_MODULE_0__.isNil)(value) && yogaNode) {\n        yogaNode.setAspectRatio(value);\n    }\n    return node;\n};\n\n/**\n * Set align content attribute to node's Yoga instance\n *\n * @param align - Value\n * @param node - Instance\n * @returns Node instance\n */\nconst setAlignContent = setAlign('content');\n\nconst POSITION = {\n    absolute: yoga_layout_load__WEBPACK_IMPORTED_MODULE_4__.PositionType.Absolute,\n    relative: yoga_layout_load__WEBPACK_IMPORTED_MODULE_4__.PositionType.Relative,\n    static: yoga_layout_load__WEBPACK_IMPORTED_MODULE_4__.PositionType.Static,\n};\n/**\n * Set position type attribute to node's Yoga instance\n *\n * @param value - Position position type\n * @returns Node instance\n */\nconst setPositionType = (value) => (node) => {\n    const { yogaNode } = node;\n    if (!(0,_react_pdf_fns__WEBPACK_IMPORTED_MODULE_0__.isNil)(value) && yogaNode) {\n        yogaNode.setPositionType(POSITION[value]);\n    }\n    return node;\n};\n\nconst FLEX_DIRECTIONS = {\n    row: yoga_layout_load__WEBPACK_IMPORTED_MODULE_4__.FlexDirection.Row,\n    'row-reverse': yoga_layout_load__WEBPACK_IMPORTED_MODULE_4__.FlexDirection.RowReverse,\n    'column-reverse': yoga_layout_load__WEBPACK_IMPORTED_MODULE_4__.FlexDirection.ColumnReverse,\n};\n/**\n * Set flex direction attribute to node's Yoga instance\n *\n * @param value - Flex direction value\n * @returns Node instance wrapper\n */\nconst setFlexDirection = (value) => (node) => {\n    const { yogaNode } = node;\n    if (yogaNode) {\n        const flexDirection = FLEX_DIRECTIONS[value] || yoga_layout_load__WEBPACK_IMPORTED_MODULE_4__.FlexDirection.Column;\n        yogaNode.setFlexDirection(flexDirection);\n    }\n    return node;\n};\n\nconst JUSTIFY_CONTENT = {\n    center: yoga_layout_load__WEBPACK_IMPORTED_MODULE_4__.Justify.Center,\n    'flex-end': yoga_layout_load__WEBPACK_IMPORTED_MODULE_4__.Justify.FlexEnd,\n    'space-between': yoga_layout_load__WEBPACK_IMPORTED_MODULE_4__.Justify.SpaceBetween,\n    'space-around': yoga_layout_load__WEBPACK_IMPORTED_MODULE_4__.Justify.SpaceAround,\n    'space-evenly': yoga_layout_load__WEBPACK_IMPORTED_MODULE_4__.Justify.SpaceEvenly,\n};\n/**\n * Set justify content attribute to node's Yoga instance\n *\n * @param value - Justify content value\n * @returns Node instance wrapper\n */\nconst setJustifyContent = (value) => (node) => {\n    const { yogaNode } = node;\n    if (!(0,_react_pdf_fns__WEBPACK_IMPORTED_MODULE_0__.isNil)(value) && yogaNode) {\n        const justifyContent = JUSTIFY_CONTENT[value] || yoga_layout_load__WEBPACK_IMPORTED_MODULE_4__.Justify.FlexStart;\n        yogaNode.setJustifyContent(justifyContent);\n    }\n    return node;\n};\n\n/**\n * Set margin top attribute to node's Yoga instance\n *\n * @param margin - Margin top\n * @param node - Node instance\n * @returns Node instance\n */\nconst setMarginTop = setYogaValue('margin', yoga_layout_load__WEBPACK_IMPORTED_MODULE_4__.Edge.Top);\n/**\n * Set margin right attribute to node's Yoga instance\n *\n * @param margin - Margin right\n * @param node - Node instance\n * @returns Node instance\n */\nconst setMarginRight = setYogaValue('margin', yoga_layout_load__WEBPACK_IMPORTED_MODULE_4__.Edge.Right);\n/**\n * Set margin bottom attribute to node's Yoga instance\n *\n * @param margin - Margin bottom\n * @param node - Node instance\n * @returns Node instance\n */\nconst setMarginBottom = setYogaValue('margin', yoga_layout_load__WEBPACK_IMPORTED_MODULE_4__.Edge.Bottom);\n/**\n * Set margin left attribute to node's Yoga instance\n *\n * @param margin - Margin left\n * @param node - Node instance\n * @returns Node instance\n */\nconst setMarginLeft = setYogaValue('margin', yoga_layout_load__WEBPACK_IMPORTED_MODULE_4__.Edge.Left);\n\n/**\n * Set padding top attribute to node's Yoga instance\n *\n * @param padding - Padding top\n * @param node - Node instance\n * @returns Node instance\n */\nconst setPaddingTop = setYogaValue('padding', yoga_layout_load__WEBPACK_IMPORTED_MODULE_4__.Edge.Top);\n/**\n * Set padding right attribute to node's Yoga instance\n *\n * @param padding - Padding right\n * @param node - Node instance\n * @returns Node instance\n */\nconst setPaddingRight = setYogaValue('padding', yoga_layout_load__WEBPACK_IMPORTED_MODULE_4__.Edge.Right);\n/**\n * Set padding bottom attribute to node's Yoga instance\n *\n * @param padding - Padding bottom\n * @param node Node instance\n * @returns Node instance\n */\nconst setPaddingBottom = setYogaValue('padding', yoga_layout_load__WEBPACK_IMPORTED_MODULE_4__.Edge.Bottom);\n/**\n * Set padding left attribute to node's Yoga instance\n *\n * @param padding - Padding left\n * @param node - Node instance\n * @returns Node instance\n */\nconst setPaddingLeft = setYogaValue('padding', yoga_layout_load__WEBPACK_IMPORTED_MODULE_4__.Edge.Left);\n\n/**\n * Set border top attribute to node's Yoga instance\n *\n * @param border - Border top width\n * @param node - Node instance\n * @returns Node instance\n */\nconst setBorderTop = setYogaValue('border', yoga_layout_load__WEBPACK_IMPORTED_MODULE_4__.Edge.Top);\n/**\n * Set border right attribute to node's Yoga instance\n *\n * @param border - Border right width\n * @param node - Node instance\n * @returns Node instance\n */\nconst setBorderRight = setYogaValue('border', yoga_layout_load__WEBPACK_IMPORTED_MODULE_4__.Edge.Right);\n/**\n * Set border bottom attribute to node's Yoga instance\n *\n * @param border - Border bottom width\n * @param node - Node instance\n * @returns Node instance\n */\nconst setBorderBottom = setYogaValue('border', yoga_layout_load__WEBPACK_IMPORTED_MODULE_4__.Edge.Bottom);\n/**\n * Set border left attribute to node's Yoga instance\n *\n * @param border - Border left width\n * @param node - Node instance\n * @returns Node instance\n */\nconst setBorderLeft = setYogaValue('border', yoga_layout_load__WEBPACK_IMPORTED_MODULE_4__.Edge.Left);\n\n/**\n * Set position top attribute to node's Yoga instance\n *\n * @param position - Position top\n * @param node - Node instance\n * @returns Node instance\n */\nconst setPositionTop = setYogaValue('position', yoga_layout_load__WEBPACK_IMPORTED_MODULE_4__.Edge.Top);\n/**\n * Set position right attribute to node's Yoga instance\n *\n * @param position - Position right\n * @param node - Node instance\n * @returns Node instance\n */\nconst setPositionRight = setYogaValue('position', yoga_layout_load__WEBPACK_IMPORTED_MODULE_4__.Edge.Right);\n/**\n * Set position bottom attribute to node's Yoga instance\n *\n * @param position - Position bottom\n * @param node - Node instance\n * @returns Node instance\n */\nconst setPositionBottom = setYogaValue('position', yoga_layout_load__WEBPACK_IMPORTED_MODULE_4__.Edge.Bottom);\n/**\n * Set position left attribute to node's Yoga instance\n *\n * @param position - Position left\n * @param node - Node instance\n * @returns Node instance\n */\nconst setPositionLeft = setYogaValue('position', yoga_layout_load__WEBPACK_IMPORTED_MODULE_4__.Edge.Left);\n\n/**\n * Set width to node's Yoga instance\n *\n * @param width - Width\n * @param node - Node instance\n * @returns Node instance\n */\nconst setWidth = setYogaValue('width');\n/**\n * Set min width to node's Yoga instance\n *\n * @param min - Width\n * @param node - Node instance\n * @returns Node instance\n */\nconst setMinWidth = setYogaValue('minWidth');\n/**\n * Set max width to node's Yoga instance\n *\n * @param max - Width\n * @param node - Node instance\n * @returns Node instance\n */\nconst setMaxWidth = setYogaValue('maxWidth');\n/**\n * Set height to node's Yoga instance\n *\n * @param height - Height\n * @param node - Node instance\n * @returns Node instance\n */\nconst setHeight = setYogaValue('height');\n/**\n * Set min height to node's Yoga instance\n *\n * @param min - Height\n * @param node - Node instance\n * @returns Node instance\n */\nconst setMinHeight = setYogaValue('minHeight');\n/**\n * Set max height to node's Yoga instance\n *\n * @param max - Height\n * @param node - Node instance\n * @returns Node instance\n */\nconst setMaxHeight = setYogaValue('maxHeight');\n\n/**\n * Set rowGap value to node's Yoga instance\n *\n * @param value - Gap value\n * @returns Node instance wrapper\n */\nconst setRowGap = setYogaValue('gap', yoga_layout_load__WEBPACK_IMPORTED_MODULE_4__.Gutter.Row);\n/**\n * Set columnGap value to node's Yoga instance\n *\n * @param value - Gap value\n * @returns Node instance wrapper\n */\nconst setColumnGap = setYogaValue('gap', yoga_layout_load__WEBPACK_IMPORTED_MODULE_4__.Gutter.Column);\n\nconst getAspectRatio = (viewbox) => {\n    if (!viewbox)\n        return null;\n    if (typeof viewbox === 'string')\n        return null;\n    return (viewbox.maxX - viewbox.minX) / (viewbox.maxY - viewbox.minY);\n};\n/**\n * Yoga svg measure function\n *\n * @param page\n * @param node\n * @returns Measure svg\n */\nconst measureCanvas$1 = (page, node) => (width, widthMode, height, heightMode) => {\n    const aspectRatio = getAspectRatio(node.props.viewBox) || 1;\n    if (widthMode === yoga_layout_load__WEBPACK_IMPORTED_MODULE_4__.MeasureMode.Exactly ||\n        widthMode === yoga_layout_load__WEBPACK_IMPORTED_MODULE_4__.MeasureMode.AtMost) {\n        return { width, height: width / aspectRatio };\n    }\n    if (heightMode === yoga_layout_load__WEBPACK_IMPORTED_MODULE_4__.MeasureMode.Exactly) {\n        return { width: height * aspectRatio };\n    }\n    return {};\n};\n\n/**\n * Get lines width (if any)\n *\n * @param node\n * @returns Lines width\n */\nconst linesWidth = (node) => {\n    if (!node.lines)\n        return 0;\n    return Math.max(0, ...node.lines.map((line) => line.xAdvance));\n};\n\n/**\n * Get lines height (if any)\n *\n * @param node\n * @returns Lines height\n */\nconst linesHeight = (node) => {\n    if (!node.lines)\n        return -1;\n    return node.lines.reduce((acc, line) => acc + line.box.height, 0);\n};\n\nconst ALIGNMENT_FACTORS = { center: 0.5, right: 1 };\n/**\n * Yoga text measure function\n *\n * @param page\n * @param node\n * @param fontStore\n * @returns {MeasureText} measure text function\n */\nconst measureText = (page, node, fontStore) => (width, widthMode, height) => {\n    if (widthMode === yoga_layout_load__WEBPACK_IMPORTED_MODULE_4__.MeasureMode.Exactly) {\n        if (!node.lines)\n            node.lines = layoutText(node, width, height, fontStore);\n        return { height: linesHeight(node) };\n    }\n    if (widthMode === yoga_layout_load__WEBPACK_IMPORTED_MODULE_4__.MeasureMode.AtMost) {\n        const alignFactor = ALIGNMENT_FACTORS[node.style?.textAlign] || 0;\n        if (!node.lines) {\n            node.lines = layoutText(node, width, height, fontStore);\n            node.alignOffset = (width - linesWidth(node)) * alignFactor; // Compensate align in variable width containers\n        }\n        return {\n            height: linesHeight(node),\n            width: Math.min(width, linesWidth(node)),\n        };\n    }\n    return {};\n};\n\n/**\n * Get image ratio\n *\n * @param node - Image node\n * @returns Image ratio\n */\nconst getRatio = (node) => {\n    return node.image?.data ? node.image.width / node.image.height : 1;\n};\n\n/**\n * Checks if page has auto height\n *\n * @param page\n * @returns Is page height auto\n */\nconst isHeightAuto = (page) => (0,_react_pdf_fns__WEBPACK_IMPORTED_MODULE_0__.isNil)(page.box?.height);\n\nconst SAFETY_HEIGHT$1 = 10;\n/**\n * Yoga image measure function\n *\n * @param page - Page\n * @param node - Node\n * @returns Measure image\n */\nconst measureImage = (page, node) => (width, widthMode, height, heightMode) => {\n    const imageRatio = getRatio(node);\n    const imageMargin = getMargin(node);\n    const pagePadding = getPadding(page);\n    // TODO: Check image percentage margins\n    const pageArea = isHeightAuto(page)\n        ? Infinity\n        : (page.box?.height || 0) -\n            pagePadding.paddingTop -\n            pagePadding.paddingBottom -\n            imageMargin.marginTop -\n            imageMargin.marginBottom -\n            SAFETY_HEIGHT$1;\n    // Skip measure if image data not present yet\n    if (!node.image)\n        return { width: 0, height: 0 };\n    if (widthMode === yoga_layout_load__WEBPACK_IMPORTED_MODULE_4__.MeasureMode.Exactly &&\n        heightMode === yoga_layout_load__WEBPACK_IMPORTED_MODULE_4__.MeasureMode.Undefined) {\n        const scaledHeight = width / imageRatio;\n        return { height: Math.min(pageArea, scaledHeight) };\n    }\n    if (heightMode === yoga_layout_load__WEBPACK_IMPORTED_MODULE_4__.MeasureMode.Exactly &&\n        (widthMode === yoga_layout_load__WEBPACK_IMPORTED_MODULE_4__.MeasureMode.AtMost ||\n            widthMode === yoga_layout_load__WEBPACK_IMPORTED_MODULE_4__.MeasureMode.Undefined)) {\n        return { width: Math.min(height * imageRatio, width) };\n    }\n    if (widthMode === yoga_layout_load__WEBPACK_IMPORTED_MODULE_4__.MeasureMode.Exactly &&\n        heightMode === yoga_layout_load__WEBPACK_IMPORTED_MODULE_4__.MeasureMode.AtMost) {\n        const scaledHeight = width / imageRatio;\n        return { height: Math.min(height, pageArea, scaledHeight) };\n    }\n    if (widthMode === yoga_layout_load__WEBPACK_IMPORTED_MODULE_4__.MeasureMode.AtMost &&\n        heightMode === yoga_layout_load__WEBPACK_IMPORTED_MODULE_4__.MeasureMode.AtMost) {\n        if (imageRatio > 1) {\n            return {\n                width,\n                height: Math.min(width / imageRatio, height),\n            };\n        }\n        return {\n            height,\n            width: Math.min(height * imageRatio, width),\n        };\n    }\n    return { height, width };\n};\n\nconst SAFETY_HEIGHT = 10;\nconst getMax = (values) => Math.max(-Infinity, ...values);\n/**\n * Helper object to predict canvas size\n * TODO: Implement remaining functions (as close as possible);\n */\nconst measureCtx = () => {\n    const ctx = {};\n    const points = [];\n    const nil = () => ctx;\n    const addPoint = (x, y) => points.push([x, y]);\n    const moveTo = (x, y) => {\n        addPoint(x, y);\n        return ctx;\n    };\n    const rect = (x, y, w, h) => {\n        addPoint(x, y);\n        addPoint(x + w, y);\n        addPoint(x, y + h);\n        addPoint(x + w, y + h);\n        return ctx;\n    };\n    const ellipse = (x, y, rx, ry) => {\n        ry = ry || rx;\n        addPoint(x - rx, y - ry);\n        addPoint(x + rx, y - ry);\n        addPoint(x + rx, y + ry);\n        addPoint(x - rx, y + ry);\n        return ctx;\n    };\n    const polygon = (...pts) => {\n        points.push(...pts);\n        return ctx;\n    };\n    // Change dimensions\n    ctx.rect = rect;\n    ctx.moveTo = moveTo;\n    ctx.lineTo = moveTo;\n    ctx.circle = ellipse;\n    ctx.polygon = polygon;\n    ctx.ellipse = ellipse;\n    ctx.roundedRect = rect;\n    // To be implemented\n    ctx.text = nil;\n    ctx.path = nil;\n    ctx.lineWidth = nil;\n    ctx.bezierCurveTo = nil;\n    ctx.quadraticCurveTo = nil;\n    ctx.scale = nil;\n    ctx.rotate = nil;\n    ctx.translate = nil;\n    // These don't change dimensions\n    ctx.dash = nil;\n    ctx.clip = nil;\n    ctx.save = nil;\n    ctx.fill = nil;\n    ctx.font = nil;\n    ctx.stroke = nil;\n    ctx.lineCap = nil;\n    ctx.opacity = nil;\n    ctx.restore = nil;\n    ctx.lineJoin = nil;\n    ctx.fontSize = nil;\n    ctx.fillColor = nil;\n    ctx.miterLimit = nil;\n    ctx.strokeColor = nil;\n    ctx.fillOpacity = nil;\n    ctx.strokeOpacity = nil;\n    ctx.linearGradient = nil;\n    ctx.radialGradient = nil;\n    ctx.getWidth = () => getMax(points.map((p) => p[0]));\n    ctx.getHeight = () => getMax(points.map((p) => p[1]));\n    return ctx;\n};\n/**\n * @typedef {Function} MeasureCanvas\n * @returns {{ width: number, height: number }} canvas width and height\n */\n/**\n * Yoga canvas measure function\n *\n * @param {Object} page\n * @param {Object} node\n * @returns {MeasureCanvas} measure canvas\n */\nconst measureCanvas = (page, node) => () => {\n    const imageMargin = getMargin(node);\n    const pagePadding = getPadding(page);\n    // TODO: Check image percentage margins\n    const pageArea = isHeightAuto(page)\n        ? Infinity\n        : (page.box?.height || 0) -\n            pagePadding.paddingTop -\n            pagePadding.paddingBottom -\n            imageMargin.marginTop -\n            imageMargin.marginBottom -\n            SAFETY_HEIGHT;\n    const ctx = measureCtx();\n    node.props.paint(ctx);\n    const width = ctx.getWidth();\n    const height = Math.min(pageArea, ctx.getHeight());\n    return { width, height };\n};\n\nconst isType$1 = (type) => (node) => node.type === type;\nconst isSvg = isType$1(_react_pdf_primitives__WEBPACK_IMPORTED_MODULE_1__.Svg);\nconst isText$2 = isType$1(_react_pdf_primitives__WEBPACK_IMPORTED_MODULE_1__.Text);\nconst isNote = isType$1(_react_pdf_primitives__WEBPACK_IMPORTED_MODULE_1__.Note);\nconst isPage = isType$1(_react_pdf_primitives__WEBPACK_IMPORTED_MODULE_1__.Page);\nconst isImage = isType$1(_react_pdf_primitives__WEBPACK_IMPORTED_MODULE_1__.Image);\nconst isCanvas = isType$1(_react_pdf_primitives__WEBPACK_IMPORTED_MODULE_1__.Canvas);\nconst isTextInstance$1 = isType$1(_react_pdf_primitives__WEBPACK_IMPORTED_MODULE_1__.TextInstance);\nconst setNodeHeight = (node) => {\n    const value = isPage(node) ? node.box?.height : node.style?.height;\n    return setHeight(value);\n};\n/**\n * Set styles valeus into yoga node before layout calculation\n *\n * @param node\n */\nconst setYogaValues = (node) => {\n    (0,_react_pdf_fns__WEBPACK_IMPORTED_MODULE_0__.compose)(setNodeHeight(node), setWidth(node.style.width), setMinWidth(node.style.minWidth), setMaxWidth(node.style.maxWidth), setMinHeight(node.style.minHeight), setMaxHeight(node.style.maxHeight), setMarginTop(node.style.marginTop), setMarginRight(node.style.marginRight), setMarginBottom(node.style.marginBottom), setMarginLeft(node.style.marginLeft), setPaddingTop(node.style.paddingTop), setPaddingRight(node.style.paddingRight), setPaddingBottom(node.style.paddingBottom), setPaddingLeft(node.style.paddingLeft), setPositionType(node.style.position), setPositionTop(node.style.top), setPositionRight(node.style.right), setPositionBottom(node.style.bottom), setPositionLeft(node.style.left), setBorderTop(node.style.borderTopWidth), setBorderRight(node.style.borderRightWidth), setBorderBottom(node.style.borderBottomWidth), setBorderLeft(node.style.borderLeftWidth), setDisplay(node.style.display), setFlexDirection(node.style.flexDirection), setAlignSelf(node.style.alignSelf), setAlignContent(node.style.alignContent), setAlignItems(node.style.alignItems), setJustifyContent(node.style.justifyContent), setFlexWrap(node.style.flexWrap), setOverflow(node.style.overflow), setAspectRatio(node.style.aspectRatio), setFlexBasis(node.style.flexBasis), setFlexGrow(node.style.flexGrow), setFlexShrink(node.style.flexShrink), setRowGap(node.style.rowGap), setColumnGap(node.style.columnGap))(node);\n};\n/**\n * Inserts child into parent' yoga node\n *\n * @param parent parent\n * @returns Insert yoga nodes\n */\nconst insertYogaNodes = (parent) => (child) => {\n    parent.insertChild(child.yogaNode, parent.getChildCount());\n    return child;\n};\nconst setMeasureFunc = (node, page, fontStore) => {\n    const { yogaNode } = node;\n    if (isText$2(node)) {\n        yogaNode.setMeasureFunc(measureText(page, node, fontStore));\n    }\n    if (isImage(node)) {\n        yogaNode.setMeasureFunc(measureImage(page, node));\n    }\n    if (isCanvas(node)) {\n        yogaNode.setMeasureFunc(measureCanvas(page, node));\n    }\n    if (isSvg(node)) {\n        yogaNode.setMeasureFunc(measureCanvas$1(page, node));\n    }\n    return node;\n};\nconst isLayoutElement = (node) => !isText$2(node) && !isNote(node) && !isSvg(node);\n/**\n * @typedef {Function} CreateYogaNodes\n * @param {Object} node\n * @returns {Object} node with appended yoga node\n */\n/**\n * Creates and add yoga node to document tree\n * Handles measure function for text and image nodes\n *\n * @returns Create yoga nodes\n */\nconst createYogaNodes = (page, fontStore, yoga) => (node) => {\n    const yogaNode = yoga.node.create();\n    const result = Object.assign({}, node, { yogaNode });\n    setYogaValues(result);\n    if (isLayoutElement(node) && node.children) {\n        const resolveChild = (0,_react_pdf_fns__WEBPACK_IMPORTED_MODULE_0__.compose)(insertYogaNodes(yogaNode), createYogaNodes(page, fontStore, yoga));\n        result.children = node.children.map(resolveChild);\n    }\n    setMeasureFunc(result, page, fontStore);\n    return result;\n};\n/**\n * Performs yoga calculation\n *\n * @param page - Page node\n * @returns Page node\n */\nconst calculateLayout = (page) => {\n    page.yogaNode.calculateLayout();\n    return page;\n};\n/**\n * Saves Yoga layout result into 'box' attribute of node\n *\n * @param node\n * @returns Node with box data\n */\nconst persistDimensions = (node) => {\n    if (isTextInstance$1(node))\n        return node;\n    const box = Object.assign(getPadding(node), getMargin(node), getBorderWidth(node), getPosition(node), getDimension(node));\n    const newNode = Object.assign({}, node, { box });\n    if (!node.children)\n        return newNode;\n    const children = node.children.map(persistDimensions);\n    return Object.assign({}, newNode, { children });\n};\n/**\n * Removes yoga node from document tree\n *\n * @param node\n * @returns Node without yoga node\n */\nconst destroyYogaNodes = (node) => {\n    const newNode = Object.assign({}, node);\n    delete newNode.yogaNode;\n    if (!node.children)\n        return newNode;\n    const children = node.children.map(destroyYogaNodes);\n    return Object.assign({}, newNode, { children });\n};\n/**\n * Free yoga node from document tree\n *\n * @param node\n * @returns Node without yoga node\n */\nconst freeYogaNodes = (node) => {\n    if (node.yogaNode)\n        node.yogaNode.freeRecursive();\n    return node;\n};\n/**\n * Calculates page object layout using Yoga.\n * Takes node values from 'box' and 'style' attributes, and persist them back into 'box'\n * Destroy yoga values at the end.\n *\n * @param page - Object\n * @returns Page object with correct 'box' layout attributes\n */\nconst resolvePageDimensions = (page, fontStore, yoga) => {\n    if ((0,_react_pdf_fns__WEBPACK_IMPORTED_MODULE_0__.isNil)(page))\n        return null;\n    return (0,_react_pdf_fns__WEBPACK_IMPORTED_MODULE_0__.compose)(destroyYogaNodes, freeYogaNodes, persistDimensions, calculateLayout, createYogaNodes(page, fontStore, yoga))(page);\n};\n/**\n * Calculates root object layout using Yoga.\n *\n * @param node - Root object\n * @param fontStore - Font store\n * @returns Root object with correct 'box' layout attributes\n */\nconst resolveDimensions = (node, fontStore) => {\n    if (!node.children)\n        return node;\n    const resolveChild = (child) => resolvePageDimensions(child, fontStore, node.yoga);\n    const children = node.children.map(resolveChild);\n    return Object.assign({}, node, { children });\n};\n\nconst isText$1 = (node) => node.type === _react_pdf_primitives__WEBPACK_IMPORTED_MODULE_1__.Text;\n// Prevent splitting elements by low decimal numbers\nconst SAFETY_THRESHOLD = 0.001;\nconst assingChildren = (children, node) => Object.assign({}, node, { children });\nconst getTop = (node) => node.box?.top || 0;\nconst allFixed = (nodes) => nodes.every(isFixed);\nconst isDynamic = (node) => node.props && 'render' in node.props;\nconst relayoutPage = (0,_react_pdf_fns__WEBPACK_IMPORTED_MODULE_0__.compose)(resolveTextLayout, resolvePageDimensions, resolveInheritance, resolvePageStyles);\nconst warnUnavailableSpace = (node) => {\n    console.warn(`Node of type ${node.type} can't wrap between pages and it's bigger than available page height`);\n};\nconst splitNodes = (height, contentArea, nodes) => {\n    const currentChildren = [];\n    const nextChildren = [];\n    for (let i = 0; i < nodes.length; i += 1) {\n        const child = nodes[i];\n        const futureNodes = nodes.slice(i + 1);\n        const futureFixedNodes = futureNodes.filter(isFixed);\n        const nodeTop = getTop(child);\n        const nodeHeight = child.box.height;\n        const isOutside = height <= nodeTop;\n        const shouldBreak$1 = shouldBreak(child, futureNodes, height);\n        const shouldSplit = height + SAFETY_THRESHOLD < nodeTop + nodeHeight;\n        const canWrap = getWrap(child);\n        const fitsInsidePage = nodeHeight <= contentArea;\n        if (isFixed(child)) {\n            nextChildren.push(child);\n            currentChildren.push(child);\n            continue;\n        }\n        if (isOutside) {\n            const box = Object.assign({}, child.box, { top: child.box.top - height });\n            const next = Object.assign({}, child, { box });\n            nextChildren.push(next);\n            continue;\n        }\n        if (!fitsInsidePage && !canWrap) {\n            currentChildren.push(child);\n            nextChildren.push(...futureNodes);\n            warnUnavailableSpace(child);\n            break;\n        }\n        if (shouldBreak$1) {\n            const box = Object.assign({}, child.box, { top: child.box.top - height });\n            const props = Object.assign({}, child.props, {\n                wrap: true,\n                break: false,\n            });\n            const next = Object.assign({}, child, { box, props });\n            currentChildren.push(...futureFixedNodes);\n            nextChildren.push(next, ...futureNodes);\n            break;\n        }\n        if (shouldSplit) {\n            const [currentChild, nextChild] = split(child, height, contentArea);\n            // All children are moved to the next page, it doesn't make sense to show the parent on the current page\n            if (child.children.length > 0 && currentChild.children.length === 0) {\n                // But if the current page is empty then we can just include the parent on the current page\n                if (currentChildren.length === 0) {\n                    currentChildren.push(child, ...futureFixedNodes);\n                    nextChildren.push(...futureNodes);\n                }\n                else {\n                    const box = Object.assign({}, child.box, {\n                        top: child.box.top - height,\n                    });\n                    const next = Object.assign({}, child, { box });\n                    currentChildren.push(...futureFixedNodes);\n                    nextChildren.push(next, ...futureNodes);\n                }\n                break;\n            }\n            if (currentChild)\n                currentChildren.push(currentChild);\n            if (nextChild)\n                nextChildren.push(nextChild);\n            continue;\n        }\n        currentChildren.push(child);\n    }\n    return [currentChildren, nextChildren];\n};\nconst splitChildren = (height, contentArea, node) => {\n    const children = node.children || [];\n    const availableHeight = height - getTop(node);\n    return splitNodes(availableHeight, contentArea, children);\n};\nconst splitView = (node, height, contentArea) => {\n    const [currentNode, nextNode] = splitNode(node, height);\n    const [currentChilds, nextChildren] = splitChildren(height, contentArea, node);\n    return [\n        assingChildren(currentChilds, currentNode),\n        assingChildren(nextChildren, nextNode),\n    ];\n};\nconst split = (node, height, contentArea) => isText$1(node) ? splitText(node, height) : splitView(node, height, contentArea);\nconst shouldResolveDynamicNodes = (node) => {\n    const children = node.children || [];\n    return isDynamic(node) || children.some(shouldResolveDynamicNodes);\n};\nconst resolveDynamicNodes = (props, node) => {\n    const isNodeDynamic = isDynamic(node);\n    // Call render prop on dynamic nodes and append result to children\n    const resolveChildren = (children = []) => {\n        if (isNodeDynamic) {\n            const res = node.props.render(props);\n            return (createInstances(res)\n                .filter(Boolean)\n                // @ts-expect-error rework dynamic nodes. conflicting types\n                .map((n) => resolveDynamicNodes(props, n)));\n        }\n        return children.map((c) => resolveDynamicNodes(props, c));\n    };\n    // We reset dynamic text box so it can be computed again later on\n    const resetHeight = isNodeDynamic && isText$1(node);\n    const box = resetHeight ? { ...node.box, height: 0 } : node.box;\n    const children = resolveChildren(node.children);\n    // @ts-expect-error handle text here specifically\n    const lines = isNodeDynamic ? null : node.lines;\n    return Object.assign({}, node, { box, lines, children });\n};\nconst resolveDynamicPage = (props, page, fontStore, yoga) => {\n    if (shouldResolveDynamicNodes(page)) {\n        const resolvedPage = resolveDynamicNodes(props, page);\n        return relayoutPage(resolvedPage, fontStore, yoga);\n    }\n    return page;\n};\nconst splitPage = (page, pageNumber, fontStore, yoga) => {\n    const wrapArea = getWrapArea(page);\n    const contentArea = getContentArea(page);\n    const dynamicPage = resolveDynamicPage({ pageNumber }, page, fontStore, yoga);\n    const height = page.style.height;\n    const [currentChilds, nextChilds] = splitNodes(wrapArea, contentArea, dynamicPage.children);\n    const relayout = (node) => \n    // @ts-expect-error rework pagination\n    relayoutPage(node, fontStore, yoga);\n    const currentBox = { ...page.box, height };\n    const currentPage = relayout(Object.assign({}, page, { box: currentBox, children: currentChilds }));\n    if (nextChilds.length === 0 || allFixed(nextChilds))\n        return [currentPage, null];\n    const nextBox = (0,_react_pdf_fns__WEBPACK_IMPORTED_MODULE_0__.omit)('height', page.box);\n    const nextProps = (0,_react_pdf_fns__WEBPACK_IMPORTED_MODULE_0__.omit)('bookmark', page.props);\n    const nextPage = relayout(Object.assign({}, page, {\n        props: nextProps,\n        box: nextBox,\n        children: nextChilds,\n    }));\n    return [currentPage, nextPage];\n};\nconst resolvePageIndices = (fontStore, yoga, page, pageNumber, pages) => {\n    const totalPages = pages.length;\n    const props = {\n        totalPages,\n        pageNumber: pageNumber + 1,\n        subPageNumber: page.subPageNumber + 1,\n        subPageTotalPages: page.subPageTotalPages,\n    };\n    return resolveDynamicPage(props, page, fontStore, yoga);\n};\nconst assocSubPageData = (subpages) => {\n    return subpages.map((page, i) => ({\n        ...page,\n        subPageNumber: i,\n        subPageTotalPages: subpages.length,\n    }));\n};\nconst dissocSubPageData = (page) => {\n    return (0,_react_pdf_fns__WEBPACK_IMPORTED_MODULE_0__.omit)(['subPageNumber', 'subPageTotalPages'], page);\n};\nconst paginate = (page, pageNumber, fontStore, yoga) => {\n    if (!page)\n        return [];\n    if (page.props?.wrap === false)\n        return [page];\n    let splittedPage = splitPage(page, pageNumber, fontStore, yoga);\n    const pages = [splittedPage[0]];\n    let nextPage = splittedPage[1];\n    while (nextPage !== null) {\n        splittedPage = splitPage(nextPage, pageNumber + pages.length, fontStore, yoga);\n        pages.push(splittedPage[0]);\n        nextPage = splittedPage[1];\n    }\n    return pages;\n};\n/**\n * Performs pagination. This is the step responsible of breaking the whole document\n * into pages following pagiation rules, such as `fixed`, `break` and dynamic nodes.\n *\n * @param root - Document node\n * @param fontStore - Font store\n * @returns Layout node\n */\nconst resolvePagination = (root, fontStore) => {\n    let pages = [];\n    let pageNumber = 1;\n    for (let i = 0; i < root.children.length; i += 1) {\n        const page = root.children[i];\n        let subpages = paginate(page, pageNumber, fontStore, root.yoga);\n        subpages = assocSubPageData(subpages);\n        pageNumber += subpages.length;\n        pages = pages.concat(subpages);\n    }\n    pages = pages.map((...args) => dissocSubPageData(resolvePageIndices(fontStore, root.yoga, ...args)));\n    return assingChildren(pages, root);\n};\n\n/**\n * Translates page percentage horizontal paddings in fixed ones\n *\n * @param container - Page container\n * @returns Resolve page horizontal padding\n */\nconst resolvePageHorizontalPadding = (container) => (value) => {\n    const match = (0,_react_pdf_fns__WEBPACK_IMPORTED_MODULE_0__.matchPercent)(value);\n    const width = container.width;\n    return match ? match.percent * width : value;\n};\n/**\n * Translates page percentage vertical paddings in fixed ones\n *\n * @param container - Page container\n * @returns Resolve page vertical padding\n */\nconst resolvePageVerticalPadding = (container) => (value) => {\n    const match = (0,_react_pdf_fns__WEBPACK_IMPORTED_MODULE_0__.matchPercent)(value);\n    const height = container.height;\n    return match ? match.percent * height : value;\n};\n/**\n * Translates page percentage paddings in fixed ones\n *\n * @param page\n * @returns Page with fixed paddings\n */\nconst resolvePagePaddings = (page) => {\n    const container = page.style;\n    const style = (0,_react_pdf_fns__WEBPACK_IMPORTED_MODULE_0__.evolve)({\n        paddingTop: resolvePageVerticalPadding(container),\n        paddingLeft: resolvePageHorizontalPadding(container),\n        paddingRight: resolvePageHorizontalPadding(container),\n        paddingBottom: resolvePageVerticalPadding(container),\n    }, page.style);\n    return Object.assign({}, page, { style });\n};\n/**\n * Translates all pages percentage paddings in fixed ones\n * This has to be computed from pages calculated size and not by Yoga\n * because at this point we didn't performed pagination yet.\n *\n * @param root - Document root\n * @returns Document root with translated page paddings\n */\nconst resolvePagesPaddings = (root) => {\n    if (!root.children)\n        return root;\n    const children = root.children.map(resolvePagePaddings);\n    return Object.assign({}, root, { children });\n};\n\nconst resolveRadius = (box) => (value) => {\n    if (!value)\n        return undefined;\n    const match = (0,_react_pdf_fns__WEBPACK_IMPORTED_MODULE_0__.matchPercent)(value);\n    return match ? match.percent * Math.min(box.width, box.height) : value;\n};\n/**\n * Transforms percent border radius into fixed values\n *\n * @param node\n * @returns Node\n */\nconst resolvePercentRadius = (node) => {\n    const style = (0,_react_pdf_fns__WEBPACK_IMPORTED_MODULE_0__.evolve)({\n        borderTopLeftRadius: resolveRadius(node.box),\n        borderTopRightRadius: resolveRadius(node.box),\n        borderBottomRightRadius: resolveRadius(node.box),\n        borderBottomLeftRadius: resolveRadius(node.box),\n    }, node.style || {});\n    const newNode = Object.assign({}, node, { style });\n    if (!node.children)\n        return newNode;\n    const children = node.children.map(resolvePercentRadius);\n    return Object.assign({}, newNode, { children });\n};\n\n/**\n * Transform percent height into fixed\n *\n * @param height\n * @returns Height\n */\nconst transformHeight = (pageArea, height) => {\n    const match = (0,_react_pdf_fns__WEBPACK_IMPORTED_MODULE_0__.matchPercent)(height);\n    return match ? match.percent * pageArea : height;\n};\n/**\n * Get page area (height minus paddings)\n *\n * @param page\n * @returns Page area\n */\nconst getPageArea = (page) => {\n    const pageHeight = page.style.height;\n    const pagePaddingTop = (page.style?.paddingTop || 0);\n    const pagePaddingBottom = (page.style?.paddingBottom || 0);\n    return pageHeight - pagePaddingTop - pagePaddingBottom;\n};\n/**\n * Transform node percent height to fixed\n *\n * @param page\n * @param node\n * @returns Transformed node\n */\nconst resolveNodePercentHeight = (page, node) => {\n    if ((0,_react_pdf_fns__WEBPACK_IMPORTED_MODULE_0__.isNil)(page.style?.height))\n        return node;\n    if ((0,_react_pdf_fns__WEBPACK_IMPORTED_MODULE_0__.isNil)(node.style?.height))\n        return node;\n    const pageArea = getPageArea(page);\n    const height = transformHeight(pageArea, node.style.height);\n    const style = Object.assign({}, node.style, { height });\n    return Object.assign({}, node, { style });\n};\n/**\n * Transform page immediate children with percent height to fixed\n *\n * @param page\n * @returns Transformed page\n */\nconst resolvePagePercentHeight = (page) => {\n    if (!page.children)\n        return page;\n    const resolveChild = (child) => resolveNodePercentHeight(page, child);\n    const children = page.children.map(resolveChild);\n    return Object.assign({}, page, { children });\n};\n/**\n * Transform all page immediate children with percent height to fixed.\n * This is needed for computing correct dimensions on pre-pagination layout.\n *\n * @param root - Document root\n * @returns Transformed document root\n */\nconst resolvePercentHeight = (root) => {\n    if (!root.children)\n        return root;\n    const children = root.children.map(resolvePagePercentHeight);\n    return Object.assign({}, root, { children });\n};\n\nconst isType = (type) => (node) => node.type === type;\nconst isLink = isType(_react_pdf_primitives__WEBPACK_IMPORTED_MODULE_1__.Link);\nconst isText = isType(_react_pdf_primitives__WEBPACK_IMPORTED_MODULE_1__.Text);\nconst isTextInstance = isType(_react_pdf_primitives__WEBPACK_IMPORTED_MODULE_1__.TextInstance);\n/**\n * Checks if node has render prop\n *\n * @param node\n * @returns Has render prop?\n */\nconst hasRenderProp = (node) => 'render' in node.props;\n/**\n * Checks if node is text type (Text or TextInstance)\n *\n * @param node\n * @returns Are all children text instances?\n */\nconst isTextType = (node) => isText(node) || isTextInstance(node);\n/**\n * Checks if is tet link that needs to be wrapped in Text\n *\n * @param node\n * @returns Are all children text instances?\n */\nconst isTextLink = (node) => {\n    const children = node.children || [];\n    // Text string inside a Link\n    if (children.every(isTextInstance))\n        return true;\n    // Text node inside a Link\n    if (children.every(isText))\n        return false;\n    return children.every(isTextType);\n};\n/**\n * Wraps node children inside Text node\n *\n * @param node\n * @returns Node with intermediate Text child\n */\nconst wrapText = (node) => {\n    const textElement = {\n        type: _react_pdf_primitives__WEBPACK_IMPORTED_MODULE_1__.Text,\n        props: {},\n        style: {},\n        box: {},\n        children: node.children,\n    };\n    return Object.assign({}, node, { children: [textElement] });\n};\nconst transformLink = (node) => {\n    if (!isLink(node))\n        return node;\n    // If has render prop substitute the instance by a Text, that will\n    // ultimately render the inline Link via the textkit PDF renderer.\n    if (hasRenderProp(node))\n        return Object.assign({}, node, { type: _react_pdf_primitives__WEBPACK_IMPORTED_MODULE_1__.Text });\n    // If is a text link (either contains Text or TextInstance), wrap it\n    // inside a Text element so styles are applied correctly\n    if (isTextLink(node))\n        return wrapText(node);\n    return node;\n};\n/**\n * Transforms Link layout to correctly render text and dynamic rendered links\n *\n * @param node\n * @returns Node with link substitution\n */\nconst resolveLinkSubstitution = (node) => {\n    if (!node.children)\n        return node;\n    const resolveChild = (0,_react_pdf_fns__WEBPACK_IMPORTED_MODULE_0__.compose)(transformLink, resolveLinkSubstitution);\n    const children = node.children.map(resolveChild);\n    return Object.assign({}, node, { children });\n};\n\nconst layout = (0,_react_pdf_fns__WEBPACK_IMPORTED_MODULE_0__.asyncCompose)(resolveZIndex, resolveOrigin, resolveAssets, resolvePagination, resolveTextLayout, resolvePercentRadius, resolveDimensions, resolveSvg, resolveAssets, resolveInheritance, resolvePercentHeight, resolvePagesPaddings, resolveStyles, resolveLinkSubstitution, resolveBookmarks, resolvePageSizes, resolveYoga);\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQHJlYWN0LXBkZitsYXlvdXRANC40LjAvbm9kZV9tb2R1bGVzL0ByZWFjdC1wZGYvbGF5b3V0L2xpYi9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUFtTDtBQUN4STtBQUNtQztBQUN3RjtBQUM3SDtBQUNpQjtBQUNyQjtBQUNPOztBQUU1QztBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDBEQUFVO0FBQzdCO0FBQ0EsbUJBQW1CLDBEQUFVO0FBQzdCO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHdDQUF3Qyx3REFBTztBQUMvQyxpREFBaUQsK0RBQWM7QUFDL0Q7QUFDQSxRQUFRO0FBQ1IsZUFBZTtBQUNmLGlCQUFpQjtBQUNqQixrQkFBa0I7QUFDbEIsa0JBQWtCO0FBQ2xCLG1CQUFtQjtBQUNuQixvQkFBb0I7QUFDcEI7QUFDQSxpQkFBaUIsOERBQVk7QUFDN0I7QUFDQTtBQUNBLGtCQUFrQixZQUFZO0FBQzlCO0FBQ0EsWUFBWSxvSkFBb0o7QUFDaEs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDhCQUE4QjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVELGlFQUFhO0FBQ3BFO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBLDJCQUEy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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLFlBQVk7QUFDWixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsTUFBTTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixlQUFlO0FBQ3pDO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsdURBQU07QUFDcEIsaUJBQWlCO0FBQ2pCLGlCQUFpQjtBQUNqQixlQUFlO0FBQ2Y7QUFDQTtBQUNBLDJCQUEyQixVQUFVLHlCQUF5QjtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixVQUFVLE1BQU0sdURBQU0sRUFBRTtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsdURBQU87QUFDaEM7QUFDQSwyQkFBMkIsVUFBVSxVQUFVO0FBQy9DOztBQUVBLGVBQWUsNERBQVk7O0FBRUUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9kaXNlYXNlLXByZWRpY3Rpb24tZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvLnBucG0vQHJlYWN0LXBkZitsYXlvdXRANC40LjAvbm9kZV9tb2R1bGVzL0ByZWFjdC1wZGYvbGF5b3V0L2xpYi9pbmRleC5qcz8zZGZhIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHVwcGVyRmlyc3QsIGNhcGl0YWxpemUsIHBhcnNlRmxvYXQgYXMgcGFyc2VGbG9hdCQxLCB3aXRob3V0LCBwaWNrLCBjb21wb3NlLCBldm9sdmUsIG1hcFZhbHVlcywgbWF0Y2hQZXJjZW50LCBjYXN0QXJyYXksIGlzTmlsLCBvbWl0LCBhc3luY0NvbXBvc2UgfSBmcm9tICdAcmVhY3QtcGRmL2Zucyc7XG5pbXBvcnQgKiBhcyBQIGZyb20gJ0ByZWFjdC1wZGYvcHJpbWl0aXZlcyc7XG5pbXBvcnQgcmVzb2x2ZVN0eWxlLCB7IHRyYW5zZm9ybUNvbG9yLCBmbGF0dGVuIH0gZnJvbSAnQHJlYWN0LXBkZi9zdHlsZXNoZWV0JztcbmltcG9ydCBsYXlvdXRFbmdpbmUsIHsgZm9udFN1YnN0aXR1dGlvbiwgd29yZEh5cGhlbmF0aW9uLCBzY3JpcHRJdGVtaXplciwgdGV4dERlY29yYXRpb24sIGp1c3RpZmljYXRpb24sIGxpbmVicmVha2VyLCBiaWRpLCBmcm9tRnJhZ21lbnRzIH0gZnJvbSAnQHJlYWN0LXBkZi90ZXh0a2l0JztcbmltcG9ydCAqIGFzIFlvZ2EgZnJvbSAneW9nYS1sYXlvdXQvbG9hZCc7XG5pbXBvcnQgeyBsb2FkWW9nYSBhcyBsb2FkWW9nYSQxIH0gZnJvbSAneW9nYS1sYXlvdXQvbG9hZCc7XG5pbXBvcnQgZW1vamlSZWdleCBmcm9tICdlbW9qaS1yZWdleCc7XG5pbXBvcnQgcmVzb2x2ZUltYWdlIGZyb20gJ0ByZWFjdC1wZGYvaW1hZ2UnO1xuXG4vKipcbiAqIEFwcGx5IHRyYW5zZm9ybWF0aW9uIHRvIHRleHQgc3RyaW5nXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHRleHRcbiAqIEBwYXJhbSB7c3RyaW5nfSB0cmFuc2Zvcm1hdGlvbiB0eXBlXG4gKiBAcmV0dXJucyB7c3RyaW5nfSB0cmFuc2Zvcm1lZCB0ZXh0XG4gKi9cbmNvbnN0IHRyYW5zZm9ybVRleHQgPSAodGV4dCwgdHJhbnNmb3JtYXRpb24pID0+IHtcbiAgICBzd2l0Y2ggKHRyYW5zZm9ybWF0aW9uKSB7XG4gICAgICAgIGNhc2UgJ3VwcGVyY2FzZSc6XG4gICAgICAgICAgICByZXR1cm4gdGV4dC50b1VwcGVyQ2FzZSgpO1xuICAgICAgICBjYXNlICdsb3dlcmNhc2UnOlxuICAgICAgICAgICAgcmV0dXJuIHRleHQudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgY2FzZSAnY2FwaXRhbGl6ZSc6XG4gICAgICAgICAgICByZXR1cm4gY2FwaXRhbGl6ZSh0ZXh0KTtcbiAgICAgICAgY2FzZSAndXBwZXJmaXJzdCc6XG4gICAgICAgICAgICByZXR1cm4gdXBwZXJGaXJzdCh0ZXh0KTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiB0ZXh0O1xuICAgIH1cbn07XG5cbmNvbnN0IGlzVHNwYW4gPSAobm9kZSkgPT4gbm9kZS50eXBlID09PSBQLlRzcGFuO1xuY29uc3QgaXNUZXh0SW5zdGFuY2UkNCA9IChub2RlKSA9PiBub2RlLnR5cGUgPT09IFAuVGV4dEluc3RhbmNlO1xuY29uc3QgZW5naW5lcyQxID0ge1xuICAgIGJpZGksXG4gICAgbGluZWJyZWFrZXIsXG4gICAganVzdGlmaWNhdGlvbixcbiAgICB0ZXh0RGVjb3JhdGlvbixcbiAgICBzY3JpcHRJdGVtaXplcixcbiAgICB3b3JkSHlwaGVuYXRpb24sXG4gICAgZm9udFN1YnN0aXR1dGlvbixcbn07XG5jb25zdCBlbmdpbmUkMSA9IGxheW91dEVuZ2luZShlbmdpbmVzJDEpO1xuY29uc3QgZ2V0RnJhZ21lbnRzJDEgPSAoZm9udFN0b3JlLCBpbnN0YW5jZSkgPT4ge1xuICAgIGlmICghaW5zdGFuY2UpXG4gICAgICAgIHJldHVybiBbeyBzdHJpbmc6ICcnIH1dO1xuICAgIGNvbnN0IGZyYWdtZW50cyA9IFtdO1xuICAgIGNvbnN0IHsgZmlsbCA9ICdibGFjaycsIGZvbnRGYW1pbHkgPSAnSGVsdmV0aWNhJywgZm9udFdlaWdodCwgZm9udFN0eWxlLCBmb250U2l6ZSA9IDE4LCB0ZXh0RGVjb3JhdGlvbkNvbG9yLCB0ZXh0RGVjb3JhdGlvblN0eWxlLCB0ZXh0VHJhbnNmb3JtLCBvcGFjaXR5LCB9ID0gaW5zdGFuY2UucHJvcHM7XG4gICAgY29uc3QgX3RleHREZWNvcmF0aW9uID0gaW5zdGFuY2UucHJvcHMudGV4dERlY29yYXRpb247XG4gICAgY29uc3QgZm9udEZhbWlsaWVzID0gdHlwZW9mIGZvbnRGYW1pbHkgPT09ICdzdHJpbmcnID8gW2ZvbnRGYW1pbHldIDogWy4uLihmb250RmFtaWx5IHx8IFtdKV07XG4gICAgLy8gRmFsbGJhY2sgZm9udFxuICAgIGZvbnRGYW1pbGllcy5wdXNoKCdIZWx2ZXRpY2EnKTtcbiAgICBjb25zdCBmb250ID0gZm9udEZhbWlsaWVzLm1hcCgoZm9udEZhbWlseU5hbWUpID0+IHtcbiAgICAgICAgY29uc3Qgb3B0cyA9IHsgZm9udEZhbWlseTogZm9udEZhbWlseU5hbWUsIGZvbnRXZWlnaHQsIGZvbnRTdHlsZSB9O1xuICAgICAgICBjb25zdCBvYmogPSBmb250U3RvcmUuZ2V0Rm9udChvcHRzKTtcbiAgICAgICAgcmV0dXJuIG9iaj8uZGF0YTtcbiAgICB9KTtcbiAgICBjb25zdCBhdHRyaWJ1dGVzID0ge1xuICAgICAgICBmb250LFxuICAgICAgICBvcGFjaXR5LFxuICAgICAgICBmb250U2l6ZSxcbiAgICAgICAgY29sb3I6IGZpbGwsXG4gICAgICAgIHVuZGVybGluZVN0eWxlOiB0ZXh0RGVjb3JhdGlvblN0eWxlLFxuICAgICAgICB1bmRlcmxpbmU6IF90ZXh0RGVjb3JhdGlvbiA9PT0gJ3VuZGVybGluZScgfHxcbiAgICAgICAgICAgIF90ZXh0RGVjb3JhdGlvbiA9PT0gJ3VuZGVybGluZSBsaW5lLXRocm91Z2gnIHx8XG4gICAgICAgICAgICBfdGV4dERlY29yYXRpb24gPT09ICdsaW5lLXRocm91Z2ggdW5kZXJsaW5lJyxcbiAgICAgICAgdW5kZXJsaW5lQ29sb3I6IHRleHREZWNvcmF0aW9uQ29sb3IgfHwgZmlsbCxcbiAgICAgICAgc3RyaWtlOiBfdGV4dERlY29yYXRpb24gPT09ICdsaW5lLXRocm91Z2gnIHx8XG4gICAgICAgICAgICBfdGV4dERlY29yYXRpb24gPT09ICd1bmRlcmxpbmUgbGluZS10aHJvdWdoJyB8fFxuICAgICAgICAgICAgX3RleHREZWNvcmF0aW9uID09PSAnbGluZS10aHJvdWdoIHVuZGVybGluZScsXG4gICAgICAgIHN0cmlrZVN0eWxlOiB0ZXh0RGVjb3JhdGlvblN0eWxlLFxuICAgICAgICBzdHJpa2VDb2xvcjogdGV4dERlY29yYXRpb25Db2xvciB8fCBmaWxsLFxuICAgIH07XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbnN0YW5jZS5jaGlsZHJlbi5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBjb25zdCBjaGlsZCA9IGluc3RhbmNlLmNoaWxkcmVuW2ldO1xuICAgICAgICBpZiAoaXNUZXh0SW5zdGFuY2UkNChjaGlsZCkpIHtcbiAgICAgICAgICAgIGZyYWdtZW50cy5wdXNoKHtcbiAgICAgICAgICAgICAgICBzdHJpbmc6IHRyYW5zZm9ybVRleHQoY2hpbGQudmFsdWUsIHRleHRUcmFuc2Zvcm0pLFxuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXMsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjaGlsZCkge1xuICAgICAgICAgICAgZnJhZ21lbnRzLnB1c2goLi4uZ2V0RnJhZ21lbnRzJDEoZm9udFN0b3JlLCBjaGlsZCkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmcmFnbWVudHM7XG59O1xuY29uc3QgZ2V0QXR0cmlidXRlZFN0cmluZyQxID0gKGZvbnRTdG9yZSwgaW5zdGFuY2UpID0+IGZyb21GcmFnbWVudHMoZ2V0RnJhZ21lbnRzJDEoZm9udFN0b3JlLCBpbnN0YW5jZSkpO1xuY29uc3QgQWxtb3N0SW5maW5pdHkgPSA5OTk5OTk5OTk5OTk7XG5jb25zdCBzaHJpbmtXaGl0ZXNwYWNlRmFjdG9yID0geyBiZWZvcmU6IC0wLjUsIGFmdGVyOiAtMC41IH07XG5jb25zdCBsYXlvdXRUc3BhbiA9IChmb250U3RvcmUpID0+IChub2RlLCB4T2Zmc2V0KSA9PiB7XG4gICAgY29uc3QgYXR0cmlidXRlZFN0cmluZyA9IGdldEF0dHJpYnV0ZWRTdHJpbmckMShmb250U3RvcmUsIG5vZGUpO1xuICAgIGNvbnN0IHggPSBub2RlLnByb3BzLnggPT09IHVuZGVmaW5lZCA/IHhPZmZzZXQgOiBub2RlLnByb3BzLng7XG4gICAgY29uc3QgeSA9IG5vZGUucHJvcHM/LnkgfHwgMDtcbiAgICBjb25zdCBjb250YWluZXIgPSB7IHgsIHksIHdpZHRoOiBBbG1vc3RJbmZpbml0eSwgaGVpZ2h0OiBBbG1vc3RJbmZpbml0eSB9O1xuICAgIGNvbnN0IGh5cGhlbmF0aW9uQ2FsbGJhY2sgPSBub2RlLnByb3BzLmh5cGhlbmF0aW9uQ2FsbGJhY2sgfHxcbiAgICAgICAgZm9udFN0b3JlPy5nZXRIeXBoZW5hdGlvbkNhbGxiYWNrKCkgfHxcbiAgICAgICAgbnVsbDtcbiAgICBjb25zdCBsYXlvdXRPcHRpb25zID0geyBoeXBoZW5hdGlvbkNhbGxiYWNrLCBzaHJpbmtXaGl0ZXNwYWNlRmFjdG9yIH07XG4gICAgY29uc3QgbGluZXMgPSBlbmdpbmUkMShhdHRyaWJ1dGVkU3RyaW5nLCBjb250YWluZXIsIGxheW91dE9wdGlvbnMpLmZsYXQoKTtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgbm9kZSwgeyBsaW5lcyB9KTtcbn07XG4vLyBDb25zZWN1dGl2ZSBUU3BhbiBlbGVtZW50cyBzaG91bGQgYmUgam9pbmVkIHdpdGggYSBzcGFjZVxuY29uc3Qgam9pblRTcGFuTGluZXMgPSAobm9kZSkgPT4ge1xuICAgIGNvbnN0IGNoaWxkcmVuID0gbm9kZS5jaGlsZHJlbi5tYXAoKGNoaWxkLCBpbmRleCkgPT4ge1xuICAgICAgICBpZiAoIWlzVHNwYW4oY2hpbGQpKVxuICAgICAgICAgICAgcmV0dXJuIGNoaWxkO1xuICAgICAgICBjb25zdCB0ZXh0SW5zdGFuY2UgPSBjaGlsZC5jaGlsZHJlblswXTtcbiAgICAgICAgaWYgKGNoaWxkLnByb3BzLnggPT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgaW5kZXggPCBub2RlLmNoaWxkcmVuLmxlbmd0aCAtIDEgJiZcbiAgICAgICAgICAgIHRleHRJbnN0YW5jZT8udmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBjaGlsZCwge1xuICAgICAgICAgICAgICAgIGNoaWxkcmVuOiBbeyAuLi50ZXh0SW5zdGFuY2UsIHZhbHVlOiBgJHt0ZXh0SW5zdGFuY2UudmFsdWV9IGAgfV0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2hpbGQ7XG4gICAgfSwgW10pO1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBub2RlLCB7IGNoaWxkcmVuIH0pO1xufTtcbmNvbnN0IGxheW91dFRleHQkMSA9IChmb250U3RvcmUsIG5vZGUpID0+IHtcbiAgICBpZiAoIW5vZGUuY2hpbGRyZW4pXG4gICAgICAgIHJldHVybiBub2RlO1xuICAgIGxldCBjdXJyZW50WE9mZnNldCA9IG5vZGUucHJvcHM/LnggfHwgMDtcbiAgICBjb25zdCBsYXlvdXRGbiA9IGxheW91dFRzcGFuKGZvbnRTdG9yZSk7XG4gICAgY29uc3Qgam9pbmVkTm9kZSA9IGpvaW5UU3BhbkxpbmVzKG5vZGUpO1xuICAgIGNvbnN0IGNoaWxkcmVuID0gam9pbmVkTm9kZS5jaGlsZHJlbi5tYXAoKGNoaWxkKSA9PiB7XG4gICAgICAgIGNvbnN0IGNoaWxkV2l0aExheW91dCA9IGxheW91dEZuKGNoaWxkLCBjdXJyZW50WE9mZnNldCk7XG4gICAgICAgIGN1cnJlbnRYT2Zmc2V0ICs9IGNoaWxkV2l0aExheW91dC5saW5lc1swXS54QWR2YW5jZTtcbiAgICAgICAgcmV0dXJuIGNoaWxkV2l0aExheW91dDtcbiAgICB9KTtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgbm9kZSwgeyBjaGlsZHJlbiB9KTtcbn07XG5cbmNvbnN0IGlzRGVmcyA9IChub2RlKSA9PiBub2RlLnR5cGUgPT09IFAuRGVmcztcbmNvbnN0IGdldERlZnMgPSAobm9kZSkgPT4ge1xuICAgIGNvbnN0IGNoaWxkcmVuID0gbm9kZS5jaGlsZHJlbiB8fCBbXTtcbiAgICBjb25zdCBkZWZzID0gY2hpbGRyZW4uZmluZChpc0RlZnMpO1xuICAgIGNvbnN0IHZhbHVlcyA9IGRlZnM/LmNoaWxkcmVuIHx8IFtdO1xuICAgIHJldHVybiB2YWx1ZXMucmVkdWNlKChhY2MsIHZhbHVlKSA9PiB7XG4gICAgICAgIGNvbnN0IGlkID0gdmFsdWUucHJvcHM/LmlkO1xuICAgICAgICBpZiAoaWQpXG4gICAgICAgICAgICBhY2NbaWRdID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBhY2M7XG4gICAgfSwge30pO1xufTtcblxuY29uc3QgaXNOb3REZWZzID0gKG5vZGUpID0+IG5vZGUudHlwZSAhPT0gUC5EZWZzO1xuY29uc3QgZGV0YWNoRGVmcyA9IChub2RlKSA9PiB7XG4gICAgaWYgKCFub2RlLmNoaWxkcmVuKVxuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICBjb25zdCBjaGlsZHJlbiA9IG5vZGUuY2hpbGRyZW4uZmlsdGVyKGlzTm90RGVmcyk7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIG5vZGUsIHsgY2hpbGRyZW4gfSk7XG59O1xuY29uc3QgVVJMX1JFR0VYID0gL3VybFxcKFsnXCJdPyMoW14nXCJdKylbJ1wiXT9cXCkvO1xuY29uc3QgcmVwbGFjZURlZiA9IChkZWZzLCB2YWx1ZSkgPT4ge1xuICAgIGlmICghdmFsdWUpXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgaWYgKCFVUkxfUkVHRVgudGVzdCh2YWx1ZSkpXG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICBjb25zdCBtYXRjaCA9IHZhbHVlLm1hdGNoKFVSTF9SRUdFWCk7XG4gICAgcmV0dXJuIGRlZnNbbWF0Y2hbMV1dO1xufTtcbmNvbnN0IHBhcnNlTm9kZURlZnMgPSAoZGVmcykgPT4gKG5vZGUpID0+IHtcbiAgICBjb25zdCBwcm9wcyA9IG5vZGUucHJvcHM7XG4gICAgY29uc3QgZmlsbCA9IGBmaWxsYCBpbiBwcm9wcyA/IHJlcGxhY2VEZWYoZGVmcywgcHJvcHM/LmZpbGwpIDogdW5kZWZpbmVkO1xuICAgIGNvbnN0IGNsaXBQYXRoID0gYGNsaXBQYXRoYCBpbiBwcm9wc1xuICAgICAgICA/IHJlcGxhY2VEZWYoZGVmcywgcHJvcHM/LmNsaXBQYXRoKVxuICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICBjb25zdCBuZXdQcm9wcyA9IE9iamVjdC5hc3NpZ24oe30sIG5vZGUucHJvcHMsIHsgZmlsbCwgY2xpcFBhdGggfSk7XG4gICAgY29uc3QgY2hpbGRyZW4gPSBub2RlLmNoaWxkcmVuXG4gICAgICAgID8gbm9kZS5jaGlsZHJlbi5tYXAocGFyc2VOb2RlRGVmcyhkZWZzKSlcbiAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIG5vZGUsIHsgcHJvcHM6IG5ld1Byb3BzLCBjaGlsZHJlbiB9KTtcbn07XG5jb25zdCBwYXJzZURlZnMgPSAocm9vdCkgPT4ge1xuICAgIGlmICghcm9vdC5jaGlsZHJlbilcbiAgICAgICAgcmV0dXJuIHJvb3Q7XG4gICAgY29uc3QgZGVmcyA9IGdldERlZnMocm9vdCk7XG4gICAgY29uc3QgY2hpbGRyZW4gPSByb290LmNoaWxkcmVuLm1hcChwYXJzZU5vZGVEZWZzKGRlZnMpKTtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgcm9vdCwgeyBjaGlsZHJlbiB9KTtcbn07XG5jb25zdCByZXBsYWNlRGVmcyA9IChub2RlKSA9PiB7XG4gICAgcmV0dXJuIGRldGFjaERlZnMocGFyc2VEZWZzKG5vZGUpKTtcbn07XG5cbmNvbnN0IHBhcnNlVmlld2JveCA9ICh2YWx1ZSkgPT4ge1xuICAgIGlmICghdmFsdWUpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnKVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgY29uc3QgdmFsdWVzID0gdmFsdWUuc3BsaXQoL1ssXFxzXSsvKS5tYXAocGFyc2VGbG9hdCQxKTtcbiAgICBpZiAodmFsdWVzLmxlbmd0aCAhPT0gNClcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgcmV0dXJuIHsgbWluWDogdmFsdWVzWzBdLCBtaW5ZOiB2YWx1ZXNbMV0sIG1heFg6IHZhbHVlc1syXSwgbWF4WTogdmFsdWVzWzNdIH07XG59O1xuXG5jb25zdCBnZXRDb250YWluZXIkMSA9IChub2RlKSA9PiB7XG4gICAgY29uc3Qgdmlld2JveCA9IHBhcnNlVmlld2JveChub2RlLnByb3BzLnZpZXdCb3gpO1xuICAgIGlmICh2aWV3Ym94KSB7XG4gICAgICAgIHJldHVybiB7IHdpZHRoOiB2aWV3Ym94Lm1heFgsIGhlaWdodDogdmlld2JveC5tYXhZIH07XG4gICAgfVxuICAgIGlmIChub2RlLnByb3BzLndpZHRoICYmIG5vZGUucHJvcHMuaGVpZ2h0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB3aWR0aDogcGFyc2VGbG9hdCQxKG5vZGUucHJvcHMud2lkdGgpLFxuICAgICAgICAgICAgaGVpZ2h0OiBwYXJzZUZsb2F0JDEobm9kZS5wcm9wcy5oZWlnaHQpLFxuICAgICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4geyB3aWR0aDogMCwgaGVpZ2h0OiAwIH07XG59O1xuXG5jb25zdCBCQVNFX1NWR19JTkhFUklURURfUFJPUFMgPSBbXG4gICAgJ3gnLFxuICAgICd5JyxcbiAgICAnY2xpcFBhdGgnLFxuICAgICdjbGlwUnVsZScsXG4gICAgJ29wYWNpdHknLFxuICAgICdmaWxsJyxcbiAgICAnZmlsbE9wYWNpdHknLFxuICAgICdmaWxsUnVsZScsXG4gICAgJ3N0cm9rZScsXG4gICAgJ3N0cm9rZUxpbmVjYXAnLFxuICAgICdzdHJva2VMaW5lam9pbicsXG4gICAgJ3N0cm9rZU9wYWNpdHknLFxuICAgICdzdHJva2VXaWR0aCcsXG4gICAgJ3RleHRBbmNob3InLFxuICAgICdkb21pbmFudEJhc2VsaW5lJyxcbiAgICAnY29sb3InLFxuICAgICdmb250RmFtaWx5JyxcbiAgICAnZm9udFNpemUnLFxuICAgICdmb250U3R5bGUnLFxuICAgICdmb250V2VpZ2h0JyxcbiAgICAnbGV0dGVyU3BhY2luZycsXG4gICAgJ29wYWNpdHknLFxuICAgICd0ZXh0RGVjb3JhdGlvbicsXG4gICAgJ2xpbmVIZWlnaHQnLFxuICAgICd0ZXh0QWxpZ24nLFxuICAgICd2aXNpYmlsaXR5JyxcbiAgICAnd29yZFNwYWNpbmcnLFxuXTtcbi8vIERvIG5vdCBpbmhlcml0IFwieFwiIGZvciA8dHNwYW4+IGVsZW1lbnRzIGZyb20gPHRleHQ+IHBhcmVudFxuY29uc3QgVEVYVF9TVkdfSU5IRVJJVEVEX1BST1BTID0gd2l0aG91dChbJ3gnXSwgQkFTRV9TVkdfSU5IRVJJVEVEX1BST1BTKTtcbmNvbnN0IFNWR19JTkhFUklURURfUFJPUFMgPSB7XG4gICAgW1AuVGV4dF06IFRFWFRfU1ZHX0lOSEVSSVRFRF9QUk9QUyxcbn07XG5jb25zdCBnZXRJbmhlcml0UHJvcHMgPSAobm9kZSkgPT4ge1xuICAgIGNvbnN0IHByb3BzID0gbm9kZS5wcm9wcyB8fCB7fTtcbiAgICBjb25zdCBzdmdJbmhlcml0ZWRQcm9wcyA9IFNWR19JTkhFUklURURfUFJPUFNbbm9kZS50eXBlXSA/PyBCQVNFX1NWR19JTkhFUklURURfUFJPUFM7XG4gICAgcmV0dXJuIHBpY2soc3ZnSW5oZXJpdGVkUHJvcHMsIHByb3BzKTtcbn07XG5jb25zdCBpbmhlcml0UHJvcHMgPSAobm9kZSkgPT4ge1xuICAgIGlmICghbm9kZS5jaGlsZHJlbilcbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgY29uc3QgaW5oZXJpdGVkUHJvcHMgPSBnZXRJbmhlcml0UHJvcHMobm9kZSk7XG4gICAgY29uc3QgY2hpbGRyZW4gPSBub2RlLmNoaWxkcmVuLm1hcCgoY2hpbGQpID0+IHtcbiAgICAgICAgY29uc3QgcHJvcHMgPSBPYmplY3QuYXNzaWduKHt9LCBpbmhlcml0ZWRQcm9wcywgY2hpbGQucHJvcHMgfHwge30pO1xuICAgICAgICBjb25zdCBuZXdDaGlsZCA9IE9iamVjdC5hc3NpZ24oe30sIGNoaWxkLCB7IHByb3BzIH0pO1xuICAgICAgICByZXR1cm4gaW5oZXJpdFByb3BzKG5ld0NoaWxkKTtcbiAgICB9KTtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgbm9kZSwgeyBjaGlsZHJlbiB9KTtcbn07XG5cbmNvbnN0IHBhcnNlQXNwZWN0UmF0aW8gPSAodmFsdWUpID0+IHtcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJylcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIGNvbnN0IG1hdGNoID0gdmFsdWVcbiAgICAgICAgLnJlcGxhY2UoL1tcXHNcXHJcXHRcXG5dKy9nbSwgJyAnKVxuICAgICAgICAucmVwbGFjZSgvXmRlZmVyXFxzLywgJycpXG4gICAgICAgIC5zcGxpdCgnICcpO1xuICAgIGNvbnN0IGFsaWduID0gKG1hdGNoWzBdIHx8ICd4TWlkWU1pZCcpO1xuICAgIGNvbnN0IG1lZXRPclNsaWNlID0gKG1hdGNoWzFdIHx8XG4gICAgICAgICdtZWV0Jyk7XG4gICAgcmV0dXJuIHsgYWxpZ24sIG1lZXRPclNsaWNlIH07XG59O1xuXG5jb25zdCBTVFlMRV9QUk9QUyA9IFtcbiAgICAnd2lkdGgnLFxuICAgICdoZWlnaHQnLFxuICAgICdjb2xvcicsXG4gICAgJ3N0cm9rZScsXG4gICAgJ3N0cm9rZVdpZHRoJyxcbiAgICAnb3BhY2l0eScsXG4gICAgJ2ZpbGxPcGFjaXR5JyxcbiAgICAnc3Ryb2tlT3BhY2l0eScsXG4gICAgJ2ZpbGwnLFxuICAgICdmaWxsUnVsZScsXG4gICAgJ2NsaXBQYXRoJyxcbiAgICAnb2Zmc2V0JyxcbiAgICAndHJhbnNmb3JtJyxcbiAgICAnc3Ryb2tlTGluZWpvaW4nLFxuICAgICdzdHJva2VMaW5lY2FwJyxcbiAgICAnc3Ryb2tlRGFzaGFycmF5JyxcbiAgICAnZ3JhZGllbnRVbml0cycsXG4gICAgJ2dyYWRpZW50VHJhbnNmb3JtJyxcbl07XG5jb25zdCBWRVJUSUNBTF9QUk9QUyA9IFsneScsICd5MScsICd5MicsICdoZWlnaHQnLCAnY3knLCAncnknXTtcbmNvbnN0IEhPUklaT05UQUxfUFJPUFMgPSBbJ3gnLCAneDEnLCAneDInLCAnd2lkdGgnLCAnY3gnLCAncngnXTtcbmNvbnN0IGlzU3ZnJDMgPSAobm9kZSkgPT4gbm9kZS50eXBlID09PSBQLlN2ZztcbmNvbnN0IGlzVGV4dCQ1ID0gKG5vZGUpID0+IG5vZGUudHlwZSA9PT0gUC5UZXh0O1xuY29uc3QgaXNUZXh0SW5zdGFuY2UkMyA9IChub2RlKSA9PiBub2RlLnR5cGUgPT09IFAuVGV4dEluc3RhbmNlO1xuY29uc3QgdHJhbnNmb3JtUGVyY2VudCA9IChjb250YWluZXIpID0+IChwcm9wcykgPT4gbWFwVmFsdWVzKHByb3BzLCAodmFsdWUsIGtleSkgPT4ge1xuICAgIGNvbnN0IG1hdGNoID0gbWF0Y2hQZXJjZW50KHZhbHVlKTtcbiAgICBpZiAobWF0Y2ggJiYgVkVSVElDQUxfUFJPUFMuaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICByZXR1cm4gbWF0Y2gucGVyY2VudCAqIGNvbnRhaW5lci5oZWlnaHQ7XG4gICAgfVxuICAgIGlmIChtYXRjaCAmJiBIT1JJWk9OVEFMX1BST1BTLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgcmV0dXJuIG1hdGNoLnBlcmNlbnQgKiBjb250YWluZXIud2lkdGg7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbn0pO1xuY29uc3QgcGFyc2VQZXJjZW50ID0gKHZhbHVlKSA9PiB7XG4gICAgY29uc3QgbWF0Y2ggPSBtYXRjaFBlcmNlbnQodmFsdWUpO1xuICAgIHJldHVybiBtYXRjaCA/IG1hdGNoLnBlcmNlbnQgOiBwYXJzZUZsb2F0JDEodmFsdWUpO1xufTtcbmNvbnN0IHBhcnNlVHJhbnNmb3JtID0gKGNvbnRhaW5lcikgPT4gKHZhbHVlKSA9PiB7XG4gICAgcmV0dXJuIHJlc29sdmVTdHlsZShjb250YWluZXIsIHsgdHJhbnNmb3JtOiB2YWx1ZSB9KS50cmFuc2Zvcm07XG59O1xuY29uc3QgcGFyc2VQcm9wcyA9IChjb250YWluZXIpID0+IChub2RlKSA9PiB7XG4gICAgbGV0IHByb3BzID0gdHJhbnNmb3JtUGVyY2VudChjb250YWluZXIpKG5vZGUucHJvcHMpO1xuICAgIHByb3BzID0gZXZvbHZlKHtcbiAgICAgICAgeDogcGFyc2VGbG9hdCQxLFxuICAgICAgICB4MTogcGFyc2VGbG9hdCQxLFxuICAgICAgICB4MjogcGFyc2VGbG9hdCQxLFxuICAgICAgICB5OiBwYXJzZUZsb2F0JDEsXG4gICAgICAgIHkxOiBwYXJzZUZsb2F0JDEsXG4gICAgICAgIHkyOiBwYXJzZUZsb2F0JDEsXG4gICAgICAgIHI6IHBhcnNlRmxvYXQkMSxcbiAgICAgICAgcng6IHBhcnNlRmxvYXQkMSxcbiAgICAgICAgcnk6IHBhcnNlRmxvYXQkMSxcbiAgICAgICAgY3g6IHBhcnNlRmxvYXQkMSxcbiAgICAgICAgY3k6IHBhcnNlRmxvYXQkMSxcbiAgICAgICAgd2lkdGg6IHBhcnNlRmxvYXQkMSxcbiAgICAgICAgaGVpZ2h0OiBwYXJzZUZsb2F0JDEsXG4gICAgICAgIG9mZnNldDogcGFyc2VQZXJjZW50LFxuICAgICAgICBmaWxsOiB0cmFuc2Zvcm1Db2xvcixcbiAgICAgICAgb3BhY2l0eTogcGFyc2VQZXJjZW50LFxuICAgICAgICBzdHJva2U6IHRyYW5zZm9ybUNvbG9yLFxuICAgICAgICBzdG9wT3BhY2l0eTogcGFyc2VQZXJjZW50LFxuICAgICAgICBzdG9wQ29sb3I6IHRyYW5zZm9ybUNvbG9yLFxuICAgICAgICB0cmFuc2Zvcm06IHBhcnNlVHJhbnNmb3JtKGNvbnRhaW5lciksXG4gICAgICAgIGdyYWRpZW50VHJhbnNmb3JtOiBwYXJzZVRyYW5zZm9ybShjb250YWluZXIpLFxuICAgIH0sIHByb3BzKTtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgbm9kZSwgeyBwcm9wcyB9KTtcbn07XG5jb25zdCBtZXJnZVN0eWxlcyQxID0gKG5vZGUpID0+IHtcbiAgICBjb25zdCBzdHlsZSA9IG5vZGUuc3R5bGUgfHwge307XG4gICAgY29uc3QgcHJvcHMgPSBPYmplY3QuYXNzaWduKHt9LCBzdHlsZSwgbm9kZS5wcm9wcyk7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIG5vZGUsIHsgcHJvcHMgfSk7XG59O1xuY29uc3QgcmVtb3ZlTm9uZVZhbHVlcyA9IChub2RlKSA9PiB7XG4gICAgY29uc3QgcmVtb3ZlTm9uZSA9ICh2YWx1ZSkgPT4gKHZhbHVlID09PSAnbm9uZScgPyBudWxsIDogdmFsdWUpO1xuICAgIGNvbnN0IHByb3BzID0gbWFwVmFsdWVzKG5vZGUucHJvcHMsIHJlbW92ZU5vbmUpO1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBub2RlLCB7IHByb3BzIH0pO1xufTtcbmNvbnN0IHBpY2tTdHlsZVByb3BzID0gKG5vZGUpID0+IHtcbiAgICBjb25zdCBwcm9wcyA9IG5vZGUucHJvcHMgfHwge307XG4gICAgY29uc3Qgc3R5bGVQcm9wcyA9IHBpY2soU1RZTEVfUFJPUFMsIHByb3BzKTtcbiAgICBjb25zdCBzdHlsZSA9IE9iamVjdC5hc3NpZ24oe30sIHN0eWxlUHJvcHMsIG5vZGUuc3R5bGUgfHwge30pO1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBub2RlLCB7IHN0eWxlIH0pO1xufTtcbmNvbnN0IHBhcnNlU3ZnUHJvcHMgPSAobm9kZSkgPT4ge1xuICAgIGNvbnN0IHByb3BzID0gZXZvbHZlKHtcbiAgICAgICAgd2lkdGg6IHBhcnNlRmxvYXQkMSxcbiAgICAgICAgaGVpZ2h0OiBwYXJzZUZsb2F0JDEsXG4gICAgICAgIHZpZXdCb3g6IHBhcnNlVmlld2JveCxcbiAgICAgICAgcHJlc2VydmVBc3BlY3RSYXRpbzogcGFyc2VBc3BlY3RSYXRpbyxcbiAgICB9LCBub2RlLnByb3BzKTtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgbm9kZSwgeyBwcm9wcyB9KTtcbn07XG5jb25zdCB3cmFwQmV0d2VlblRzcGFuID0gKG5vZGUpID0+ICh7XG4gICAgdHlwZTogUC5Uc3BhbixcbiAgICBwcm9wczoge30sXG4gICAgc3R5bGU6IHt9LFxuICAgIGNoaWxkcmVuOiBbbm9kZV0sXG59KTtcbmNvbnN0IGFkZE1pc3NpbmdUc3BhbiA9IChub2RlKSA9PiB7XG4gICAgaWYgKCFpc1RleHQkNShub2RlKSlcbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgaWYgKCFub2RlLmNoaWxkcmVuKVxuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICBjb25zdCByZXNvbHZlQ2hpbGQgPSAoY2hpbGQpID0+IGlzVGV4dEluc3RhbmNlJDMoY2hpbGQpID8gd3JhcEJldHdlZW5Uc3BhbihjaGlsZCkgOiBjaGlsZDtcbiAgICBjb25zdCBjaGlsZHJlbiA9IG5vZGUuY2hpbGRyZW4ubWFwKHJlc29sdmVDaGlsZCk7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIG5vZGUsIHsgY2hpbGRyZW4gfSk7XG59O1xuY29uc3QgcGFyc2VUZXh0ID0gKGZvbnRTdG9yZSkgPT4gKG5vZGUpID0+IHtcbiAgICBpZiAoaXNUZXh0JDUobm9kZSkpXG4gICAgICAgIHJldHVybiBsYXlvdXRUZXh0JDEoZm9udFN0b3JlLCBub2RlKTtcbiAgICBpZiAoIW5vZGUuY2hpbGRyZW4pXG4gICAgICAgIHJldHVybiBub2RlO1xuICAgIGNvbnN0IGNoaWxkcmVuID0gbm9kZS5jaGlsZHJlbi5tYXAocGFyc2VUZXh0KGZvbnRTdG9yZSkpO1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBub2RlLCB7IGNoaWxkcmVuIH0pO1xufTtcbmNvbnN0IHJlc29sdmVTdmdOb2RlID0gKGNvbnRhaW5lcikgPT4gY29tcG9zZShwYXJzZVByb3BzKGNvbnRhaW5lciksIGFkZE1pc3NpbmdUc3BhbiwgcmVtb3ZlTm9uZVZhbHVlcywgbWVyZ2VTdHlsZXMkMSk7XG5jb25zdCByZXNvbHZlQ2hpbGRyZW4gPSAoY29udGFpbmVyKSA9PiAobm9kZSkgPT4ge1xuICAgIGlmICghbm9kZS5jaGlsZHJlbilcbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgY29uc3QgcmVzb2x2ZUNoaWxkID0gY29tcG9zZShyZXNvbHZlQ2hpbGRyZW4oY29udGFpbmVyKSwgcmVzb2x2ZVN2Z05vZGUoY29udGFpbmVyKSk7XG4gICAgY29uc3QgY2hpbGRyZW4gPSBub2RlLmNoaWxkcmVuLm1hcChyZXNvbHZlQ2hpbGQpO1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBub2RlLCB7IGNoaWxkcmVuIH0pO1xufTtcbmNvbnN0IGJ1aWxkWExpbmtzSW5kZXggPSAobm9kZSkgPT4ge1xuICAgIGNvbnN0IGlkSW5kZXggPSB7fTtcbiAgICBjb25zdCBsaXN0VG9FeHBsb3JlID0gbm9kZS5jaGlsZHJlbj8uc2xpY2UoMCkgfHwgW107XG4gICAgd2hpbGUgKGxpc3RUb0V4cGxvcmUubGVuZ3RoID4gMCkge1xuICAgICAgICBjb25zdCBjaGlsZCA9IGxpc3RUb0V4cGxvcmUuc2hpZnQoKTtcbiAgICAgICAgaWYgKGNoaWxkLnByb3BzICYmICdpZCcgaW4gY2hpbGQucHJvcHMpIHtcbiAgICAgICAgICAgIGlkSW5kZXhbY2hpbGQucHJvcHMuaWRdID0gY2hpbGQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoaWxkLmNoaWxkcmVuKVxuICAgICAgICAgICAgbGlzdFRvRXhwbG9yZS5wdXNoKC4uLmNoaWxkLmNoaWxkcmVuKTtcbiAgICB9XG4gICAgcmV0dXJuIGlkSW5kZXg7XG59O1xuY29uc3QgcmVwbGFjZVhMaW5rcyA9IChub2RlLCBpZEluZGV4KSA9PiB7XG4gICAgaWYgKG5vZGUucHJvcHMgJiYgJ3hsaW5rSHJlZicgaW4gbm9kZS5wcm9wcykge1xuICAgICAgICBjb25zdCBsaW5rZWROb2RlID0gaWRJbmRleFtub2RlLnByb3BzLnhsaW5rSHJlZi5yZXBsYWNlKC9eIy8sICcnKV07XG4gICAgICAgIC8vIE5vIG5vZGUgdG8gZXh0ZW5kIGZyb21cbiAgICAgICAgaWYgKCFsaW5rZWROb2RlKVxuICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgIGNvbnN0IG5ld1Byb3BzID0gT2JqZWN0LmFzc2lnbih7fSwgbGlua2VkTm9kZS5wcm9wcywgbm9kZS5wcm9wcyk7XG4gICAgICAgIGRlbGV0ZSBuZXdQcm9wcy54bGlua0hyZWY7XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBsaW5rZWROb2RlLCB7IHByb3BzOiBuZXdQcm9wcyB9KTtcbiAgICB9XG4gICAgY29uc3QgY2hpbGRyZW4gPSBub2RlLmNoaWxkcmVuPy5tYXAoKGNoaWxkKSA9PiByZXBsYWNlWExpbmtzKGNoaWxkLCBpZEluZGV4KSk7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIG5vZGUsIHsgY2hpbGRyZW4gfSk7XG59O1xuY29uc3QgcmVzb2x2ZVhMaW5rcyA9IChub2RlKSA9PiB7XG4gICAgY29uc3QgaWRJbmRleCA9IGJ1aWxkWExpbmtzSW5kZXgobm9kZSk7XG4gICAgcmV0dXJuIHJlcGxhY2VYTGlua3Mobm9kZSwgaWRJbmRleCk7XG59O1xuY29uc3QgcmVzb2x2ZVN2Z1Jvb3QgPSAobm9kZSwgZm9udFN0b3JlKSA9PiB7XG4gICAgY29uc3QgY29udGFpbmVyID0gZ2V0Q29udGFpbmVyJDEobm9kZSk7XG4gICAgcmV0dXJuIGNvbXBvc2UocmVwbGFjZURlZnMsIHBhcnNlVGV4dChmb250U3RvcmUpLCBwYXJzZVN2Z1Byb3BzLCBwaWNrU3R5bGVQcm9wcywgaW5oZXJpdFByb3BzLCByZXNvbHZlQ2hpbGRyZW4oY29udGFpbmVyKSwgcmVzb2x2ZVhMaW5rcykobm9kZSk7XG59O1xuLyoqXG4gKiBQcmUtcHJvY2VzcyBTVkcgbm9kZXMgc28gdGhleSBjYW4gYmUgcmVuZGVyZWQgaW4gdGhlIG5leHQgc3RlcHNcbiAqXG4gKiBAcGFyYW0gbm9kZSAtIFJvb3Qgbm9kZVxuICogQHBhcmFtIGZvbnRTdG9yZSAtIEZvbnQgc3RvcmVcbiAqIEByZXR1cm5zIFJvb3Qgbm9kZVxuICovXG5jb25zdCByZXNvbHZlU3ZnID0gKG5vZGUsIGZvbnRTdG9yZSkgPT4ge1xuICAgIGlmICghKCdjaGlsZHJlbicgaW4gbm9kZSkpXG4gICAgICAgIHJldHVybiBub2RlO1xuICAgIGNvbnN0IHJlc29sdmVDaGlsZCA9IChjaGlsZCkgPT4gcmVzb2x2ZVN2ZyhjaGlsZCwgZm9udFN0b3JlKTtcbiAgICBjb25zdCByb290ID0gaXNTdmckMyhub2RlKSA/IHJlc29sdmVTdmdSb290KG5vZGUsIGZvbnRTdG9yZSkgOiBub2RlO1xuICAgIGNvbnN0IGNoaWxkcmVuID0gcm9vdC5jaGlsZHJlbj8ubWFwKHJlc29sdmVDaGlsZCk7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIHJvb3QsIHsgY2hpbGRyZW4gfSk7XG59O1xuXG5sZXQgaW5zdGFuY2VQcm9taXNlO1xuY29uc3QgbG9hZFlvZ2EgPSBhc3luYyAoKSA9PiB7XG4gICAgLy8gWW9nYSBXQVNNIGJpbmFyaWVzIG11c3QgYmUgYXN5bmNocm9ub3VzbHkgY29tcGlsZWQgYW5kIGxvYWRlZFxuICAgIC8vIHRvIHByZXZlbnQgRXZlbnQgZW1pdHRlciBtZW1vcnkgbGVhayB3YXJuaW5ncywgWW9nYSBtdXN0IGJlIGxvYWRlZCBvbmx5IG9uY2VcbiAgICBjb25zdCBpbnN0YW5jZSA9IGF3YWl0IChpbnN0YW5jZVByb21pc2UgPz89IGxvYWRZb2dhJDEoKSk7XG4gICAgY29uc3QgY29uZmlnID0gaW5zdGFuY2UuQ29uZmlnLmNyZWF0ZSgpO1xuICAgIGNvbmZpZy5zZXRQb2ludFNjYWxlRmFjdG9yKDApO1xuICAgIGNvbnN0IG5vZGUgPSB7IGNyZWF0ZTogKCkgPT4gaW5zdGFuY2UuTm9kZS5jcmVhdGVXaXRoQ29uZmlnKGNvbmZpZykgfTtcbiAgICByZXR1cm4geyBub2RlIH07XG59O1xuXG5jb25zdCByZXNvbHZlWW9nYSA9IGFzeW5jIChyb290KSA9PiB7XG4gICAgY29uc3QgeW9nYSA9IGF3YWl0IGxvYWRZb2dhKCk7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIHJvb3QsIHsgeW9nYSB9KTtcbn07XG5cbmNvbnN0IGdldFpJbmRleCA9IChub2RlKSA9PiBub2RlLnN0eWxlLnpJbmRleDtcbmNvbnN0IHNob3VsZFNvcnQgPSAobm9kZSkgPT4gbm9kZS50eXBlICE9PSBQLkRvY3VtZW50ICYmIG5vZGUudHlwZSAhPT0gUC5Tdmc7XG5jb25zdCBzb3J0WkluZGV4ID0gKGEsIGIpID0+IHtcbiAgICBjb25zdCB6YSA9IGdldFpJbmRleChhKTtcbiAgICBjb25zdCB6YiA9IGdldFpJbmRleChiKTtcbiAgICBpZiAoIXphICYmICF6YilcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgaWYgKCF6YSlcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgaWYgKCF6YilcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIHJldHVybiB6YiAtIHphO1xufTtcbi8qKlxuICogU29ydCBjaGlsZHJlbiBieSB6SW5kZXggdmFsdWVcbiAqXG4gKiBAcGFyYW0gbm9kZVxuICogQHJldHVybnMgTm9kZVxuICovXG5jb25zdCByZXNvbHZlTm9kZVpJbmRleCA9IChub2RlKSA9PiB7XG4gICAgaWYgKCFub2RlLmNoaWxkcmVuKVxuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICBjb25zdCBzb3J0ZWRDaGlsZHJlbiA9IHNob3VsZFNvcnQobm9kZSlcbiAgICAgICAgPyBub2RlLmNoaWxkcmVuLnNvcnQoc29ydFpJbmRleClcbiAgICAgICAgOiBub2RlLmNoaWxkcmVuO1xuICAgIGNvbnN0IGNoaWxkcmVuID0gc29ydGVkQ2hpbGRyZW4ubWFwKHJlc29sdmVOb2RlWkluZGV4KTtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgbm9kZSwgeyBjaGlsZHJlbiB9KTtcbn07XG4vKipcbiAqIFNvcnQgY2hpbGRyZW4gYnkgekluZGV4IHZhbHVlXG4gKlxuICogQHBhcmFtIG5vZGVcbiAqIEByZXR1cm5zIE5vZGVcbiAqL1xuY29uc3QgcmVzb2x2ZVpJbmRleCA9IChyb290KSA9PiByZXNvbHZlTm9kZVpJbmRleChyb290KTtcblxuLy8gQ2FjaGVzIGVtb2ppIGltYWdlcyBkYXRhXG5jb25zdCBlbW9qaXMgPSB7fTtcbmNvbnN0IHJlZ2V4ID0gZW1vamlSZWdleCgpO1xuLyoqXG4gKiBXaGVuIGFuIGVtb2ppIGFzIG5vIHZhcmlhdGlvbnMsIGl0IG1pZ2h0IHN0aWxsIGhhdmUgMiBwYXJ0cyxcbiAqIHRoZSBjYW5vbmljYWwgZW1vamkgYW5kIGFuIGVtcHR5IHN0cmluZy5cbiAqIGV4LlxuICogICAobm8gY29sb3IpIEFycmF5LmZyb20oJ+KdpO+4jycpID0+IFtcIuKdpFwiLCBcIu+4j1wiXVxuICogICAody8gY29sb3IpIEFycmF5LmZyb20oJ/CfkY3wn4+/JykgPT4gW1wi8J+RjVwiLCBcIvCfj79cIl1cbiAqXG4gKiBUaGUgZW1wdHkgc3RyaW5nIG5lZWRzIHRvIGJlIHJlbW92ZWQgb3RoZXJ3aXNlIHRoZSBnZW5lcmF0ZWRcbiAqIHVybCB3aWxsIGJlIGluY29yZWN0LlxuICovXG5jb25zdCByZW1vdmVWYXJpYXRpb25TZWxlY3RvcnMgPSAoeCkgPT4geCAhPT0gJ++4jyc7XG5jb25zdCBnZXRDb2RlUG9pbnRzID0gKHN0cmluZywgd2l0aFZhcmlhdGlvblNlbGVjdG9ycyA9IGZhbHNlKSA9PiBBcnJheS5mcm9tKHN0cmluZylcbiAgICAuZmlsdGVyKHdpdGhWYXJpYXRpb25TZWxlY3RvcnMgPyAoKSA9PiB0cnVlIDogcmVtb3ZlVmFyaWF0aW9uU2VsZWN0b3JzKVxuICAgIC5tYXAoKGNoYXIpID0+IGNoYXIuY29kZVBvaW50QXQoMCkudG9TdHJpbmcoMTYpKVxuICAgIC5qb2luKCctJyk7XG5jb25zdCBidWlsZEVtb2ppVXJsID0gKGVtb2ppLCBzb3VyY2UpID0+IHtcbiAgICBpZiAoJ2J1aWxkZXInIGluIHNvdXJjZSkge1xuICAgICAgICByZXR1cm4gc291cmNlLmJ1aWxkZXIoZ2V0Q29kZVBvaW50cyhlbW9qaSwgc291cmNlLndpdGhWYXJpYXRpb25TZWxlY3RvcnMpKTtcbiAgICB9XG4gICAgY29uc3QgeyB1cmwsIGZvcm1hdCA9ICdwbmcnLCB3aXRoVmFyaWF0aW9uU2VsZWN0b3JzIH0gPSBzb3VyY2U7XG4gICAgcmV0dXJuIGAke3VybH0ke2dldENvZGVQb2ludHMoZW1vamksIHdpdGhWYXJpYXRpb25TZWxlY3RvcnMpfS4ke2Zvcm1hdH1gO1xufTtcbmNvbnN0IGZldGNoRW1vamlzID0gKHN0cmluZywgc291cmNlKSA9PiB7XG4gICAgaWYgKCFzb3VyY2UpXG4gICAgICAgIHJldHVybiBbXTtcbiAgICBjb25zdCBwcm9taXNlcyA9IFtdO1xuICAgIEFycmF5LmZyb20oc3RyaW5nLm1hdGNoQWxsKHJlZ2V4KSkuZm9yRWFjaCgobWF0Y2gpID0+IHtcbiAgICAgICAgY29uc3QgZW1vamkgPSBtYXRjaFswXTtcbiAgICAgICAgaWYgKCFlbW9qaXNbZW1vamldIHx8IGVtb2ppc1tlbW9qaV0ubG9hZGluZykge1xuICAgICAgICAgICAgY29uc3QgZW1vamlVcmwgPSBidWlsZEVtb2ppVXJsKGVtb2ppLCBzb3VyY2UpO1xuICAgICAgICAgICAgZW1vamlzW2Vtb2ppXSA9IHsgbG9hZGluZzogdHJ1ZSB9O1xuICAgICAgICAgICAgcHJvbWlzZXMucHVzaChyZXNvbHZlSW1hZ2UoeyB1cmk6IGVtb2ppVXJsIH0pLnRoZW4oKGltYWdlKSA9PiB7XG4gICAgICAgICAgICAgICAgZW1vamlzW2Vtb2ppXS5sb2FkaW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgZW1vamlzW2Vtb2ppXS5kYXRhID0gaW1hZ2UuZGF0YTtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBwcm9taXNlcztcbn07XG5jb25zdCBlbWJlZEVtb2ppcyA9IChmcmFnbWVudHMpID0+IHtcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZyYWdtZW50cy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBjb25zdCBmcmFnbWVudCA9IGZyYWdtZW50c1tpXTtcbiAgICAgICAgbGV0IGxhc3RJbmRleCA9IDA7XG4gICAgICAgIEFycmF5LmZyb20oZnJhZ21lbnQuc3RyaW5nLm1hdGNoQWxsKHJlZ2V4KSkuZm9yRWFjaCgobWF0Y2gpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgaW5kZXggfSA9IG1hdGNoO1xuICAgICAgICAgICAgY29uc3QgZW1vamkgPSBtYXRjaFswXTtcbiAgICAgICAgICAgIGNvbnN0IGVtb2ppU2l6ZSA9IGZyYWdtZW50LmF0dHJpYnV0ZXMuZm9udFNpemU7XG4gICAgICAgICAgICBjb25zdCBjaHVuayA9IGZyYWdtZW50LnN0cmluZy5zbGljZShsYXN0SW5kZXgsIGluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoKTtcbiAgICAgICAgICAgIC8vIElmIGVtb2ppIGltYWdlIHdhcyBmb3VuZCwgd2UgY3JlYXRlIGEgbmV3IGZyYWdtZW50IHdpdGggdGhlXG4gICAgICAgICAgICAvLyBjb3JyZWN0IGF0dGFjaG1lbnQgYW5kIG9iamVjdCBzdWJzdGl0dXRpb24gY2hhcmFjdGVyO1xuICAgICAgICAgICAgaWYgKGVtb2ppc1tlbW9qaV0gJiYgZW1vamlzW2Vtb2ppXS5kYXRhKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBzdHJpbmc6IGNodW5rLnJlcGxhY2UobWF0Y2hbMF0sIFN0cmluZy5mcm9tQ2hhckNvZGUoMHhmZmZjKSksXG4gICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLmZyYWdtZW50LmF0dHJpYnV0ZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICBhdHRhY2htZW50OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IGVtb2ppU2l6ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IGVtb2ppU2l6ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB5T2Zmc2V0OiBNYXRoLmZsb29yKGVtb2ppU2l6ZSAqIDAuMSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW1hZ2U6IGVtb2ppc1tlbW9qaV0uZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBJZiBubyBlbW9qaSBkYXRhLCB3ZSB0cnkgdG8gdXNlIGVtb2ppcyBpbiB0aGUgZm9udFxuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgc3RyaW5nOiBjaHVuayxcbiAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlczogZnJhZ21lbnQuYXR0cmlidXRlcyxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxhc3RJbmRleCA9IGluZGV4ICsgZW1vamkubGVuZ3RoO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGxhc3RJbmRleCA8IGZyYWdtZW50LnN0cmluZy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHtcbiAgICAgICAgICAgICAgICBzdHJpbmc6IGZyYWdtZW50LnN0cmluZy5zbGljZShsYXN0SW5kZXgpLFxuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IGZyYWdtZW50LmF0dHJpYnV0ZXMsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBHZXQgaW1hZ2Ugc291cmNlXG4gKlxuICogQHBhcmFtIG5vZGUgLSBJbWFnZSBub2RlXG4gKiBAcmV0dXJucyBJbWFnZSBzcmNcbiAqL1xuY29uc3QgZ2V0U291cmNlID0gKG5vZGUpID0+IHtcbiAgICBpZiAobm9kZS5wcm9wcy5zcmMpXG4gICAgICAgIHJldHVybiBub2RlLnByb3BzLnNyYztcbiAgICBpZiAobm9kZS5wcm9wcy5zb3VyY2UpXG4gICAgICAgIHJldHVybiBub2RlLnByb3BzLnNvdXJjZTtcbn07XG5cbi8qKlxuICogUmVzb2x2ZXMgYHNyY2AgdG8gYEByZWFjdC1wZGYvaW1hZ2VgIGludGVyZmFjZS5cbiAqXG4gKiBBbHNvIGl0IGhhbmRsZXMgZmFjdG9yaWVzIGFuZCBhc3luYyBzb3VyY2VzLlxuICpcbiAqIEBwYXJhbSBzcmNcbiAqIEByZXR1cm5zIFJlc29sdmVkIHNyY1xuICovXG5jb25zdCByZXNvbHZlU291cmNlID0gYXN5bmMgKHNyYykgPT4ge1xuICAgIGNvbnN0IHNvdXJjZSA9IHR5cGVvZiBzcmMgPT09ICdmdW5jdGlvbicgPyBhd2FpdCBzcmMoKSA6IGF3YWl0IHNyYztcbiAgICByZXR1cm4gdHlwZW9mIHNvdXJjZSA9PT0gJ3N0cmluZycgPyB7IHVyaTogc291cmNlIH0gOiBzb3VyY2U7XG59O1xuXG4vKipcbiAqIEZldGNoZXMgaW1hZ2UgYW5kIGFwcGVuZCBkYXRhIHRvIG5vZGVcbiAqIElkZWFsbHkgdGhpcyBmbiBzaG91bGQgYmUgaW1tdXRhYmxlLlxuICpcbiAqIEBwYXJhbSBub2RlXG4gKi9cbmNvbnN0IGZldGNoSW1hZ2UgPSBhc3luYyAobm9kZSkgPT4ge1xuICAgIGNvbnN0IHNyYyA9IGdldFNvdXJjZShub2RlKTtcbiAgICBjb25zdCB7IGNhY2hlIH0gPSBub2RlLnByb3BzO1xuICAgIGlmICghc3JjKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihmYWxzZSwgJ0ltYWdlIHNob3VsZCByZWNlaXZlIGVpdGhlciBhIFwic3JjXCIgb3IgXCJzb3VyY2VcIiBwcm9wJyk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3Qgc291cmNlID0gYXdhaXQgcmVzb2x2ZVNvdXJjZShzcmMpO1xuICAgICAgICBpZiAoIXNvdXJjZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbWFnZSdzIFwic3JjXCIgb3IgXCJzb3VyY2VcIiBwcm9wIHJldHVybmVkICR7c291cmNlfWApO1xuICAgICAgICB9XG4gICAgICAgIG5vZGUuaW1hZ2UgPSBhd2FpdCByZXNvbHZlSW1hZ2Uoc291cmNlLCB7IGNhY2hlIH0pO1xuICAgICAgICBpZiAoQnVmZmVyLmlzQnVmZmVyKHNvdXJjZSkgfHwgc291cmNlIGluc3RhbmNlb2YgQmxvYilcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgbm9kZS5pbWFnZS5rZXkgPSAnZGF0YScgaW4gc291cmNlID8gc291cmNlLmRhdGEudG9TdHJpbmcoKSA6IHNvdXJjZS51cmk7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihlLm1lc3NhZ2UpO1xuICAgIH1cbn07XG5cbmNvbnN0IGlzSW1hZ2UkMiA9IChub2RlKSA9PiBub2RlLnR5cGUgPT09IFAuSW1hZ2U7XG4vKipcbiAqIEdldCBhbGwgYXNzZXQgcHJvbWlzZXMgdGhhdCBuZWVkIHRvIGJlIHJlc29sdmVkXG4gKlxuICogQHBhcmFtIGZvbnRTdG9yZSAtIEZvbnQgc3RvcmVcbiAqIEBwYXJhbSBub2RlIC0gUm9vdCBub2RlXG4gKiBAcmV0dXJucyBBc3NldCBwcm9taXNlc1xuICovXG5jb25zdCBmZXRjaEFzc2V0cyA9IChmb250U3RvcmUsIG5vZGUpID0+IHtcbiAgICBjb25zdCBwcm9taXNlcyA9IFtdO1xuICAgIGNvbnN0IGxpc3RUb0V4cGxvcmUgPSBub2RlLmNoaWxkcmVuPy5zbGljZSgwKSB8fCBbXTtcbiAgICBjb25zdCBlbW9qaVNvdXJjZSA9IGZvbnRTdG9yZSA/IGZvbnRTdG9yZS5nZXRFbW9qaVNvdXJjZSgpIDogbnVsbDtcbiAgICB3aGlsZSAobGlzdFRvRXhwbG9yZS5sZW5ndGggPiAwKSB7XG4gICAgICAgIGNvbnN0IG4gPSBsaXN0VG9FeHBsb3JlLnNoaWZ0KCk7XG4gICAgICAgIGlmIChpc0ltYWdlJDIobikpIHtcbiAgICAgICAgICAgIHByb21pc2VzLnB1c2goZmV0Y2hJbWFnZShuKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZvbnRTdG9yZSAmJiBuLnN0eWxlPy5mb250RmFtaWx5KSB7XG4gICAgICAgICAgICBjb25zdCBmb250RmFtaWxpZXMgPSBjYXN0QXJyYXkobi5zdHlsZS5mb250RmFtaWx5KTtcbiAgICAgICAgICAgIHByb21pc2VzLnB1c2goLi4uZm9udEZhbWlsaWVzLm1hcCgoZm9udEZhbWlseSkgPT4gZm9udFN0b3JlLmxvYWQoe1xuICAgICAgICAgICAgICAgIGZvbnRGYW1pbHksXG4gICAgICAgICAgICAgICAgZm9udFN0eWxlOiBuLnN0eWxlLmZvbnRTdHlsZSxcbiAgICAgICAgICAgICAgICBmb250V2VpZ2h0OiBuLnN0eWxlLmZvbnRXZWlnaHQsXG4gICAgICAgICAgICB9KSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHByb21pc2VzLnB1c2goLi4uZmV0Y2hFbW9qaXMobiwgZW1vamlTb3VyY2UpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoJ3ZhbHVlJyBpbiBuICYmIHR5cGVvZiBuLnZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcHJvbWlzZXMucHVzaCguLi5mZXRjaEVtb2ppcyhuLnZhbHVlLCBlbW9qaVNvdXJjZSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuLmNoaWxkcmVuKSB7XG4gICAgICAgICAgICBuLmNoaWxkcmVuLmZvckVhY2goKGNoaWxkTm9kZSkgPT4ge1xuICAgICAgICAgICAgICAgIGxpc3RUb0V4cGxvcmUucHVzaChjaGlsZE5vZGUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHByb21pc2VzO1xufTtcbi8qKlxuICogRmV0Y2ggaW1hZ2UsIGZvbnQgYW5kIGVtb2ppIGFzc2V0cyBpbiBwYXJhbGxlbC5cbiAqIExheW91dCBwcm9jZXNzIHdpbGwgbm90IGJlIHJlc3VtZWQgdW50aWwgcHJvbWlzZSByZXNvbHZlcy5cbiAqXG4gKiBAcGFyYW0gbm9kZSByb290IG5vZGVcbiAqIEBwYXJhbSBmb250U3RvcmUgZm9udCBzdG9yZVxuICogQHJldHVybnMgUm9vdCBub2RlXG4gKi9cbmNvbnN0IHJlc29sdmVBc3NldHMgPSBhc3luYyAobm9kZSwgZm9udFN0b3JlKSA9PiB7XG4gICAgY29uc3QgcHJvbWlzZXMgPSBmZXRjaEFzc2V0cyhmb250U3RvcmUsIG5vZGUpO1xuICAgIGF3YWl0IFByb21pc2UuYWxsKHByb21pc2VzKTtcbiAgICByZXR1cm4gbm9kZTtcbn07XG5cbmNvbnN0IGlzTGluayQxID0gKG5vZGUpID0+IG5vZGUudHlwZSA9PT0gUC5MaW5rO1xuY29uc3QgREVGQVVMVF9MSU5LX1NUWUxFUyA9IHtcbiAgICBjb2xvcjogJ2JsdWUnLFxuICAgIHRleHREZWNvcmF0aW9uOiAndW5kZXJsaW5lJyxcbn07XG4vKipcbiAqIENvbXB1dGVzIHN0eWxlcyB1c2luZyBzdHlsZXNoZWV0XG4gKlxuICogQHBhcmFtIGNvbnRhaW5lclxuICogQHBhcmFtIG5vZGUgLSBEb2N1bWVudCBub2RlXG4gKiBAcmV0dXJucyBDb21wdXRlZCBzdHlsZXNcbiAqL1xuY29uc3QgY29tcHV0ZVN0eWxlID0gKGNvbnRhaW5lciwgbm9kZSkgPT4ge1xuICAgIGxldCBiYXNlU3R5bGUgPSBbbm9kZS5zdHlsZV07XG4gICAgaWYgKGlzTGluayQxKG5vZGUpKSB7XG4gICAgICAgIGJhc2VTdHlsZSA9IEFycmF5LmlzQXJyYXkobm9kZS5zdHlsZSlcbiAgICAgICAgICAgID8gW0RFRkFVTFRfTElOS19TVFlMRVMsIC4uLm5vZGUuc3R5bGVdXG4gICAgICAgICAgICA6IFtERUZBVUxUX0xJTktfU1RZTEVTLCBub2RlLnN0eWxlXTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc29sdmVTdHlsZShjb250YWluZXIsIGJhc2VTdHlsZSk7XG59O1xuLyoqXG4gKiBSZXNvbHZlcyBub2RlIHN0eWxlc1xuICpcbiAqIEBwYXJhbSBjb250YWluZXJcbiAqIEByZXR1cm5zIFJlc29sdmUgbm9kZSBzdHlsZXNcbiAqL1xuY29uc3QgcmVzb2x2ZU5vZGVTdHlsZXMgPSAoY29udGFpbmVyKSA9PiAobm9kZSkgPT4ge1xuICAgIGNvbnN0IHN0eWxlID0gY29tcHV0ZVN0eWxlKGNvbnRhaW5lciwgbm9kZSk7XG4gICAgaWYgKCFub2RlLmNoaWxkcmVuKVxuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgbm9kZSwgeyBzdHlsZSB9KTtcbiAgICBjb25zdCBjaGlsZHJlbiA9IG5vZGUuY2hpbGRyZW4ubWFwKHJlc29sdmVOb2RlU3R5bGVzKGNvbnRhaW5lcikpO1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBub2RlLCB7IHN0eWxlLCBjaGlsZHJlbiB9KTtcbn07XG4vKipcbiAqIFJlc29sdmVzIHBhZ2Ugc3R5bGVzXG4gKlxuICogQHBhcmFtIHBhZ2UgRG9jdW1lbnQgcGFnZVxuICogQHJldHVybnMgRG9jdW1lbnQgcGFnZSB3aXRoIHJlc29sdmVkIHN0eWxlc1xuICovXG5jb25zdCByZXNvbHZlUGFnZVN0eWxlcyA9IChwYWdlKSA9PiB7XG4gICAgY29uc3QgZHBpID0gcGFnZS5wcm9wcz8uZHBpIHx8IDcyO1xuICAgIGNvbnN0IHN0eWxlID0gcGFnZS5zdHlsZTtcbiAgICBjb25zdCB3aWR0aCA9IHBhZ2UuYm94Py53aWR0aCB8fCBzdHlsZS53aWR0aDtcbiAgICBjb25zdCBoZWlnaHQgPSBwYWdlLmJveD8uaGVpZ2h0IHx8IHN0eWxlLmhlaWdodDtcbiAgICBjb25zdCBvcmllbnRhdGlvbiA9IHBhZ2UucHJvcHM/Lm9yaWVudGF0aW9uIHx8ICdwb3J0cmFpdCc7XG4gICAgY29uc3QgcmVtQmFzZSA9IHN0eWxlPy5mb250U2l6ZSB8fCAxODtcbiAgICBjb25zdCBjb250YWluZXIgPSB7IHdpZHRoLCBoZWlnaHQsIG9yaWVudGF0aW9uLCBkcGksIHJlbUJhc2UgfTtcbiAgICByZXR1cm4gcmVzb2x2ZU5vZGVTdHlsZXMoY29udGFpbmVyKShwYWdlKTtcbn07XG4vKipcbiAqIFJlc29sdmVzIGRvY3VtZW50IHN0eWxlc1xuICpcbiAqIEBwYXJhbSByb290IC0gRG9jdW1lbnQgcm9vdFxuICogQHJldHVybnMgRG9jdW1lbnQgcm9vdCB3aXRoIHJlc29sdmVkIHN0eWxlc1xuICovXG5jb25zdCByZXNvbHZlU3R5bGVzID0gKHJvb3QpID0+IHtcbiAgICBpZiAoIXJvb3QuY2hpbGRyZW4pXG4gICAgICAgIHJldHVybiByb290O1xuICAgIGNvbnN0IGNoaWxkcmVuID0gcm9vdC5jaGlsZHJlbi5tYXAocmVzb2x2ZVBhZ2VTdHlsZXMpO1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCByb290LCB7IGNoaWxkcmVuIH0pO1xufTtcblxuY29uc3QgZ2V0VHJhbnNmb3JtU3R5bGUgPSAocykgPT4gKG5vZGUpID0+IGlzTmlsKG5vZGUuc3R5bGU/LltzXSkgPyAnNTAlJyA6IG5vZGUuc3R5bGU/LltzXSA/PyBudWxsO1xuLyoqXG4gKiBHZXQgbm9kZSBvcmlnaW5cbiAqXG4gKiBAcGFyYW0gbm9kZVxuICogQHJldHVybnMge3sgbGVmdD86IG51bWJlciwgdG9wPzogbnVtYmVyIH19IG5vZGUgb3JpZ2luXG4gKi9cbmNvbnN0IGdldE9yaWdpbiA9IChub2RlKSA9PiB7XG4gICAgaWYgKCFub2RlLmJveClcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgY29uc3QgeyBsZWZ0LCB0b3AsIHdpZHRoLCBoZWlnaHQgfSA9IG5vZGUuYm94O1xuICAgIGNvbnN0IHRyYW5zZm9ybU9yaWdpblggPSBnZXRUcmFuc2Zvcm1TdHlsZSgndHJhbnNmb3JtT3JpZ2luWCcpKG5vZGUpO1xuICAgIGNvbnN0IHRyYW5zZm9ybU9yaWdpblkgPSBnZXRUcmFuc2Zvcm1TdHlsZSgndHJhbnNmb3JtT3JpZ2luWScpKG5vZGUpO1xuICAgIGNvbnN0IHBlcmNlbnRYID0gbWF0Y2hQZXJjZW50KHRyYW5zZm9ybU9yaWdpblgpO1xuICAgIGNvbnN0IHBlcmNlbnRZID0gbWF0Y2hQZXJjZW50KHRyYW5zZm9ybU9yaWdpblkpO1xuICAgIGNvbnN0IG9mZnNldFggPSBwZXJjZW50WCA/IHdpZHRoICogcGVyY2VudFgucGVyY2VudCA6IHRyYW5zZm9ybU9yaWdpblg7XG4gICAgY29uc3Qgb2Zmc2V0WSA9IHBlcmNlbnRZID8gaGVpZ2h0ICogcGVyY2VudFkucGVyY2VudCA6IHRyYW5zZm9ybU9yaWdpblk7XG4gICAgaWYgKGlzTmlsKG9mZnNldFgpIHx8IHR5cGVvZiBvZmZzZXRYID09PSAnc3RyaW5nJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIG9yaWdpbiBvZmZzZXRYOiAke29mZnNldFh9YCk7XG4gICAgaWYgKGlzTmlsKG9mZnNldFkpIHx8IHR5cGVvZiBvZmZzZXRZID09PSAnc3RyaW5nJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIG9yaWdpbiBvZmZzZXRZOiAke29mZnNldFl9YCk7XG4gICAgcmV0dXJuIHsgbGVmdDogbGVmdCArIG9mZnNldFgsIHRvcDogdG9wICsgb2Zmc2V0WSB9O1xufTtcblxuLyoqXG4gKiBSZXNvbHZlIG5vZGUgb3JpZ2luXG4gKlxuICogQHBhcmFtIG5vZGVcbiAqIEByZXR1cm5zIE5vZGUgd2l0aCBvcmlnaW4gYXR0cmlidXRlXG4gKi9cbmNvbnN0IHJlc29sdmVOb2RlT3JpZ2luID0gKG5vZGUpID0+IHtcbiAgICBjb25zdCBvcmlnaW4gPSBnZXRPcmlnaW4obm9kZSk7XG4gICAgY29uc3QgbmV3Tm9kZSA9IE9iamVjdC5hc3NpZ24oe30sIG5vZGUsIHsgb3JpZ2luIH0pO1xuICAgIGlmICghbm9kZS5jaGlsZHJlbilcbiAgICAgICAgcmV0dXJuIG5ld05vZGU7XG4gICAgY29uc3QgY2hpbGRyZW4gPSBub2RlLmNoaWxkcmVuLm1hcChyZXNvbHZlTm9kZU9yaWdpbik7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIG5ld05vZGUsIHsgY2hpbGRyZW4gfSk7XG59O1xuLyoqXG4gKiBSZXNvbHZlIGRvY3VtZW50IG9yaWdpbnNcbiAqXG4gKiBAcGFyYW0gcm9vdCAtIERvY3VtZW50IHJvb3RcbiAqIEByZXR1cm5zIERvY3VtZW50IHJvb3RcbiAqL1xuY29uc3QgcmVzb2x2ZU9yaWdpbiA9IChyb290KSA9PiB7XG4gICAgaWYgKCFyb290LmNoaWxkcmVuKVxuICAgICAgICByZXR1cm4gcm9vdDtcbiAgICBjb25zdCBjaGlsZHJlbiA9IHJvb3QuY2hpbGRyZW4ubWFwKHJlc29sdmVOb2RlT3JpZ2luKTtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgcm9vdCwgeyBjaGlsZHJlbiB9KTtcbn07XG5cbmNvbnN0IGdldEJvb2ttYXJrVmFsdWUgPSAoYm9va21hcmspID0+IHtcbiAgICByZXR1cm4gdHlwZW9mIGJvb2ttYXJrID09PSAnc3RyaW5nJ1xuICAgICAgICA/IHsgdGl0bGU6IGJvb2ttYXJrLCBmaXQ6IGZhbHNlLCBleHBhbmRlZDogZmFsc2UgfVxuICAgICAgICA6IGJvb2ttYXJrO1xufTtcbmNvbnN0IHJlc29sdmVCb29rbWFya3MgPSAobm9kZSkgPT4ge1xuICAgIGxldCByZWZzID0gMDtcbiAgICBjb25zdCBjaGlsZHJlbiA9IChub2RlLmNoaWxkcmVuIHx8IFtdKS5zbGljZSgwKTtcbiAgICBjb25zdCBsaXN0VG9FeHBsb3JlID0gY2hpbGRyZW4ubWFwKCh2YWx1ZSkgPT4gKHtcbiAgICAgICAgdmFsdWUsXG4gICAgICAgIHBhcmVudDogbnVsbCxcbiAgICB9KSk7XG4gICAgd2hpbGUgKGxpc3RUb0V4cGxvcmUubGVuZ3RoID4gMCkge1xuICAgICAgICBjb25zdCBlbGVtZW50ID0gbGlzdFRvRXhwbG9yZS5zaGlmdCgpO1xuICAgICAgICBpZiAoIWVsZW1lbnQpXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY29uc3QgY2hpbGQgPSBlbGVtZW50LnZhbHVlO1xuICAgICAgICBsZXQgcGFyZW50ID0gZWxlbWVudC5wYXJlbnQ7XG4gICAgICAgIGlmIChjaGlsZC5wcm9wcyAmJiAnYm9va21hcmsnIGluIGNoaWxkLnByb3BzKSB7XG4gICAgICAgICAgICBjb25zdCBib29rbWFyayA9IGdldEJvb2ttYXJrVmFsdWUoY2hpbGQucHJvcHMuYm9va21hcmspO1xuICAgICAgICAgICAgY29uc3QgcmVmID0gcmVmcysrO1xuICAgICAgICAgICAgY29uc3QgbmV3SGllcmFyY2h5ID0geyByZWYsIHBhcmVudDogcGFyZW50Py5yZWYsIC4uLmJvb2ttYXJrIH07XG4gICAgICAgICAgICBjaGlsZC5wcm9wcy5ib29rbWFyayA9IG5ld0hpZXJhcmNoeTtcbiAgICAgICAgICAgIHBhcmVudCA9IG5ld0hpZXJhcmNoeTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hpbGQuY2hpbGRyZW4pIHtcbiAgICAgICAgICAgIGNoaWxkLmNoaWxkcmVuLmZvckVhY2goKGNoaWxkTm9kZSkgPT4ge1xuICAgICAgICAgICAgICAgIGxpc3RUb0V4cGxvcmUucHVzaCh7IHZhbHVlOiBjaGlsZE5vZGUsIHBhcmVudCB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBub2RlO1xufTtcblxuY29uc3QgVkFMSURfT1JJRU5UQVRJT05TID0gWydwb3J0cmFpdCcsICdsYW5kc2NhcGUnXTtcbi8qKlxuICogR2V0IHBhZ2Ugb3JpZW50YXRpb24uIERlZmF1bHRzIHRvIHBvcnRyYWl0XG4gKlxuICogQHBhcmFtIHBhZ2UgLSBQYWdlIG9iamVjdFxuICogQHJldHVybnMgUGFnZSBvcmllbnRhdGlvblxuICovXG5jb25zdCBnZXRPcmllbnRhdGlvbiA9IChwYWdlKSA9PiB7XG4gICAgY29uc3QgdmFsdWUgPSBwYWdlLnByb3BzPy5vcmllbnRhdGlvbiB8fCAncG9ydHJhaXQnO1xuICAgIHJldHVybiBWQUxJRF9PUklFTlRBVElPTlMuaW5jbHVkZXModmFsdWUpID8gdmFsdWUgOiAncG9ydHJhaXQnO1xufTtcblxuLyoqXG4gKiBSZXR1cm4gdHJ1ZSBpZiBwYWdlIGlzIGxhbmRzY2FwZVxuICpcbiAqIEBwYXJhbSBwYWdlIC0gUGFnZSBpbnN0YW5jZVxuICogQHJldHVybnMgSXMgcGFnZSBsYW5kc2NhcGVcbiAqL1xuY29uc3QgaXNMYW5kc2NhcGUgPSAocGFnZSkgPT4gZ2V0T3JpZW50YXRpb24ocGFnZSkgPT09ICdsYW5kc2NhcGUnO1xuXG4vLyBQYWdlIHNpemVzIGZvciA3MmRwaS4gNzJkcGkgaXMgdXNlZCBpbnRlcm5hbGx5IGJ5IHBkZmtpdC5cbmNvbnN0IFBBR0VfU0laRVMgPSB7XG4gICAgJzRBMCc6IFs0NzY3Ljg3LCA2NzQwLjc5XSxcbiAgICAnMkEwJzogWzMzNzAuMzksIDQ3NjcuODddLFxuICAgIEEwOiBbMjM4My45NCwgMzM3MC4zOV0sXG4gICAgQTE6IFsxNjgzLjc4LCAyMzgzLjk0XSxcbiAgICBBMjogWzExOTAuNTUsIDE2ODMuNzhdLFxuICAgIEEzOiBbODQxLjg5LCAxMTkwLjU1XSxcbiAgICBBNDogWzU5NS4yOCwgODQxLjg5XSxcbiAgICBBNTogWzQxOS41MywgNTk1LjI4XSxcbiAgICBBNjogWzI5Ny42NCwgNDE5LjUzXSxcbiAgICBBNzogWzIwOS43NiwgMjk3LjY0XSxcbiAgICBBODogWzE0Ny40LCAyMDkuNzZdLFxuICAgIEE5OiBbMTA0Ljg4LCAxNDcuNF0sXG4gICAgQTEwOiBbNzMuNywgMTA0Ljg4XSxcbiAgICBCMDogWzI4MzQuNjUsIDQwMDguMTldLFxuICAgIEIxOiBbMjAwNC4wOSwgMjgzNC42NV0sXG4gICAgQjI6IFsxNDE3LjMyLCAyMDA0LjA5XSxcbiAgICBCMzogWzEwMDAuNjMsIDE0MTcuMzJdLFxuICAgIEI0OiBbNzA4LjY2LCAxMDAwLjYzXSxcbiAgICBCNTogWzQ5OC45LCA3MDguNjZdLFxuICAgIEI2OiBbMzU0LjMzLCA0OTguOV0sXG4gICAgQjc6IFsyNDkuNDUsIDM1NC4zM10sXG4gICAgQjg6IFsxNzUuNzUsIDI0OS40NV0sXG4gICAgQjk6IFsxMjQuNzIsIDE3NS43NV0sXG4gICAgQjEwOiBbODcuODcsIDEyNC43Ml0sXG4gICAgQzA6IFsyNTk5LjM3LCAzNjc2LjU0XSxcbiAgICBDMTogWzE4MzYuODUsIDI1OTkuMzddLFxuICAgIEMyOiBbMTI5OC4yNywgMTgzNi44NV0sXG4gICAgQzM6IFs5MTguNDMsIDEyOTguMjddLFxuICAgIEM0OiBbNjQ5LjEzLCA5MTguNDNdLFxuICAgIEM1OiBbNDU5LjIxLCA2NDkuMTNdLFxuICAgIEM2OiBbMzIzLjE1LCA0NTkuMjFdLFxuICAgIEM3OiBbMjI5LjYxLCAzMjMuMTVdLFxuICAgIEM4OiBbMTYxLjU3LCAyMjkuNjFdLFxuICAgIEM5OiBbMTEzLjM5LCAxNjEuNTddLFxuICAgIEMxMDogWzc5LjM3LCAxMTMuMzldLFxuICAgIFJBMDogWzI0MzcuOCwgMzQ1OC4yN10sXG4gICAgUkExOiBbMTcyOS4xMywgMjQzNy44XSxcbiAgICBSQTI6IFsxMjE4LjksIDE3MjkuMTNdLFxuICAgIFJBMzogWzg2NC41NywgMTIxOC45XSxcbiAgICBSQTQ6IFs2MDkuNDUsIDg2NC41N10sXG4gICAgU1JBMDogWzI1NTEuMTgsIDM2MjguMzVdLFxuICAgIFNSQTE6IFsxODE0LjE3LCAyNTUxLjE4XSxcbiAgICBTUkEyOiBbMTI3NS41OSwgMTgxNC4xN10sXG4gICAgU1JBMzogWzkwNy4wOSwgMTI3NS41OV0sXG4gICAgU1JBNDogWzYzNy44LCA5MDcuMDldLFxuICAgIEVYRUNVVElWRTogWzUyMS44NiwgNzU2LjBdLFxuICAgIEZPTElPOiBbNjEyLjAsIDkzNi4wXSxcbiAgICBMRUdBTDogWzYxMi4wLCAxMDA4LjBdLFxuICAgIExFVFRFUjogWzYxMi4wLCA3OTIuMF0sXG4gICAgVEFCTE9JRDogWzc5Mi4wLCAxMjI0LjBdLFxuICAgIElEMTogWzE1MywgMjQzXSxcbn07XG4vKipcbiAqIFBhcnNlcyBzY2FsYXIgdmFsdWUgaW4gdmFsdWUgYW5kIHVuaXQgcGFpcnNcbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBTY2FsYXIgdmFsdWVcbiAqIEByZXR1cm5zIFBhcnNlZCB2YWx1ZVxuICovXG5jb25zdCBwYXJzZVZhbHVlID0gKHZhbHVlKSA9PiB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpXG4gICAgICAgIHJldHVybiB7IHZhbHVlLCB1bml0OiB1bmRlZmluZWQgfTtcbiAgICBjb25zdCBtYXRjaCA9IC9eKC0/XFxkKlxcLj9cXGQrKShpbnxtbXxjbXxwdHxweCk/JC9nLmV4ZWModmFsdWUpO1xuICAgIHJldHVybiBtYXRjaFxuICAgICAgICA/IHsgdmFsdWU6IHBhcnNlRmxvYXQobWF0Y2hbMV0pLCB1bml0OiBtYXRjaFsyXSB8fCAncHQnIH1cbiAgICAgICAgOiB7IHZhbHVlLCB1bml0OiB1bmRlZmluZWQgfTtcbn07XG4vKipcbiAqIFRyYW5zZm9ybSBnaXZlbiBzY2FsYXIgdmFsdWUgdG8gNzJkcGkgZXF1aXZhbGVudCBvZiBzaXplXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gU3R5bGVzIHZhbHVlXG4gKiBAcGFyYW0gaW5wdXREcGkgLSBVc2VyIGRlZmluZWQgZHBpXG4gKiBAcmV0dXJucyBUcmFuc2Zvcm1lZCB2YWx1ZVxuICovXG5jb25zdCB0cmFuc2Zvcm1Vbml0ID0gKHZhbHVlLCBpbnB1dERwaSkgPT4ge1xuICAgIGlmICghdmFsdWUpXG4gICAgICAgIHJldHVybiAwO1xuICAgIGNvbnN0IHNjYWxhciA9IHBhcnNlVmFsdWUodmFsdWUpO1xuICAgIGNvbnN0IG91dHB1dERwaSA9IDcyO1xuICAgIGNvbnN0IG1tRmFjdG9yID0gKDEgLyAyNS40KSAqIG91dHB1dERwaTtcbiAgICBjb25zdCBjbUZhY3RvciA9ICgxIC8gMi41NCkgKiBvdXRwdXREcGk7XG4gICAgaWYgKHR5cGVvZiBzY2FsYXIudmFsdWUgPT09ICdzdHJpbmcnKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgcGFnZSBzaXplOiAke3ZhbHVlfWApO1xuICAgIHN3aXRjaCAoc2NhbGFyLnVuaXQpIHtcbiAgICAgICAgY2FzZSAnaW4nOlxuICAgICAgICAgICAgcmV0dXJuIHNjYWxhci52YWx1ZSAqIG91dHB1dERwaTtcbiAgICAgICAgY2FzZSAnbW0nOlxuICAgICAgICAgICAgcmV0dXJuIHNjYWxhci52YWx1ZSAqIG1tRmFjdG9yO1xuICAgICAgICBjYXNlICdjbSc6XG4gICAgICAgICAgICByZXR1cm4gc2NhbGFyLnZhbHVlICogY21GYWN0b3I7XG4gICAgICAgIGNhc2UgJ3B4JzpcbiAgICAgICAgICAgIHJldHVybiBNYXRoLnJvdW5kKHNjYWxhci52YWx1ZSAqIChvdXRwdXREcGkgLyBpbnB1dERwaSkpO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIHNjYWxhci52YWx1ZTtcbiAgICB9XG59O1xuY29uc3QgdHJhbnNmb3JtVW5pdHMgPSAoeyB3aWR0aCwgaGVpZ2h0IH0sIGRwaSkgPT4gKHtcbiAgICB3aWR0aDogdHJhbnNmb3JtVW5pdCh3aWR0aCwgZHBpKSxcbiAgICBoZWlnaHQ6IHRyYW5zZm9ybVVuaXQoaGVpZ2h0LCBkcGkpLFxufSk7XG4vKipcbiAqIFRyYW5zZm9ybXMgYXJyYXkgaW50byBzaXplIG9iamVjdFxuICpcbiAqIEBwYXJhbSB2IC0gVmFsdWVzIGFycmF5XG4gKiBAcmV0dXJucyBTaXplIG9iamVjdCB3aXRoIHdpZHRoIGFuZCBoZWlnaHRcbiAqL1xuY29uc3QgdG9TaXplT2JqZWN0ID0gKHYpID0+ICh7XG4gICAgd2lkdGg6IHZbMF0sXG4gICAgaGVpZ2h0OiB2WzFdLFxufSk7XG4vKipcbiAqIEZsaXAgc2l6ZSBvYmplY3RcbiAqXG4gKiBAcGFyYW0gdiAtIFNpemUgb2JqZWN0XG4gKiBAcmV0dXJucyBGbGlwcGVkIHNpemUgb2JqZWN0XG4gKi9cbmNvbnN0IGZsaXBTaXplT2JqZWN0ID0gKHYpID0+ICh7XG4gICAgd2lkdGg6IHYuaGVpZ2h0LFxuICAgIGhlaWdodDogdi53aWR0aCxcbn0pO1xuLyoqXG4gKiBSZXR1cm5zIHNpemUgb2JqZWN0IGZyb20gYSBnaXZlbiBzdHJpbmdcbiAqXG4gKiBAcGFyYW0gdiAtIFBhZ2Ugc2l6ZSBzdHJpbmdcbiAqIEByZXR1cm5zIFNpemUgb2JqZWN0IHdpdGggd2lkdGggYW5kIGhlaWdodFxuICovXG5jb25zdCBnZXRTdHJpbmdTaXplID0gKHYpID0+IHtcbiAgICByZXR1cm4gdG9TaXplT2JqZWN0KFBBR0VfU0laRVNbdi50b1VwcGVyQ2FzZSgpXSk7XG59O1xuLyoqXG4gKiBSZXR1cm5zIHNpemUgb2JqZWN0IGZyb20gYSBzaW5nbGUgbnVtYmVyXG4gKlxuICogQHBhcmFtIG4gLSBQYWdlIHNpemUgbnVtYmVyXG4gKiBAcmV0dXJucyBTaXplIG9iamVjdCB3aXRoIHdpZHRoIGFuZCBoZWlnaHRcbiAqL1xuY29uc3QgZ2V0TnVtYmVyU2l6ZSA9IChuKSA9PiB0b1NpemVPYmplY3QoW24sIG5dKTtcbi8qKlxuICogUmV0dXJuIHBhZ2Ugc2l6ZSBpbiBhbiBvYmplY3QgeyB3aWR0aCwgaGVpZ2h0IH1cbiAqXG4gKiBAcGFyYW0gcGFnZSAtIFBhZ2Ugbm9kZVxuICogQHJldHVybnMgU2l6ZSBvYmplY3Qgd2l0aCB3aWR0aCBhbmQgaGVpZ2h0XG4gKi9cbmNvbnN0IGdldFNpemUgPSAocGFnZSkgPT4ge1xuICAgIGNvbnN0IHZhbHVlID0gcGFnZS5wcm9wcz8uc2l6ZSB8fCAnQTQnO1xuICAgIGNvbnN0IGRwaSA9IHBhZ2UucHJvcHM/LmRwaSB8fCA3MjtcbiAgICBsZXQgc2l6ZTtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICBzaXplID0gZ2V0U3RyaW5nU2l6ZSh2YWx1ZSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIHNpemUgPSB0cmFuc2Zvcm1Vbml0cyh0b1NpemVPYmplY3QodmFsdWUpLCBkcGkpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgICAgIHNpemUgPSB0cmFuc2Zvcm1Vbml0cyhnZXROdW1iZXJTaXplKHZhbHVlKSwgZHBpKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHNpemUgPSB0cmFuc2Zvcm1Vbml0cyh2YWx1ZSwgZHBpKTtcbiAgICB9XG4gICAgcmV0dXJuIGlzTGFuZHNjYXBlKHBhZ2UpID8gZmxpcFNpemVPYmplY3Qoc2l6ZSkgOiBzaXplO1xufTtcblxuLyoqXG4gKiBSZXNvbHZlcyBwYWdlIHNpemVcbiAqXG4gKiBAcGFyYW0gcGFnZVxuICogQHJldHVybnMgUGFnZSB3aXRoIHJlc29sdmVkIHNpemUgaW4gc3R5bGUgYXR0cmlidXRlXG4gKi9cbmNvbnN0IHJlc29sdmVQYWdlU2l6ZSA9IChwYWdlKSA9PiB7XG4gICAgY29uc3Qgc2l6ZSA9IGdldFNpemUocGFnZSk7XG4gICAgY29uc3Qgc3R5bGUgPSBmbGF0dGVuKHBhZ2Uuc3R5bGUgfHwge30pO1xuICAgIHJldHVybiB7IC4uLnBhZ2UsIHN0eWxlOiB7IC4uLnN0eWxlLCAuLi5zaXplIH0gfTtcbn07XG4vKipcbiAqIFJlc29sdmVzIHBhZ2Ugc2l6ZXNcbiAqXG4gKiBAcGFyYW0gcm9vdCAgLURvY3VtZW50IHJvb3RcbiAqIEByZXR1cm5zIERvY3VtZW50IHJvb3Qgd2l0aCByZXNvbHZlZCBwYWdlIHNpemVzXG4gKi9cbmNvbnN0IHJlc29sdmVQYWdlU2l6ZXMgPSAocm9vdCkgPT4ge1xuICAgIGlmICghcm9vdC5jaGlsZHJlbilcbiAgICAgICAgcmV0dXJuIHJvb3Q7XG4gICAgY29uc3QgY2hpbGRyZW4gPSByb290LmNoaWxkcmVuLm1hcChyZXNvbHZlUGFnZVNpemUpO1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCByb290LCB7IGNoaWxkcmVuIH0pO1xufTtcblxuY29uc3QgaXNGaXhlZCA9IChub2RlKSA9PiB7XG4gICAgaWYgKCFub2RlLnByb3BzKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuICdmaXhlZCcgaW4gbm9kZS5wcm9wcyA/IG5vZGUucHJvcHMuZml4ZWQgPT09IHRydWUgOiBmYWxzZTtcbn07XG5cbi8qKlxuICogR2V0IGxpbmUgaW5kZXggYXQgZ2l2ZW4gaGVpZ2h0XG4gKlxuICogQHBhcmFtIG5vZGVcbiAqIEBwYXJhbSBoZWlnaHRcbiAqL1xuY29uc3QgbGluZUluZGV4QXRIZWlnaHQgPSAobm9kZSwgaGVpZ2h0KSA9PiB7XG4gICAgbGV0IHkgPSAwO1xuICAgIGlmICghbm9kZS5saW5lcylcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2RlLmxpbmVzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGNvbnN0IGxpbmUgPSBub2RlLmxpbmVzW2ldO1xuICAgICAgICBpZiAoeSArIGxpbmUuYm94LmhlaWdodCA+IGhlaWdodClcbiAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICB5ICs9IGxpbmUuYm94LmhlaWdodDtcbiAgICB9XG4gICAgcmV0dXJuIG5vZGUubGluZXMubGVuZ3RoO1xufTtcblxuLyoqXG4gKiBHZXQgaGVpZ2h0IGZvciBnaXZlbiB0ZXh0IGxpbmUgaW5kZXhcbiAqXG4gKiBAcGFyYW0gbm9kZVxuICogQHBhcmFtIGluZGV4XG4gKi9cbmNvbnN0IGhlaWdodEF0TGluZUluZGV4ID0gKG5vZGUsIGluZGV4KSA9PiB7XG4gICAgbGV0IGNvdW50ZXIgPSAwO1xuICAgIGlmICghbm9kZS5saW5lcylcbiAgICAgICAgcmV0dXJuIGNvdW50ZXI7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbmRleDsgaSArPSAxKSB7XG4gICAgICAgIGNvbnN0IGxpbmUgPSBub2RlLmxpbmVzW2ldO1xuICAgICAgICBpZiAoIWxpbmUpXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY291bnRlciArPSBsaW5lLmJveC5oZWlnaHQ7XG4gICAgfVxuICAgIHJldHVybiBjb3VudGVyO1xufTtcblxuY29uc3QgZ2V0TGluZUJyZWFrID0gKG5vZGUsIGhlaWdodCkgPT4ge1xuICAgIGNvbnN0IHRvcCA9IG5vZGUuYm94Py50b3AgfHwgMDtcbiAgICBjb25zdCB3aWRvd3MgPSBub2RlLnByb3BzLndpZG93cyB8fCAyO1xuICAgIGNvbnN0IG9ycGhhbnMgPSBub2RlLnByb3BzLm9ycGhhbnMgfHwgMjtcbiAgICBjb25zdCBsaW5lc1F1YW50aXR5ID0gbm9kZS5saW5lcy5sZW5ndGg7XG4gICAgY29uc3Qgc2xpY2VkTGluZSA9IGxpbmVJbmRleEF0SGVpZ2h0KG5vZGUsIGhlaWdodCAtIHRvcCk7XG4gICAgaWYgKHNsaWNlZExpbmUgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIGlmIChsaW5lc1F1YW50aXR5IDwgb3JwaGFucykge1xuICAgICAgICByZXR1cm4gbGluZXNRdWFudGl0eTtcbiAgICB9XG4gICAgaWYgKHNsaWNlZExpbmUgPCBvcnBoYW5zIHx8IGxpbmVzUXVhbnRpdHkgPCBvcnBoYW5zICsgd2lkb3dzKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICBpZiAobGluZXNRdWFudGl0eSA9PT0gb3JwaGFucyArIHdpZG93cykge1xuICAgICAgICByZXR1cm4gb3JwaGFucztcbiAgICB9XG4gICAgaWYgKGxpbmVzUXVhbnRpdHkgLSBzbGljZWRMaW5lIDwgd2lkb3dzKSB7XG4gICAgICAgIHJldHVybiBsaW5lc1F1YW50aXR5IC0gd2lkb3dzO1xuICAgIH1cbiAgICByZXR1cm4gc2xpY2VkTGluZTtcbn07XG4vLyBBbHNvIHJlY2VpdmVzIGNvbnRlbnRBcmVhIGluIGNhc2UgaXQncyBuZWVkZWRcbmNvbnN0IHNwbGl0VGV4dCA9IChub2RlLCBoZWlnaHQpID0+IHtcbiAgICBjb25zdCBzbGljZWRMaW5lSW5kZXggPSBnZXRMaW5lQnJlYWsobm9kZSwgaGVpZ2h0KTtcbiAgICBjb25zdCBjdXJyZW50SGVpZ2h0ID0gaGVpZ2h0QXRMaW5lSW5kZXgobm9kZSwgc2xpY2VkTGluZUluZGV4KTtcbiAgICBjb25zdCBuZXh0SGVpZ2h0ID0gbm9kZS5ib3guaGVpZ2h0IC0gY3VycmVudEhlaWdodDtcbiAgICBjb25zdCBjdXJyZW50ID0gT2JqZWN0LmFzc2lnbih7fSwgbm9kZSwge1xuICAgICAgICBib3g6IHtcbiAgICAgICAgICAgIC4uLm5vZGUuYm94LFxuICAgICAgICAgICAgaGVpZ2h0OiBjdXJyZW50SGVpZ2h0LFxuICAgICAgICAgICAgYm9yZGVyQm90dG9tV2lkdGg6IDAsXG4gICAgICAgIH0sXG4gICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICAuLi5ub2RlLnN0eWxlLFxuICAgICAgICAgICAgbWFyZ2luQm90dG9tOiAwLFxuICAgICAgICAgICAgcGFkZGluZ0JvdHRvbTogMCxcbiAgICAgICAgICAgIGJvcmRlckJvdHRvbVdpZHRoOiAwLFxuICAgICAgICAgICAgYm9yZGVyQm90dG9tTGVmdFJhZGl1czogMCxcbiAgICAgICAgICAgIGJvcmRlckJvdHRvbVJpZ2h0UmFkaXVzOiAwLFxuICAgICAgICB9LFxuICAgICAgICBsaW5lczogbm9kZS5saW5lcy5zbGljZSgwLCBzbGljZWRMaW5lSW5kZXgpLFxuICAgIH0pO1xuICAgIGNvbnN0IG5leHQgPSBPYmplY3QuYXNzaWduKHt9LCBub2RlLCB7XG4gICAgICAgIGJveDoge1xuICAgICAgICAgICAgLi4ubm9kZS5ib3gsXG4gICAgICAgICAgICB0b3A6IDAsXG4gICAgICAgICAgICBoZWlnaHQ6IG5leHRIZWlnaHQsXG4gICAgICAgICAgICBib3JkZXJUb3BXaWR0aDogMCxcbiAgICAgICAgfSxcbiAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgIC4uLm5vZGUuc3R5bGUsXG4gICAgICAgICAgICBtYXJnaW5Ub3A6IDAsXG4gICAgICAgICAgICBwYWRkaW5nVG9wOiAwLFxuICAgICAgICAgICAgYm9yZGVyVG9wV2lkdGg6IDAsXG4gICAgICAgICAgICBib3JkZXJUb3BMZWZ0UmFkaXVzOiAwLFxuICAgICAgICAgICAgYm9yZGVyVG9wUmlnaHRSYWRpdXM6IDAsXG4gICAgICAgIH0sXG4gICAgICAgIGxpbmVzOiBub2RlLmxpbmVzLnNsaWNlKHNsaWNlZExpbmVJbmRleCksXG4gICAgfSk7XG4gICAgcmV0dXJuIFtjdXJyZW50LCBuZXh0XTtcbn07XG5cbmNvbnN0IGdldFRvcCQxID0gKG5vZGUpID0+IG5vZGUuYm94Py50b3AgfHwgMDtcbmNvbnN0IGhhc0ZpeGVkSGVpZ2h0ID0gKG5vZGUpID0+ICFpc05pbChub2RlLnN0eWxlPy5oZWlnaHQpO1xuY29uc3Qgc3BsaXROb2RlID0gKG5vZGUsIGhlaWdodCkgPT4ge1xuICAgIGlmICghbm9kZSlcbiAgICAgICAgcmV0dXJuIFtudWxsLCBudWxsXTtcbiAgICBjb25zdCBub2RlVG9wID0gZ2V0VG9wJDEobm9kZSk7XG4gICAgY29uc3QgY3VycmVudCA9IE9iamVjdC5hc3NpZ24oe30sIG5vZGUsIHtcbiAgICAgICAgYm94OiB7XG4gICAgICAgICAgICAuLi5ub2RlLmJveCxcbiAgICAgICAgICAgIGJvcmRlckJvdHRvbVdpZHRoOiAwLFxuICAgICAgICB9LFxuICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgLi4ubm9kZS5zdHlsZSxcbiAgICAgICAgICAgIG1hcmdpbkJvdHRvbTogMCxcbiAgICAgICAgICAgIHBhZGRpbmdCb3R0b206IDAsXG4gICAgICAgICAgICBib3JkZXJCb3R0b21XaWR0aDogMCxcbiAgICAgICAgICAgIGJvcmRlckJvdHRvbUxlZnRSYWRpdXM6IDAsXG4gICAgICAgICAgICBib3JkZXJCb3R0b21SaWdodFJhZGl1czogMCxcbiAgICAgICAgfSxcbiAgICB9KTtcbiAgICBjdXJyZW50LnN0eWxlLmhlaWdodCA9IGhlaWdodCAtIG5vZGVUb3A7XG4gICAgY29uc3QgbmV4dEhlaWdodCA9IGhhc0ZpeGVkSGVpZ2h0KG5vZGUpXG4gICAgICAgID8gbm9kZS5ib3guaGVpZ2h0IC0gKGhlaWdodCAtIG5vZGVUb3ApXG4gICAgICAgIDogbnVsbDtcbiAgICBjb25zdCBuZXh0ID0gT2JqZWN0LmFzc2lnbih7fSwgbm9kZSwge1xuICAgICAgICBib3g6IHtcbiAgICAgICAgICAgIC4uLm5vZGUuYm94LFxuICAgICAgICAgICAgdG9wOiAwLFxuICAgICAgICAgICAgYm9yZGVyVG9wV2lkdGg6IDAsXG4gICAgICAgIH0sXG4gICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICAuLi5ub2RlLnN0eWxlLFxuICAgICAgICAgICAgbWFyZ2luVG9wOiAwLFxuICAgICAgICAgICAgcGFkZGluZ1RvcDogMCxcbiAgICAgICAgICAgIGJvcmRlclRvcFdpZHRoOiAwLFxuICAgICAgICAgICAgYm9yZGVyVG9wTGVmdFJhZGl1czogMCxcbiAgICAgICAgICAgIGJvcmRlclRvcFJpZ2h0UmFkaXVzOiAwLFxuICAgICAgICB9LFxuICAgIH0pO1xuICAgIGlmIChuZXh0SGVpZ2h0KSB7XG4gICAgICAgIG5leHQuc3R5bGUuaGVpZ2h0ID0gbmV4dEhlaWdodDtcbiAgICB9XG4gICAgcmV0dXJuIFtjdXJyZW50LCBuZXh0XTtcbn07XG5cbmNvbnN0IE5PTl9XUkFQX1RZUEVTID0gW1AuU3ZnLCBQLk5vdGUsIFAuSW1hZ2UsIFAuQ2FudmFzXTtcbmNvbnN0IGdldFdyYXAgPSAobm9kZSkgPT4ge1xuICAgIGlmIChOT05fV1JBUF9UWVBFUy5pbmNsdWRlcyhub2RlLnR5cGUpKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgaWYgKCFub2RlLnByb3BzKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICByZXR1cm4gJ3dyYXAnIGluIG5vZGUucHJvcHMgPyBub2RlLnByb3BzLndyYXAgOiB0cnVlO1xufTtcblxuY29uc3QgZ2V0Q29tcHV0ZWRQYWRkaW5nID0gKG5vZGUsIGVkZ2UpID0+IHtcbiAgICBjb25zdCB7IHlvZ2FOb2RlIH0gPSBub2RlO1xuICAgIHJldHVybiB5b2dhTm9kZSA/IHlvZ2FOb2RlLmdldENvbXB1dGVkUGFkZGluZyhlZGdlKSA6IG51bGw7XG59O1xuLyoqXG4gKiBHZXQgWW9nYSBjb21wdXRlZCBwYWRkaW5ncy4gWmVybyBvdGhlcndpc2VcbiAqXG4gKiBAcGFyYW0gIG5vZGVcbiAqIEByZXR1cm5zIHBhZGRpbmdzXG4gKi9cbmNvbnN0IGdldFBhZGRpbmcgPSAobm9kZSkgPT4ge1xuICAgIGNvbnN0IHsgc3R5bGUsIGJveCB9ID0gbm9kZTtcbiAgICBjb25zdCBwYWRkaW5nVG9wID0gZ2V0Q29tcHV0ZWRQYWRkaW5nKG5vZGUsIFlvZ2EuRWRnZS5Ub3ApIHx8XG4gICAgICAgIGJveD8ucGFkZGluZ1RvcCB8fFxuICAgICAgICBzdHlsZT8ucGFkZGluZ1RvcCB8fFxuICAgICAgICAwO1xuICAgIGNvbnN0IHBhZGRpbmdSaWdodCA9IGdldENvbXB1dGVkUGFkZGluZyhub2RlLCBZb2dhLkVkZ2UuUmlnaHQpIHx8XG4gICAgICAgIGJveD8ucGFkZGluZ1JpZ2h0IHx8XG4gICAgICAgIHN0eWxlPy5wYWRkaW5nUmlnaHQgfHxcbiAgICAgICAgMDtcbiAgICBjb25zdCBwYWRkaW5nQm90dG9tID0gZ2V0Q29tcHV0ZWRQYWRkaW5nKG5vZGUsIFlvZ2EuRWRnZS5Cb3R0b20pIHx8XG4gICAgICAgIGJveD8ucGFkZGluZ0JvdHRvbSB8fFxuICAgICAgICBzdHlsZT8ucGFkZGluZ0JvdHRvbSB8fFxuICAgICAgICAwO1xuICAgIGNvbnN0IHBhZGRpbmdMZWZ0ID0gZ2V0Q29tcHV0ZWRQYWRkaW5nKG5vZGUsIFlvZ2EuRWRnZS5MZWZ0KSB8fFxuICAgICAgICBib3g/LnBhZGRpbmdMZWZ0IHx8XG4gICAgICAgIHN0eWxlPy5wYWRkaW5nTGVmdCB8fFxuICAgICAgICAwO1xuICAgIHJldHVybiB7IHBhZGRpbmdUb3AsIHBhZGRpbmdSaWdodCwgcGFkZGluZ0JvdHRvbSwgcGFkZGluZ0xlZnQgfTtcbn07XG5cbmNvbnN0IGdldFdyYXBBcmVhID0gKHBhZ2UpID0+IHtcbiAgICBjb25zdCBoZWlnaHQgPSBwYWdlLnN0eWxlPy5oZWlnaHQ7XG4gICAgY29uc3QgeyBwYWRkaW5nQm90dG9tIH0gPSBnZXRQYWRkaW5nKHBhZ2UpO1xuICAgIHJldHVybiBoZWlnaHQgLSBwYWRkaW5nQm90dG9tO1xufTtcblxuY29uc3QgZ2V0Q29udGVudEFyZWEgPSAocGFnZSkgPT4ge1xuICAgIGNvbnN0IGhlaWdodCA9IHBhZ2Uuc3R5bGU/LmhlaWdodDtcbiAgICBjb25zdCB7IHBhZGRpbmdUb3AsIHBhZGRpbmdCb3R0b20gfSA9IGdldFBhZGRpbmcocGFnZSk7XG4gICAgcmV0dXJuIGhlaWdodCAtIHBhZGRpbmdCb3R0b20gLSBwYWRkaW5nVG9wO1xufTtcblxuY29uc3QgaXNTdHJpbmcgPSAodmFsdWUpID0+IHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZyc7XG5jb25zdCBpc051bWJlciA9ICh2YWx1ZSkgPT4gdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJztcbmNvbnN0IGlzQm9vbGVhbiA9ICh2YWx1ZSkgPT4gdHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbic7XG5jb25zdCBpc0ZyYWdtZW50ID0gKHZhbHVlKSA9PiB2YWx1ZSAmJiB2YWx1ZS50eXBlID09PSBTeW1ib2wuZm9yKCdyZWFjdC5mcmFnbWVudCcpO1xuLyoqXG4gKiBUcmFuc2Zvcm1zIGEgcmVhY3QgZWxlbWVudCBpbnN0YW5jZSB0byBpbnRlcm5hbCBlbGVtZW50IGZvcm1hdC5cbiAqXG4gKiBDYW4gcmV0dXJuIG11bHRpcGxlIGluc3RhbmNlcyBpbiB0aGUgY2FzZSBvZiBhcnJheXMgb3IgZnJhZ21lbnRzLlxuICpcbiAqIEBwYXJhbSBlbGVtZW50IC0gUmVhY3QgZWxlbWVudFxuICogQHJldHVybnMgUGFyc2VkIFJlYWN0IGVsZW1lbnRzXG4gKi9cbmNvbnN0IGNyZWF0ZUluc3RhbmNlcyA9IChlbGVtZW50KSA9PiB7XG4gICAgaWYgKCFlbGVtZW50KVxuICAgICAgICByZXR1cm4gW107XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZWxlbWVudCkpIHtcbiAgICAgICAgcmV0dXJuIGVsZW1lbnQucmVkdWNlKChhY2MsIGVsKSA9PiBhY2MuY29uY2F0KGNyZWF0ZUluc3RhbmNlcyhlbCkpLCBbXSk7XG4gICAgfVxuICAgIGlmIChpc0Jvb2xlYW4oZWxlbWVudCkpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICBpZiAoaXNTdHJpbmcoZWxlbWVudCkgfHwgaXNOdW1iZXIoZWxlbWVudCkpIHtcbiAgICAgICAgcmV0dXJuIFt7IHR5cGU6IFAuVGV4dEluc3RhbmNlLCB2YWx1ZTogYCR7ZWxlbWVudH1gIH1dO1xuICAgIH1cbiAgICBpZiAoaXNGcmFnbWVudChlbGVtZW50KSkge1xuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIGZpZ3VyZSBvdXQgd2h5IHRoaXMgaXMgY29tcGxhaW5zXG4gICAgICAgIHJldHVybiBjcmVhdGVJbnN0YW5jZXMoZWxlbWVudC5wcm9wcy5jaGlsZHJlbik7XG4gICAgfVxuICAgIGlmICghaXNTdHJpbmcoZWxlbWVudC50eXBlKSkge1xuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIGZpZ3VyZSBvdXQgd2h5IHRoaXMgaXMgY29tcGxhaW5zXG4gICAgICAgIHJldHVybiBjcmVhdGVJbnN0YW5jZXMoZWxlbWVudC50eXBlKGVsZW1lbnQucHJvcHMpKTtcbiAgICB9XG4gICAgY29uc3QgeyB0eXBlLCBwcm9wczogeyBzdHlsZSA9IHt9LCBjaGlsZHJlbiwgLi4ucHJvcHMgfSwgfSA9IGVsZW1lbnQ7XG4gICAgY29uc3QgbmV4dENoaWxkcmVuID0gY2FzdEFycmF5KGNoaWxkcmVuKS5yZWR1Y2UoKGFjYywgY2hpbGQpID0+IGFjYy5jb25jYXQoY3JlYXRlSW5zdGFuY2VzKGNoaWxkKSksIFtdKTtcbiAgICByZXR1cm4gW1xuICAgICAgICB7XG4gICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgc3R5bGUsXG4gICAgICAgICAgICBwcm9wcyxcbiAgICAgICAgICAgIGNoaWxkcmVuOiBuZXh0Q2hpbGRyZW4sXG4gICAgICAgIH0sXG4gICAgXTtcbn07XG5cbmNvbnN0IGdldEJyZWFrID0gKG5vZGUpID0+ICdicmVhaycgaW4gbm9kZS5wcm9wcyA/IG5vZGUucHJvcHMuYnJlYWsgOiBmYWxzZTtcbmNvbnN0IGdldE1pblByZXNlbmNlQWhlYWQgPSAobm9kZSkgPT4gJ21pblByZXNlbmNlQWhlYWQnIGluIG5vZGUucHJvcHMgPyBub2RlLnByb3BzLm1pblByZXNlbmNlQWhlYWQgOiAwO1xuY29uc3QgZ2V0RnVydGhlc3RFbmQgPSAoZWxlbWVudHMpID0+IE1hdGgubWF4KC4uLmVsZW1lbnRzLm1hcCgobm9kZSkgPT4gbm9kZS5ib3gudG9wICsgbm9kZS5ib3guaGVpZ2h0KSk7XG5jb25zdCBnZXRFbmRPZk1pblByZXNlbmNlQWhlYWQgPSAoY2hpbGQpID0+IHtcbiAgICByZXR1cm4gKGNoaWxkLmJveC50b3AgK1xuICAgICAgICBjaGlsZC5ib3guaGVpZ2h0ICtcbiAgICAgICAgY2hpbGQuYm94Lm1hcmdpbkJvdHRvbSArXG4gICAgICAgIGdldE1pblByZXNlbmNlQWhlYWQoY2hpbGQpKTtcbn07XG5jb25zdCBnZXRFbmRPZlByZXNlbmNlID0gKGNoaWxkLCBmdXR1cmVFbGVtZW50cykgPT4ge1xuICAgIGNvbnN0IGFmdGVyTWluUHJlc2VuY2VBaGVhZCA9IGdldEVuZE9mTWluUHJlc2VuY2VBaGVhZChjaGlsZCk7XG4gICAgY29uc3QgZW5kT2ZGdXJ0aGVzdEZ1dHVyZUVsZW1lbnQgPSBnZXRGdXJ0aGVzdEVuZChmdXR1cmVFbGVtZW50cy5maWx0ZXIoKG5vZGUpID0+ICEoJ2ZpeGVkJyBpbiBub2RlLnByb3BzKSkpO1xuICAgIHJldHVybiBNYXRoLm1pbihhZnRlck1pblByZXNlbmNlQWhlYWQsIGVuZE9mRnVydGhlc3RGdXR1cmVFbGVtZW50KTtcbn07XG5jb25zdCBzaG91bGRCcmVhayA9IChjaGlsZCwgZnV0dXJlRWxlbWVudHMsIGhlaWdodCkgPT4ge1xuICAgIGlmICgnZml4ZWQnIGluIGNoaWxkLnByb3BzKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgY29uc3Qgc2hvdWxkU3BsaXQgPSBoZWlnaHQgPCBjaGlsZC5ib3gudG9wICsgY2hpbGQuYm94LmhlaWdodDtcbiAgICBjb25zdCBjYW5XcmFwID0gZ2V0V3JhcChjaGlsZCk7XG4gICAgLy8gQ2FsY3VsYXRlIHRoZSB5IGNvb3JkaW5hdGUgd2hlcmUgdGhlIGRlc2lyZWQgcHJlc2VuY2Ugb2YgdGhlIGNoaWxkIGVuZHNcbiAgICBjb25zdCBlbmRPZlByZXNlbmNlID0gZ2V0RW5kT2ZQcmVzZW5jZShjaGlsZCwgZnV0dXJlRWxlbWVudHMpO1xuICAgIC8vIElmIHRoZSBjaGlsZCBpcyBhbHJlYWR5IGF0IHRoZSB0b3Agb2YgdGhlIHBhZ2UsIGJyZWFraW5nIHdvbid0IGltcHJvdmUgaXRzIHByZXNlbmNlXG4gICAgLy8gKGFzIGxvbmcgYXMgcmVhY3QtcGRmIGRvZXMgbm90IHN1cHBvcnQgYnJlYWtpbmcgaW50byBkaWZmZXJlbnRseSBzaXplZCBjb250YWluZXJzKVxuICAgIGNvbnN0IGJyZWFraW5nSW1wcm92ZXNQcmVzZW5jZSA9IGNoaWxkLmJveC50b3AgPiBjaGlsZC5ib3gubWFyZ2luVG9wO1xuICAgIHJldHVybiAoZ2V0QnJlYWsoY2hpbGQpIHx8XG4gICAgICAgIChzaG91bGRTcGxpdCAmJiAhY2FuV3JhcCkgfHxcbiAgICAgICAgKCFzaG91bGRTcGxpdCAmJiBlbmRPZlByZXNlbmNlID4gaGVpZ2h0ICYmIGJyZWFraW5nSW1wcm92ZXNQcmVzZW5jZSkpO1xufTtcblxuY29uc3QgSUdOT1JBQkxFX0NPREVQT0lOVFMgPSBbXG4gICAgODIzMiwgLy8gTElORV9TRVBBUkFUT1JcbiAgICA4MjMzLCAvLyBQQVJBR1JBUEhfU0VQQVJBVE9SXG5dO1xuY29uc3QgYnVpbGRTdWJzZXRGb3JGb250ID0gKGZvbnQpID0+IElHTk9SQUJMRV9DT0RFUE9JTlRTLnJlZHVjZSgoYWNjLCBjb2RlUG9pbnQpID0+IHtcbiAgICBpZiAoZm9udCAmJlxuICAgICAgICBmb250Lmhhc0dseXBoRm9yQ29kZVBvaW50ICYmXG4gICAgICAgIGZvbnQuaGFzR2x5cGhGb3JDb2RlUG9pbnQoY29kZVBvaW50KSkge1xuICAgICAgICByZXR1cm4gYWNjO1xuICAgIH1cbiAgICByZXR1cm4gWy4uLmFjYywgU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlUG9pbnQpXTtcbn0sIFtdKTtcbmNvbnN0IGlnbm9yZUNoYXJzID0gKGZyYWdtZW50cykgPT4gZnJhZ21lbnRzLm1hcCgoZnJhZ21lbnQpID0+IHtcbiAgICBjb25zdCBjaGFyU3Vic2V0ID0gYnVpbGRTdWJzZXRGb3JGb250KGZyYWdtZW50LmF0dHJpYnV0ZXMuZm9udFswXSk7XG4gICAgY29uc3Qgc3Vic2V0UmVnZXggPSBuZXcgUmVnRXhwKGNoYXJTdWJzZXQuam9pbignfCcpKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBzdHJpbmc6IGZyYWdtZW50LnN0cmluZy5yZXBsYWNlKHN1YnNldFJlZ2V4LCAnJyksXG4gICAgICAgIGF0dHJpYnV0ZXM6IGZyYWdtZW50LmF0dHJpYnV0ZXMsXG4gICAgfTtcbn0pO1xuXG5jb25zdCBQUkVQUk9DRVNTT1JTID0gW2lnbm9yZUNoYXJzLCBlbWJlZEVtb2ppc107XG5jb25zdCBpc0ltYWdlJDEgPSAobm9kZSkgPT4gbm9kZS50eXBlID09PSBQLkltYWdlO1xuY29uc3QgaXNUZXh0SW5zdGFuY2UkMiA9IChub2RlKSA9PiBub2RlLnR5cGUgPT09IFAuVGV4dEluc3RhbmNlO1xuLyoqXG4gKiBHZXQgdGV4dGtpdCBmcmFnbWVudHMgb2YgZ2l2ZW4gbm9kZSBvYmplY3RcbiAqXG4gKiBAcGFyYW0gZm9udFN0b3JlIC0gRm9udCBzdG9yZVxuICogQHBhcmFtIGluc3RhbmNlIC0gTm9kZVxuICogQHBhcmFtIHBhcmVudExpbmsgLSBQYXJlbnQgbGlua1xuICogQHBhcmFtIGxldmVsIC0gRnJhZ21lbnQgbGV2ZWxcbiAqIEByZXR1cm5zIFRleHQgZnJhZ21lbnRzXG4gKi9cbmNvbnN0IGdldEZyYWdtZW50cyA9IChmb250U3RvcmUsIGluc3RhbmNlLCBwYXJlbnRMaW5rID0gbnVsbCwgbGV2ZWwgPSAwKSA9PiB7XG4gICAgaWYgKCFpbnN0YW5jZSlcbiAgICAgICAgcmV0dXJuIFt7IHN0cmluZzogJycgfV07XG4gICAgbGV0IGZyYWdtZW50cyA9IFtdO1xuICAgIGNvbnN0IHsgY29sb3IgPSAnYmxhY2snLCBkaXJlY3Rpb24gPSAnbHRyJywgZm9udEZhbWlseSA9ICdIZWx2ZXRpY2EnLCBmb250V2VpZ2h0LCBmb250U3R5bGUsIGZvbnRTaXplID0gMTgsIHRleHRBbGlnbiwgbGluZUhlaWdodCwgdGV4dERlY29yYXRpb24sIHRleHREZWNvcmF0aW9uQ29sb3IsIHRleHREZWNvcmF0aW9uU3R5bGUsIHRleHRUcmFuc2Zvcm0sIGxldHRlclNwYWNpbmcsIHRleHRJbmRlbnQsIG9wYWNpdHksIHZlcnRpY2FsQWxpZ24sIH0gPSBpbnN0YW5jZS5zdHlsZTtcbiAgICBjb25zdCBmb250RmFtaWxpZXMgPSB0eXBlb2YgZm9udEZhbWlseSA9PT0gJ3N0cmluZycgPyBbZm9udEZhbWlseV0gOiBbLi4uKGZvbnRGYW1pbHkgfHwgW10pXTtcbiAgICAvLyBGYWxsYmFjayBmb250XG4gICAgZm9udEZhbWlsaWVzLnB1c2goJ0hlbHZldGljYScpO1xuICAgIGNvbnN0IGZvbnQgPSBmb250RmFtaWxpZXMubWFwKChmb250RmFtaWx5TmFtZSkgPT4ge1xuICAgICAgICBjb25zdCBvcHRzID0geyBmb250RmFtaWx5OiBmb250RmFtaWx5TmFtZSwgZm9udFdlaWdodCwgZm9udFN0eWxlIH07XG4gICAgICAgIGNvbnN0IG9iaiA9IGZvbnRTdG9yZS5nZXRGb250KG9wdHMpO1xuICAgICAgICByZXR1cm4gb2JqPy5kYXRhO1xuICAgIH0pO1xuICAgIC8vIERvbid0IHBhc3MgbWFpbiBiYWNrZ3JvdW5kIGNvbG9yIHRvIHRleHRraXQuIFdpbGwgYmUgcmVuZGVyZWQgYnkgdGhlIHJlbmRlciBwYWNrYWdlIGluc3RlYWRcbiAgICBjb25zdCBiYWNrZ3JvdW5kQ29sb3IgPSBsZXZlbCA9PT0gMCA/IG51bGwgOiBpbnN0YW5jZS5zdHlsZS5iYWNrZ3JvdW5kQ29sb3I7XG4gICAgY29uc3QgYXR0cmlidXRlcyA9IHtcbiAgICAgICAgZm9udCxcbiAgICAgICAgY29sb3IsXG4gICAgICAgIG9wYWNpdHksXG4gICAgICAgIGZvbnRTaXplLFxuICAgICAgICBsaW5lSGVpZ2h0LFxuICAgICAgICBkaXJlY3Rpb24sXG4gICAgICAgIHZlcnRpY2FsQWxpZ24sXG4gICAgICAgIGJhY2tncm91bmRDb2xvcixcbiAgICAgICAgaW5kZW50OiB0ZXh0SW5kZW50LFxuICAgICAgICBjaGFyYWN0ZXJTcGFjaW5nOiBsZXR0ZXJTcGFjaW5nLFxuICAgICAgICBzdHJpa2VTdHlsZTogdGV4dERlY29yYXRpb25TdHlsZSxcbiAgICAgICAgdW5kZXJsaW5lU3R5bGU6IHRleHREZWNvcmF0aW9uU3R5bGUsXG4gICAgICAgIHVuZGVybGluZTogdGV4dERlY29yYXRpb24gPT09ICd1bmRlcmxpbmUnIHx8XG4gICAgICAgICAgICB0ZXh0RGVjb3JhdGlvbiA9PT0gJ3VuZGVybGluZSBsaW5lLXRocm91Z2gnIHx8XG4gICAgICAgICAgICB0ZXh0RGVjb3JhdGlvbiA9PT0gJ2xpbmUtdGhyb3VnaCB1bmRlcmxpbmUnLFxuICAgICAgICBzdHJpa2U6IHRleHREZWNvcmF0aW9uID09PSAnbGluZS10aHJvdWdoJyB8fFxuICAgICAgICAgICAgdGV4dERlY29yYXRpb24gPT09ICd1bmRlcmxpbmUgbGluZS10aHJvdWdoJyB8fFxuICAgICAgICAgICAgdGV4dERlY29yYXRpb24gPT09ICdsaW5lLXRocm91Z2ggdW5kZXJsaW5lJyxcbiAgICAgICAgc3RyaWtlQ29sb3I6IHRleHREZWNvcmF0aW9uQ29sb3IgfHwgY29sb3IsXG4gICAgICAgIHVuZGVybGluZUNvbG9yOiB0ZXh0RGVjb3JhdGlvbkNvbG9yIHx8IGNvbG9yLFxuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIGFsbG93IHRoaXMgcHJvcHMgYWNjZXNzXG4gICAgICAgIGxpbms6IHBhcmVudExpbmsgfHwgaW5zdGFuY2UucHJvcHM/LnNyYyB8fCBpbnN0YW5jZS5wcm9wcz8uaHJlZixcbiAgICAgICAgYWxpZ246IHRleHRBbGlnbiB8fCAoZGlyZWN0aW9uID09PSAncnRsJyA/ICdyaWdodCcgOiAnbGVmdCcpLFxuICAgIH07XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbnN0YW5jZS5jaGlsZHJlbi5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBjb25zdCBjaGlsZCA9IGluc3RhbmNlLmNoaWxkcmVuW2ldO1xuICAgICAgICBpZiAoaXNJbWFnZSQxKGNoaWxkKSkge1xuICAgICAgICAgICAgZnJhZ21lbnRzLnB1c2goe1xuICAgICAgICAgICAgICAgIHN0cmluZzogU3RyaW5nLmZyb21DaGFyQ29kZSgweGZmZmMpLFxuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgICAgICAgICAgLi4uYXR0cmlidXRlcyxcbiAgICAgICAgICAgICAgICAgICAgYXR0YWNobWVudDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IChjaGlsZC5zdHlsZS53aWR0aCB8fCBmb250U2l6ZSksXG4gICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IChjaGlsZC5zdHlsZS5oZWlnaHQgfHwgZm9udFNpemUpLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW1hZ2U6IGNoaWxkLmltYWdlLmRhdGEsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzVGV4dEluc3RhbmNlJDIoY2hpbGQpKSB7XG4gICAgICAgICAgICBmcmFnbWVudHMucHVzaCh7XG4gICAgICAgICAgICAgICAgc3RyaW5nOiB0cmFuc2Zvcm1UZXh0KGNoaWxkLnZhbHVlLCB0ZXh0VHJhbnNmb3JtKSxcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY2hpbGQpIHtcbiAgICAgICAgICAgIGZyYWdtZW50cy5wdXNoKC4uLmdldEZyYWdtZW50cyhmb250U3RvcmUsIGNoaWxkLCBhdHRyaWJ1dGVzLmxpbmssIGxldmVsICsgMSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgUFJFUFJPQ0VTU09SUy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBjb25zdCBwcmVwcm9jZXNzb3IgPSBQUkVQUk9DRVNTT1JTW2ldO1xuICAgICAgICBmcmFnbWVudHMgPSBwcmVwcm9jZXNzb3IoZnJhZ21lbnRzKTtcbiAgICB9XG4gICAgcmV0dXJuIGZyYWdtZW50cztcbn07XG4vKipcbiAqIEdldCB0ZXh0a2l0IGF0dHJpYnV0ZWQgc3RyaW5nIGZyb20gdGV4dCBub2RlXG4gKlxuICogQHBhcmFtIGZvbnRTdG9yZSAtIEZvbnQgc3RvcmVcbiAqIEBwYXJhbSBpbnN0YW5jZSBOb2RlXG4gKiBAcmV0dXJucyBBdHRyaWJ1dGVkIHN0cmluZ1xuICovXG5jb25zdCBnZXRBdHRyaWJ1dGVkU3RyaW5nID0gKGZvbnRTdG9yZSwgaW5zdGFuY2UpID0+IHtcbiAgICBjb25zdCBmcmFnbWVudHMgPSBnZXRGcmFnbWVudHMoZm9udFN0b3JlLCBpbnN0YW5jZSk7XG4gICAgcmV0dXJuIGZyb21GcmFnbWVudHMoZnJhZ21lbnRzKTtcbn07XG5cbmNvbnN0IGVuZ2luZXMgPSB7XG4gICAgYmlkaSxcbiAgICBsaW5lYnJlYWtlcixcbiAgICBqdXN0aWZpY2F0aW9uLFxuICAgIHRleHREZWNvcmF0aW9uLFxuICAgIHNjcmlwdEl0ZW1pemVyLFxuICAgIHdvcmRIeXBoZW5hdGlvbixcbiAgICBmb250U3Vic3RpdHV0aW9uLFxufTtcbmNvbnN0IGVuZ2luZSA9IGxheW91dEVuZ2luZShlbmdpbmVzKTtcbmNvbnN0IGdldE1heExpbmVzID0gKG5vZGUpID0+IG5vZGUuc3R5bGU/Lm1heExpbmVzO1xuY29uc3QgZ2V0VGV4dE92ZXJmbG93ID0gKG5vZGUpID0+IG5vZGUuc3R5bGU/LnRleHRPdmVyZmxvdztcbi8qKlxuICogR2V0IGxheW91dCBjb250YWluZXIgZm9yIHNwZWNpZmljIHRleHQgbm9kZVxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSB3aWR0aFxuICogQHBhcmFtIHtudW1iZXJ9IGhlaWdodFxuICogQHBhcmFtIHtPYmplY3R9IG5vZGVcbiAqIEByZXR1cm5zIHtPYmplY3R9IGxheW91dCBjb250YWluZXJcbiAqL1xuY29uc3QgZ2V0Q29udGFpbmVyID0gKHdpZHRoLCBoZWlnaHQsIG5vZGUpID0+IHtcbiAgICBjb25zdCBtYXhMaW5lcyA9IGdldE1heExpbmVzKG5vZGUpO1xuICAgIGNvbnN0IHRleHRPdmVyZmxvdyA9IGdldFRleHRPdmVyZmxvdyhub2RlKTtcbiAgICByZXR1cm4ge1xuICAgICAgICB4OiAwLFxuICAgICAgICB5OiAwLFxuICAgICAgICB3aWR0aCxcbiAgICAgICAgbWF4TGluZXMsXG4gICAgICAgIGhlaWdodDogaGVpZ2h0IHx8IEluZmluaXR5LFxuICAgICAgICB0cnVuY2F0ZU1vZGU6IHRleHRPdmVyZmxvdyxcbiAgICB9O1xufTtcbi8qKlxuICogR2V0IHRleHQgbGF5b3V0IG9wdGlvbnMgZm9yIHNwZWNpZmljIHRleHQgbm9kZVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBub2RlIGluc3RhbmNlXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBsYXlvdXQgb3B0aW9uc1xuICovXG5jb25zdCBnZXRMYXlvdXRPcHRpb25zID0gKGZvbnRTdG9yZSwgbm9kZSkgPT4gKHtcbiAgICBoeXBoZW5hdGlvblBlbmFsdHk6IG5vZGUucHJvcHMuaHlwaGVuYXRpb25QZW5hbHR5LFxuICAgIHNocmlua1doaXRlc3BhY2VGYWN0b3I6IHsgYmVmb3JlOiAtMC41LCBhZnRlcjogLTAuNSB9LFxuICAgIGh5cGhlbmF0aW9uQ2FsbGJhY2s6IG5vZGUucHJvcHMuaHlwaGVuYXRpb25DYWxsYmFjayB8fFxuICAgICAgICBmb250U3RvcmU/LmdldEh5cGhlbmF0aW9uQ2FsbGJhY2soKSB8fFxuICAgICAgICBudWxsLFxufSk7XG4vKipcbiAqIEdldCB0ZXh0IGxpbmVzIGZvciBnaXZlbiBub2RlXG4gKlxuICogQHBhcmFtIG5vZGUgLSBOb2RlXG4gKiBAcGFyYW0gd2lkdGggLSBDb250YWluZXIgd2lkdGhcbiAqIEBwYXJhbSBoZWlnaHQgLSBDb250YWluZXIgaGVpZ2h0XG4gKiBAcGFyYW0gZm9udFN0b3JlIC0gRm9udCBzdG9yZVxuICogQHJldHVybnMgTGF5b3V0IGxpbmVzXG4gKi9cbmNvbnN0IGxheW91dFRleHQgPSAobm9kZSwgd2lkdGgsIGhlaWdodCwgZm9udFN0b3JlKSA9PiB7XG4gICAgY29uc3QgYXR0cmlidXRlZFN0cmluZyA9IGdldEF0dHJpYnV0ZWRTdHJpbmcoZm9udFN0b3JlLCBub2RlKTtcbiAgICBjb25zdCBjb250YWluZXIgPSBnZXRDb250YWluZXIod2lkdGgsIGhlaWdodCwgbm9kZSk7XG4gICAgY29uc3Qgb3B0aW9ucyA9IGdldExheW91dE9wdGlvbnMoZm9udFN0b3JlLCBub2RlKTtcbiAgICBjb25zdCBsaW5lcyA9IGVuZ2luZShhdHRyaWJ1dGVkU3RyaW5nLCBjb250YWluZXIsIG9wdGlvbnMpO1xuICAgIHJldHVybiBsaW5lcy5yZWR1Y2UoKGFjYywgbGluZSkgPT4gWy4uLmFjYywgLi4ubGluZV0sIFtdKTtcbn07XG5cbmNvbnN0IGlzU3ZnJDIgPSAobm9kZSkgPT4gbm9kZS50eXBlID09PSBQLlN2ZztcbmNvbnN0IGlzVGV4dCQ0ID0gKG5vZGUpID0+IG5vZGUudHlwZSA9PT0gUC5UZXh0O1xuY29uc3Qgc2hvdWxkSXRlcmF0ZSA9IChub2RlKSA9PiAhaXNTdmckMihub2RlKSAmJiAhaXNUZXh0JDQobm9kZSk7XG5jb25zdCBzaG91bGRMYXlvdXRUZXh0ID0gKG5vZGUpID0+IGlzVGV4dCQ0KG5vZGUpICYmICFub2RlLmxpbmVzO1xuLyoqXG4gKiBQZXJmb3JtcyB0ZXh0IGxheW91dCBvbiB0ZXh0IG5vZGUgaWYgd2Fzbid0IGNhbGN1bGF0ZWQgYmVmb3JlLlxuICogVGV4dCBsYXlvdXQgaXMgdXN1YWxseSBwZXJmb3JtZWQgb24gWW9nYSdzIGxheW91dCBwcm9jZXNzICh2aWEgc2V0TWVhc3VyZUZ1bmMpLFxuICogYnV0IHdlIG5lZWQgdG8gbGF5b3V0IHRob3NlIG5vZGVzIHdpdGggZml4ZWQgd2lkdGggYW5kIGhlaWdodC5cbiAqXG4gKiBAcGFyYW0gbm9kZVxuICogQHJldHVybnMgTGF5b3V0IG5vZGVcbiAqL1xuY29uc3QgcmVzb2x2ZVRleHRMYXlvdXQgPSAobm9kZSwgZm9udFN0b3JlKSA9PiB7XG4gICAgaWYgKHNob3VsZExheW91dFRleHQobm9kZSkpIHtcbiAgICAgICAgY29uc3Qgd2lkdGggPSBub2RlLmJveC53aWR0aCAtIChub2RlLmJveC5wYWRkaW5nUmlnaHQgKyBub2RlLmJveC5wYWRkaW5nTGVmdCk7XG4gICAgICAgIGNvbnN0IGhlaWdodCA9IG5vZGUuYm94LmhlaWdodCAtIChub2RlLmJveC5wYWRkaW5nVG9wICsgbm9kZS5ib3gucGFkZGluZ0JvdHRvbSk7XG4gICAgICAgIG5vZGUubGluZXMgPSBsYXlvdXRUZXh0KG5vZGUsIHdpZHRoLCBoZWlnaHQsIGZvbnRTdG9yZSk7XG4gICAgfVxuICAgIGlmIChzaG91bGRJdGVyYXRlKG5vZGUpKSB7XG4gICAgICAgIGlmICghbm9kZS5jaGlsZHJlbilcbiAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICBjb25zdCBtYXBDaGlsZCA9IChjaGlsZCkgPT4gcmVzb2x2ZVRleHRMYXlvdXQoY2hpbGQsIGZvbnRTdG9yZSk7XG4gICAgICAgIGNvbnN0IGNoaWxkcmVuID0gbm9kZS5jaGlsZHJlbi5tYXAobWFwQ2hpbGQpO1xuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgbm9kZSwgeyBjaGlsZHJlbiB9KTtcbiAgICB9XG4gICAgcmV0dXJuIG5vZGU7XG59O1xuXG5jb25zdCBCQVNFX0lOSEVSSVRBQkxFX1BST1BFUlRJRVMgPSBbXG4gICAgJ2NvbG9yJyxcbiAgICAnZm9udEZhbWlseScsXG4gICAgJ2ZvbnRTaXplJyxcbiAgICAnZm9udFN0eWxlJyxcbiAgICAnZm9udFdlaWdodCcsXG4gICAgJ2xldHRlclNwYWNpbmcnLFxuICAgICdvcGFjaXR5JyxcbiAgICAndGV4dERlY29yYXRpb24nLFxuICAgICd0ZXh0VHJhbnNmb3JtJyxcbiAgICAnbGluZUhlaWdodCcsXG4gICAgJ3RleHRBbGlnbicsXG4gICAgJ3Zpc2liaWxpdHknLFxuICAgICd3b3JkU3BhY2luZycsXG5dO1xuY29uc3QgVEVYVF9JTkhFUklUQUJMRV9QUk9QRVJUSUVTID0gW1xuICAgIC4uLkJBU0VfSU5IRVJJVEFCTEVfUFJPUEVSVElFUyxcbiAgICAnYmFja2dyb3VuZENvbG9yJyxcbl07XG5jb25zdCBpc1R5cGUkMiA9ICh0eXBlKSA9PiAobm9kZSkgPT4gbm9kZS50eXBlID09PSB0eXBlO1xuY29uc3QgaXNTdmckMSA9IGlzVHlwZSQyKFAuU3ZnKTtcbmNvbnN0IGlzVGV4dCQzID0gaXNUeXBlJDIoUC5UZXh0KTtcbi8vIE1lcmdlIHN0eWxlIHZhbHVlc1xuY29uc3QgbWVyZ2VWYWx1ZXMgPSAoc3R5bGVOYW1lLCB2YWx1ZSwgaW5oZXJpdGVkVmFsdWUpID0+IHtcbiAgICBzd2l0Y2ggKHN0eWxlTmFtZSkge1xuICAgICAgICBjYXNlICd0ZXh0RGVjb3JhdGlvbic6IHtcbiAgICAgICAgICAgIC8vIG1lcmdlIG5vdCBub25lIGFuZCBub3QgZmFsc2UgdGV4dERlY29yYXRpb24gdmFsdWVzIHRvIG9uZSBydWxlXG4gICAgICAgICAgICByZXR1cm4gW2luaGVyaXRlZFZhbHVlLCB2YWx1ZV0uZmlsdGVyKCh2KSA9PiB2ICYmIHYgIT09ICdub25lJykuam9pbignICcpO1xuICAgICAgICB9XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxufTtcbi8vIE1lcmdlIGluaGVyaXRlZCBhbmQgbm9kZSBzdHlsZXNcbmNvbnN0IG1lcmdlID0gKGluaGVyaXRlZFN0eWxlcywgc3R5bGUpID0+IHtcbiAgICBjb25zdCBtZXJnZWRTdHlsZXMgPSB7IC4uLmluaGVyaXRlZFN0eWxlcyB9O1xuICAgIE9iamVjdC5lbnRyaWVzKHN0eWxlKS5mb3JFYWNoKChbc3R5bGVOYW1lLCB2YWx1ZV0pID0+IHtcbiAgICAgICAgbWVyZ2VkU3R5bGVzW3N0eWxlTmFtZV0gPSBtZXJnZVZhbHVlcyhzdHlsZU5hbWUsIHZhbHVlLCBpbmhlcml0ZWRTdHlsZXNbc3R5bGVOYW1lXSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIG1lcmdlZFN0eWxlcztcbn07XG4vKipcbiAqIE1lcmdlcyBzdHlsZXMgd2l0aCBub2RlXG4gKlxuICogQHBhcmFtIGluaGVyaXRlZFN0eWxlcyAtIFN0eWxlIG9iamVjdFxuICogQHJldHVybnMgTWVyZ2Ugc3R5bGVzIGZ1bmN0aW9uXG4gKi9cbmNvbnN0IG1lcmdlU3R5bGVzID0gKGluaGVyaXRlZFN0eWxlcykgPT4gKG5vZGUpID0+IHtcbiAgICBjb25zdCBzdHlsZSA9IG1lcmdlKGluaGVyaXRlZFN0eWxlcywgbm9kZS5zdHlsZSB8fCB7fSk7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIG5vZGUsIHsgc3R5bGUgfSk7XG59O1xuLyoqXG4gKiBJbmhlcml0IHN0eWxlIHZhbHVlcyBmcm9tIHRoZSByb290IHRvIHRoZSBsZWFmc1xuICpcbiAqIEBwYXJhbSBub2RlIC0gRG9jdW1lbnQgcm9vdFxuICogQHJldHVybnMgRG9jdW1lbnQgcm9vdCB3aXRoIGluaGVyaXRhbmNlXG4gKlxuICovXG5jb25zdCByZXNvbHZlSW5oZXJpdGFuY2UgPSAobm9kZSkgPT4ge1xuICAgIGlmIChpc1N2ZyQxKG5vZGUpKVxuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICBpZiAoISgnY2hpbGRyZW4nIGluIG5vZGUpKVxuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICBjb25zdCBpbmhlcml0YWJsZVByb3BlcnRpZXMgPSBpc1RleHQkMyhub2RlKVxuICAgICAgICA/IFRFWFRfSU5IRVJJVEFCTEVfUFJPUEVSVElFU1xuICAgICAgICA6IEJBU0VfSU5IRVJJVEFCTEVfUFJPUEVSVElFUztcbiAgICBjb25zdCBpbmhlcml0U3R5bGVzID0gcGljayhpbmhlcml0YWJsZVByb3BlcnRpZXMsIG5vZGUuc3R5bGUgfHwge30pO1xuICAgIGNvbnN0IHJlc29sdmVDaGlsZCA9IGNvbXBvc2UocmVzb2x2ZUluaGVyaXRhbmNlLCBtZXJnZVN0eWxlcyhpbmhlcml0U3R5bGVzKSk7XG4gICAgY29uc3QgY2hpbGRyZW4gPSBub2RlLmNoaWxkcmVuLm1hcChyZXNvbHZlQ2hpbGQpO1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBub2RlLCB7IGNoaWxkcmVuIH0pO1xufTtcblxuY29uc3QgZ2V0Q29tcHV0ZWRNYXJnaW4gPSAobm9kZSwgZWRnZSkgPT4ge1xuICAgIGNvbnN0IHsgeW9nYU5vZGUgfSA9IG5vZGU7XG4gICAgcmV0dXJuIHlvZ2FOb2RlID8geW9nYU5vZGUuZ2V0Q29tcHV0ZWRNYXJnaW4oZWRnZSkgOiBudWxsO1xufTtcbi8qKlxuICogR2V0IFlvZ2EgY29tcHV0ZWQgbWFnaW5zLiBaZXJvIG90aGVyd2lzZVxuICpcbiAqIEBwYXJhbSBub2RlXG4gKiBAcmV0dXJucyBNYXJnaW5zXG4gKi9cbmNvbnN0IGdldE1hcmdpbiA9IChub2RlKSA9PiB7XG4gICAgY29uc3QgeyBzdHlsZSwgYm94IH0gPSBub2RlO1xuICAgIGNvbnN0IG1hcmdpblRvcCA9IGdldENvbXB1dGVkTWFyZ2luKG5vZGUsIFlvZ2EuRWRnZS5Ub3ApIHx8XG4gICAgICAgIGJveD8ubWFyZ2luVG9wIHx8XG4gICAgICAgIHN0eWxlPy5tYXJnaW5Ub3AgfHxcbiAgICAgICAgMDtcbiAgICBjb25zdCBtYXJnaW5SaWdodCA9IGdldENvbXB1dGVkTWFyZ2luKG5vZGUsIFlvZ2EuRWRnZS5SaWdodCkgfHxcbiAgICAgICAgYm94Py5tYXJnaW5SaWdodCB8fFxuICAgICAgICBzdHlsZT8ubWFyZ2luUmlnaHQgfHxcbiAgICAgICAgMDtcbiAgICBjb25zdCBtYXJnaW5Cb3R0b20gPSBnZXRDb21wdXRlZE1hcmdpbihub2RlLCBZb2dhLkVkZ2UuQm90dG9tKSB8fFxuICAgICAgICBib3g/Lm1hcmdpbkJvdHRvbSB8fFxuICAgICAgICBzdHlsZT8ubWFyZ2luQm90dG9tIHx8XG4gICAgICAgIDA7XG4gICAgY29uc3QgbWFyZ2luTGVmdCA9IGdldENvbXB1dGVkTWFyZ2luKG5vZGUsIFlvZ2EuRWRnZS5MZWZ0KSB8fFxuICAgICAgICBib3g/Lm1hcmdpbkxlZnQgfHxcbiAgICAgICAgc3R5bGU/Lm1hcmdpbkxlZnQgfHxcbiAgICAgICAgMDtcbiAgICByZXR1cm4geyBtYXJnaW5Ub3AsIG1hcmdpblJpZ2h0LCBtYXJnaW5Cb3R0b20sIG1hcmdpbkxlZnQgfTtcbn07XG5cbi8qKlxuICogR2V0IFlvZ2EgY29tcHV0ZWQgcG9zaXRpb24uIFplcm8gb3RoZXJ3aXNlXG4gKlxuICogQHBhcmFtIG5vZGVcbiAqIEByZXR1cm5zIFBvc2l0aW9uXG4gKi9cbmNvbnN0IGdldFBvc2l0aW9uID0gKG5vZGUpID0+IHtcbiAgICBjb25zdCB7IHlvZ2FOb2RlIH0gPSBub2RlO1xuICAgIHJldHVybiB7XG4gICAgICAgIHRvcDogeW9nYU5vZGU/LmdldENvbXB1dGVkVG9wKCkgfHwgMCxcbiAgICAgICAgcmlnaHQ6IHlvZ2FOb2RlPy5nZXRDb21wdXRlZFJpZ2h0KCkgfHwgMCxcbiAgICAgICAgYm90dG9tOiB5b2dhTm9kZT8uZ2V0Q29tcHV0ZWRCb3R0b20oKSB8fCAwLFxuICAgICAgICBsZWZ0OiB5b2dhTm9kZT8uZ2V0Q29tcHV0ZWRMZWZ0KCkgfHwgMCxcbiAgICB9O1xufTtcblxuY29uc3QgREVGQVVMVF9ESU1FTlNJT04gPSB7XG4gICAgd2lkdGg6IDAsXG4gICAgaGVpZ2h0OiAwLFxufTtcbi8qKlxuICogR2V0IFlvZ2EgY29tcHV0ZWQgZGltZW5zaW9ucy4gWmVybyBvdGhlcndpc2VcbiAqXG4gKiBAcGFyYW0gbm9kZVxuICogQHJldHVybnMgRGltZW5zaW9uc1xuICovXG5jb25zdCBnZXREaW1lbnNpb24gPSAobm9kZSkgPT4ge1xuICAgIGNvbnN0IHsgeW9nYU5vZGUgfSA9IG5vZGU7XG4gICAgaWYgKCF5b2dhTm9kZSlcbiAgICAgICAgcmV0dXJuIERFRkFVTFRfRElNRU5TSU9OO1xuICAgIHJldHVybiB7XG4gICAgICAgIHdpZHRoOiB5b2dhTm9kZS5nZXRDb21wdXRlZFdpZHRoKCksXG4gICAgICAgIGhlaWdodDogeW9nYU5vZGUuZ2V0Q29tcHV0ZWRIZWlnaHQoKSxcbiAgICB9O1xufTtcblxuY29uc3QgZ2V0Q29tcHV0ZWRCb3JkZXIgPSAoeW9nYU5vZGUsIGVkZ2UpID0+ICh5b2dhTm9kZSA/IHlvZ2FOb2RlLmdldENvbXB1dGVkQm9yZGVyKGVkZ2UpIDogMCk7XG4vKipcbiAqIEdldCBZb2dhIGNvbXB1dGVkIGJvcmRlciB3aWR0aC4gWmVybyBvdGhlcndpc2VcbiAqXG4gKiBAcGFyYW0gbm9kZVxuICogQHJldHVybnMgQm9yZGVyIHdpZHRoc1xuICovXG5jb25zdCBnZXRCb3JkZXJXaWR0aCA9IChub2RlKSA9PiB7XG4gICAgY29uc3QgeyB5b2dhTm9kZSB9ID0gbm9kZTtcbiAgICByZXR1cm4ge1xuICAgICAgICBib3JkZXJUb3BXaWR0aDogZ2V0Q29tcHV0ZWRCb3JkZXIoeW9nYU5vZGUsIFlvZ2EuRWRnZS5Ub3ApLFxuICAgICAgICBib3JkZXJSaWdodFdpZHRoOiBnZXRDb21wdXRlZEJvcmRlcih5b2dhTm9kZSwgWW9nYS5FZGdlLlJpZ2h0KSxcbiAgICAgICAgYm9yZGVyQm90dG9tV2lkdGg6IGdldENvbXB1dGVkQm9yZGVyKHlvZ2FOb2RlLCBZb2dhLkVkZ2UuQm90dG9tKSxcbiAgICAgICAgYm9yZGVyTGVmdFdpZHRoOiBnZXRDb21wdXRlZEJvcmRlcih5b2dhTm9kZSwgWW9nYS5FZGdlLkxlZnQpLFxuICAgIH07XG59O1xuXG4vKipcbiAqIFNldCBkaXNwbGF5IGF0dHJpYnV0ZSB0byBub2RlJ3MgWW9nYSBpbnN0YW5jZVxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIERpc3BsYXlcbiAqIEByZXR1cm5zIE5vZGUgaW5zdGFuY2Ugd3JhcHBlclxuICovXG5jb25zdCBzZXREaXNwbGF5ID0gKHZhbHVlKSA9PiAobm9kZSkgPT4ge1xuICAgIGNvbnN0IHsgeW9nYU5vZGUgfSA9IG5vZGU7XG4gICAgaWYgKHlvZ2FOb2RlKSB7XG4gICAgICAgIHlvZ2FOb2RlLnNldERpc3BsYXkodmFsdWUgPT09ICdub25lJyA/IFlvZ2EuRGlzcGxheS5Ob25lIDogWW9nYS5EaXNwbGF5LkZsZXgpO1xuICAgIH1cbiAgICByZXR1cm4gbm9kZTtcbn07XG5cbmNvbnN0IE9WRVJGTE9XID0ge1xuICAgIGhpZGRlbjogWW9nYS5PdmVyZmxvdy5IaWRkZW4sXG4gICAgc2Nyb2xsOiBZb2dhLk92ZXJmbG93LlNjcm9sbCxcbn07XG4vKipcbiAqIFNldCBvdmVyZmxvdyBhdHRyaWJ1dGUgdG8gbm9kZSdzIFlvZ2EgaW5zdGFuY2VcbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBPdmVyZmxvdyB2YWx1ZVxuICogQHJldHVybnMgTm9kZSBpbnN0YW5jZSB3cmFwcGVyXG4gKi9cbmNvbnN0IHNldE92ZXJmbG93ID0gKHZhbHVlKSA9PiAobm9kZSkgPT4ge1xuICAgIGNvbnN0IHsgeW9nYU5vZGUgfSA9IG5vZGU7XG4gICAgaWYgKCFpc05pbCh2YWx1ZSkgJiYgeW9nYU5vZGUpIHtcbiAgICAgICAgY29uc3Qgb3ZlcmZsb3cgPSBPVkVSRkxPV1t2YWx1ZV0gfHwgWW9nYS5PdmVyZmxvdy5WaXNpYmxlO1xuICAgICAgICB5b2dhTm9kZS5zZXRPdmVyZmxvdyhvdmVyZmxvdyk7XG4gICAgfVxuICAgIHJldHVybiBub2RlO1xufTtcblxuY29uc3QgRkxFWF9XUkFQID0ge1xuICAgIHdyYXA6IFlvZ2EuV3JhcC5XcmFwLFxuICAgICd3cmFwLXJldmVyc2UnOiBZb2dhLldyYXAuV3JhcFJldmVyc2UsXG59O1xuLyoqXG4gKiBTZXQgZmxleCB3cmFwIGF0dHJpYnV0ZSB0byBub2RlJ3MgWW9nYSBpbnN0YW5jZVxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIEZsZXggd3JhcCB2YWx1ZVxuICogQHJldHVybnMgTm9kZSBpbnN0YW5jZSB3cmFwcGVyXG4gKi9cbmNvbnN0IHNldEZsZXhXcmFwID0gKHZhbHVlKSA9PiAobm9kZSkgPT4ge1xuICAgIGNvbnN0IHsgeW9nYU5vZGUgfSA9IG5vZGU7XG4gICAgaWYgKHlvZ2FOb2RlKSB7XG4gICAgICAgIGNvbnN0IGZsZXhXcmFwID0gRkxFWF9XUkFQW3ZhbHVlXSB8fCBZb2dhLldyYXAuTm9XcmFwO1xuICAgICAgICB5b2dhTm9kZS5zZXRGbGV4V3JhcChmbGV4V3JhcCk7XG4gICAgfVxuICAgIHJldHVybiBub2RlO1xufTtcblxuLyoqXG4gKiBTZXQgZ2VuZXJpYyB5b2dhIGF0dHJpYnV0ZSB0byBub2RlJ3MgWW9nYSBpbnN0YW5jZSwgaGFuZGluZyBgYXV0b2AsIGVkZ2VzIGFuZCBwZXJjZW50YWdlIGNhc2VzXG4gKlxuICogQHBhcmFtIGF0dHIgLSBQcm9wZXJ0eVxuICogQHBhcmFtIGVkZ2UgLSBFZGdlXG4gKiBAcmV0dXJucyBOb2RlIGluc3RhbmNlIHdyYXBwZXJcbiAqL1xuY29uc3Qgc2V0WW9nYVZhbHVlID0gKGF0dHIsIGVkZ2UpID0+ICh2YWx1ZSkgPT4gKG5vZGUpID0+IHtcbiAgICBjb25zdCB7IHlvZ2FOb2RlIH0gPSBub2RlO1xuICAgIGlmICghaXNOaWwodmFsdWUpICYmIHlvZ2FOb2RlKSB7XG4gICAgICAgIGNvbnN0IGhhc0VkZ2UgPSAhaXNOaWwoZWRnZSk7XG4gICAgICAgIGNvbnN0IGZpeGVkTWV0aG9kID0gYHNldCR7dXBwZXJGaXJzdChhdHRyKX1gO1xuICAgICAgICBjb25zdCBhdXRvTWV0aG9kID0gYCR7Zml4ZWRNZXRob2R9QXV0b2A7XG4gICAgICAgIGNvbnN0IHBlcmNlbnRNZXRob2QgPSBgJHtmaXhlZE1ldGhvZH1QZXJjZW50YDtcbiAgICAgICAgY29uc3QgcGVyY2VudCA9IG1hdGNoUGVyY2VudCh2YWx1ZSk7XG4gICAgICAgIGlmIChwZXJjZW50ICYmICF5b2dhTm9kZVtwZXJjZW50TWV0aG9kXSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBZb3UgY2FuJ3QgcGFzcyBwZXJjZW50YWdlIHZhbHVlcyB0byAke2F0dHJ9IHByb3BlcnR5YCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBlcmNlbnQpIHtcbiAgICAgICAgICAgIGlmIChoYXNFZGdlKSB7XG4gICAgICAgICAgICAgICAgeW9nYU5vZGVbcGVyY2VudE1ldGhvZF0/LihlZGdlLCBwZXJjZW50LnZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHlvZ2FOb2RlW3BlcmNlbnRNZXRob2RdPy4ocGVyY2VudC52YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodmFsdWUgPT09ICdhdXRvJykge1xuICAgICAgICAgICAgaWYgKGhhc0VkZ2UpIHtcbiAgICAgICAgICAgICAgICB5b2dhTm9kZVthdXRvTWV0aG9kXT8uKGVkZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgeW9nYU5vZGVbYXV0b01ldGhvZF0/LigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGhhc0VkZ2UpIHtcbiAgICAgICAgICAgIHlvZ2FOb2RlW2ZpeGVkTWV0aG9kXT8uKGVkZ2UsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHlvZ2FOb2RlW2ZpeGVkTWV0aG9kXT8uKHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbm9kZTtcbn07XG5cbi8qKlxuICogU2V0IGZsZXggZ3JvdyBhdHRyaWJ1dGUgdG8gbm9kZSdzIFlvZ2EgaW5zdGFuY2VcbiAqXG4gKiBAcGFyYW0gIHZhbHVlIC0gRmxleCBncm93IHZhbHVlXG4gKiBAcmV0dXJucyBOb2RlIGluc3RhbmNlIHdyYXBwZXJcbiAqL1xuY29uc3Qgc2V0RmxleEdyb3cgPSAodmFsdWUpID0+IChub2RlKSA9PiB7XG4gICAgcmV0dXJuIHNldFlvZ2FWYWx1ZSgnZmxleEdyb3cnKSh2YWx1ZSB8fCAwKShub2RlKTtcbn07XG5cbi8qKlxuICogU2V0IGZsZXggYmFzaXMgYXR0cmlidXRlIHRvIG5vZGUncyBZb2dhIGluc3RhbmNlXG4gKlxuICogQHBhcmFtIGZsZXggLSBCYXNpcyB2YWx1ZVxuICogQHBhcmFtIG5vZGUgLSBOb2RlIGluc3RhbmNlXG4gKiBAcmV0dXJucyBOb2RlIGluc3RhbmNlXG4gKi9cbmNvbnN0IHNldEZsZXhCYXNpcyA9IHNldFlvZ2FWYWx1ZSgnZmxleEJhc2lzJyk7XG5cbmNvbnN0IEFMSUdOID0ge1xuICAgICdmbGV4LXN0YXJ0JzogWW9nYS5BbGlnbi5GbGV4U3RhcnQsXG4gICAgY2VudGVyOiBZb2dhLkFsaWduLkNlbnRlcixcbiAgICAnZmxleC1lbmQnOiBZb2dhLkFsaWduLkZsZXhFbmQsXG4gICAgc3RyZXRjaDogWW9nYS5BbGlnbi5TdHJldGNoLFxuICAgIGJhc2VsaW5lOiBZb2dhLkFsaWduLkJhc2VsaW5lLFxuICAgICdzcGFjZS1iZXR3ZWVuJzogWW9nYS5BbGlnbi5TcGFjZUJldHdlZW4sXG4gICAgJ3NwYWNlLWFyb3VuZCc6IFlvZ2EuQWxpZ24uU3BhY2VBcm91bmQsXG4gICAgJ3NwYWNlLWV2ZW5seSc6IFlvZ2EuQWxpZ24uU3BhY2VFdmVubHksXG59O1xuLyoqXG4gKiBTZXQgZ2VuZXJpYyBhbGlnbiBhdHRyaWJ1dGUgdG8gbm9kZSdzIFlvZ2EgaW5zdGFuY2VcbiAqXG4gKiBAcGFyYW0gYXR0ciAtIFNwZWNpZmljIGFsaWduIHByb3BlcnR5XG4gKiBAcGFyYW0gdmFsdWUgLSBTcGVjaWZpYyBhbGlnbiB2YWx1ZVxuICogQHBhcmFtIG5vZGUgLSBOb2RlXG4gKiBAcmV0dXJucyBOb2RlXG4gKi9cbmNvbnN0IHNldEFsaWduID0gKGF0dHIpID0+ICh2YWx1ZSkgPT4gKG5vZGUpID0+IHtcbiAgICBjb25zdCB7IHlvZ2FOb2RlIH0gPSBub2RlO1xuICAgIGNvbnN0IGRlZmF1bHRWYWx1ZSA9IGF0dHIgPT09ICdpdGVtcycgPyBZb2dhLkFsaWduLlN0cmV0Y2ggOiBZb2dhLkFsaWduLkF1dG87XG4gICAgaWYgKHlvZ2FOb2RlKSB7XG4gICAgICAgIGNvbnN0IGFsaWduID0gQUxJR05bdmFsdWVdIHx8IGRlZmF1bHRWYWx1ZTtcbiAgICAgICAgeW9nYU5vZGVbYHNldEFsaWduJHt1cHBlckZpcnN0KGF0dHIpfWBdKGFsaWduKTtcbiAgICB9XG4gICAgcmV0dXJuIG5vZGU7XG59O1xuXG4vKipcbiAqIFNldCBhbGlnbiBzZWxmIGF0dHJpYnV0ZSB0byBub2RlJ3MgWW9nYSBpbnN0YW5jZVxuICpcbiAqIEBwYXJhbSBhbGlnbiAtIFZhbHVlXG4gKiBAcGFyYW0gbm9kZSAtIE5vZGUgaW5zdGFuY2VcbiAqIEByZXR1cm5zIE5vZGUgaW5zdGFuY2VcbiAqL1xuY29uc3Qgc2V0QWxpZ25TZWxmID0gc2V0QWxpZ24oJ3NlbGYnKTtcblxuLyoqXG4gKiBTZXQgYWxpZ24gaXRlbXMgYXR0cmlidXRlIHRvIG5vZGUncyBZb2dhIGluc3RhbmNlXG4gKlxuICogQHBhcmFtIGFsaWduIC0gVmFsdWVcbiAqIEBwYXJhbSBub2RlIC0gTm9kZSBpbnN0YW5jZVxuICogQHJldHVybnMgTm9kZSBpbnN0YW5jZVxuICovXG5jb25zdCBzZXRBbGlnbkl0ZW1zID0gc2V0QWxpZ24oJ2l0ZW1zJyk7XG5cbi8qKlxuICogU2V0IGZsZXggc2hyaW5rIGF0dHJpYnV0ZSB0byBub2RlJ3MgWW9nYSBpbnN0YW5jZVxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIEZsZXggc2hyaW5rIHZhbHVlXG4gKiBAcmV0dXJucyBOb2RlIGluc3RhbmNlIHdyYXBwZXJcbiAqL1xuY29uc3Qgc2V0RmxleFNocmluayA9ICh2YWx1ZSkgPT4gKG5vZGUpID0+IHtcbiAgICByZXR1cm4gc2V0WW9nYVZhbHVlKCdmbGV4U2hyaW5rJykodmFsdWUgfHwgMSkobm9kZSk7XG59O1xuXG4vKipcbiAqIFNldCBhc3BlY3QgcmF0aW8gYXR0cmlidXRlIHRvIG5vZGUncyBZb2dhIGluc3RhbmNlXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gUmF0aW9cbiAqIEByZXR1cm5zIE5vZGUgaW5zdGFuY2VcbiAqL1xuY29uc3Qgc2V0QXNwZWN0UmF0aW8gPSAodmFsdWUpID0+IChub2RlKSA9PiB7XG4gICAgY29uc3QgeyB5b2dhTm9kZSB9ID0gbm9kZTtcbiAgICBpZiAoIWlzTmlsKHZhbHVlKSAmJiB5b2dhTm9kZSkge1xuICAgICAgICB5b2dhTm9kZS5zZXRBc3BlY3RSYXRpbyh2YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiBub2RlO1xufTtcblxuLyoqXG4gKiBTZXQgYWxpZ24gY29udGVudCBhdHRyaWJ1dGUgdG8gbm9kZSdzIFlvZ2EgaW5zdGFuY2VcbiAqXG4gKiBAcGFyYW0gYWxpZ24gLSBWYWx1ZVxuICogQHBhcmFtIG5vZGUgLSBJbnN0YW5jZVxuICogQHJldHVybnMgTm9kZSBpbnN0YW5jZVxuICovXG5jb25zdCBzZXRBbGlnbkNvbnRlbnQgPSBzZXRBbGlnbignY29udGVudCcpO1xuXG5jb25zdCBQT1NJVElPTiA9IHtcbiAgICBhYnNvbHV0ZTogWW9nYS5Qb3NpdGlvblR5cGUuQWJzb2x1dGUsXG4gICAgcmVsYXRpdmU6IFlvZ2EuUG9zaXRpb25UeXBlLlJlbGF0aXZlLFxuICAgIHN0YXRpYzogWW9nYS5Qb3NpdGlvblR5cGUuU3RhdGljLFxufTtcbi8qKlxuICogU2V0IHBvc2l0aW9uIHR5cGUgYXR0cmlidXRlIHRvIG5vZGUncyBZb2dhIGluc3RhbmNlXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gUG9zaXRpb24gcG9zaXRpb24gdHlwZVxuICogQHJldHVybnMgTm9kZSBpbnN0YW5jZVxuICovXG5jb25zdCBzZXRQb3NpdGlvblR5cGUgPSAodmFsdWUpID0+IChub2RlKSA9PiB7XG4gICAgY29uc3QgeyB5b2dhTm9kZSB9ID0gbm9kZTtcbiAgICBpZiAoIWlzTmlsKHZhbHVlKSAmJiB5b2dhTm9kZSkge1xuICAgICAgICB5b2dhTm9kZS5zZXRQb3NpdGlvblR5cGUoUE9TSVRJT05bdmFsdWVdKTtcbiAgICB9XG4gICAgcmV0dXJuIG5vZGU7XG59O1xuXG5jb25zdCBGTEVYX0RJUkVDVElPTlMgPSB7XG4gICAgcm93OiBZb2dhLkZsZXhEaXJlY3Rpb24uUm93LFxuICAgICdyb3ctcmV2ZXJzZSc6IFlvZ2EuRmxleERpcmVjdGlvbi5Sb3dSZXZlcnNlLFxuICAgICdjb2x1bW4tcmV2ZXJzZSc6IFlvZ2EuRmxleERpcmVjdGlvbi5Db2x1bW5SZXZlcnNlLFxufTtcbi8qKlxuICogU2V0IGZsZXggZGlyZWN0aW9uIGF0dHJpYnV0ZSB0byBub2RlJ3MgWW9nYSBpbnN0YW5jZVxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIEZsZXggZGlyZWN0aW9uIHZhbHVlXG4gKiBAcmV0dXJucyBOb2RlIGluc3RhbmNlIHdyYXBwZXJcbiAqL1xuY29uc3Qgc2V0RmxleERpcmVjdGlvbiA9ICh2YWx1ZSkgPT4gKG5vZGUpID0+IHtcbiAgICBjb25zdCB7IHlvZ2FOb2RlIH0gPSBub2RlO1xuICAgIGlmICh5b2dhTm9kZSkge1xuICAgICAgICBjb25zdCBmbGV4RGlyZWN0aW9uID0gRkxFWF9ESVJFQ1RJT05TW3ZhbHVlXSB8fCBZb2dhLkZsZXhEaXJlY3Rpb24uQ29sdW1uO1xuICAgICAgICB5b2dhTm9kZS5zZXRGbGV4RGlyZWN0aW9uKGZsZXhEaXJlY3Rpb24pO1xuICAgIH1cbiAgICByZXR1cm4gbm9kZTtcbn07XG5cbmNvbnN0IEpVU1RJRllfQ09OVEVOVCA9IHtcbiAgICBjZW50ZXI6IFlvZ2EuSnVzdGlmeS5DZW50ZXIsXG4gICAgJ2ZsZXgtZW5kJzogWW9nYS5KdXN0aWZ5LkZsZXhFbmQsXG4gICAgJ3NwYWNlLWJldHdlZW4nOiBZb2dhLkp1c3RpZnkuU3BhY2VCZXR3ZWVuLFxuICAgICdzcGFjZS1hcm91bmQnOiBZb2dhLkp1c3RpZnkuU3BhY2VBcm91bmQsXG4gICAgJ3NwYWNlLWV2ZW5seSc6IFlvZ2EuSnVzdGlmeS5TcGFjZUV2ZW5seSxcbn07XG4vKipcbiAqIFNldCBqdXN0aWZ5IGNvbnRlbnQgYXR0cmlidXRlIHRvIG5vZGUncyBZb2dhIGluc3RhbmNlXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gSnVzdGlmeSBjb250ZW50IHZhbHVlXG4gKiBAcmV0dXJucyBOb2RlIGluc3RhbmNlIHdyYXBwZXJcbiAqL1xuY29uc3Qgc2V0SnVzdGlmeUNvbnRlbnQgPSAodmFsdWUpID0+IChub2RlKSA9PiB7XG4gICAgY29uc3QgeyB5b2dhTm9kZSB9ID0gbm9kZTtcbiAgICBpZiAoIWlzTmlsKHZhbHVlKSAmJiB5b2dhTm9kZSkge1xuICAgICAgICBjb25zdCBqdXN0aWZ5Q29udGVudCA9IEpVU1RJRllfQ09OVEVOVFt2YWx1ZV0gfHwgWW9nYS5KdXN0aWZ5LkZsZXhTdGFydDtcbiAgICAgICAgeW9nYU5vZGUuc2V0SnVzdGlmeUNvbnRlbnQoanVzdGlmeUNvbnRlbnQpO1xuICAgIH1cbiAgICByZXR1cm4gbm9kZTtcbn07XG5cbi8qKlxuICogU2V0IG1hcmdpbiB0b3AgYXR0cmlidXRlIHRvIG5vZGUncyBZb2dhIGluc3RhbmNlXG4gKlxuICogQHBhcmFtIG1hcmdpbiAtIE1hcmdpbiB0b3BcbiAqIEBwYXJhbSBub2RlIC0gTm9kZSBpbnN0YW5jZVxuICogQHJldHVybnMgTm9kZSBpbnN0YW5jZVxuICovXG5jb25zdCBzZXRNYXJnaW5Ub3AgPSBzZXRZb2dhVmFsdWUoJ21hcmdpbicsIFlvZ2EuRWRnZS5Ub3ApO1xuLyoqXG4gKiBTZXQgbWFyZ2luIHJpZ2h0IGF0dHJpYnV0ZSB0byBub2RlJ3MgWW9nYSBpbnN0YW5jZVxuICpcbiAqIEBwYXJhbSBtYXJnaW4gLSBNYXJnaW4gcmlnaHRcbiAqIEBwYXJhbSBub2RlIC0gTm9kZSBpbnN0YW5jZVxuICogQHJldHVybnMgTm9kZSBpbnN0YW5jZVxuICovXG5jb25zdCBzZXRNYXJnaW5SaWdodCA9IHNldFlvZ2FWYWx1ZSgnbWFyZ2luJywgWW9nYS5FZGdlLlJpZ2h0KTtcbi8qKlxuICogU2V0IG1hcmdpbiBib3R0b20gYXR0cmlidXRlIHRvIG5vZGUncyBZb2dhIGluc3RhbmNlXG4gKlxuICogQHBhcmFtIG1hcmdpbiAtIE1hcmdpbiBib3R0b21cbiAqIEBwYXJhbSBub2RlIC0gTm9kZSBpbnN0YW5jZVxuICogQHJldHVybnMgTm9kZSBpbnN0YW5jZVxuICovXG5jb25zdCBzZXRNYXJnaW5Cb3R0b20gPSBzZXRZb2dhVmFsdWUoJ21hcmdpbicsIFlvZ2EuRWRnZS5Cb3R0b20pO1xuLyoqXG4gKiBTZXQgbWFyZ2luIGxlZnQgYXR0cmlidXRlIHRvIG5vZGUncyBZb2dhIGluc3RhbmNlXG4gKlxuICogQHBhcmFtIG1hcmdpbiAtIE1hcmdpbiBsZWZ0XG4gKiBAcGFyYW0gbm9kZSAtIE5vZGUgaW5zdGFuY2VcbiAqIEByZXR1cm5zIE5vZGUgaW5zdGFuY2VcbiAqL1xuY29uc3Qgc2V0TWFyZ2luTGVmdCA9IHNldFlvZ2FWYWx1ZSgnbWFyZ2luJywgWW9nYS5FZGdlLkxlZnQpO1xuXG4vKipcbiAqIFNldCBwYWRkaW5nIHRvcCBhdHRyaWJ1dGUgdG8gbm9kZSdzIFlvZ2EgaW5zdGFuY2VcbiAqXG4gKiBAcGFyYW0gcGFkZGluZyAtIFBhZGRpbmcgdG9wXG4gKiBAcGFyYW0gbm9kZSAtIE5vZGUgaW5zdGFuY2VcbiAqIEByZXR1cm5zIE5vZGUgaW5zdGFuY2VcbiAqL1xuY29uc3Qgc2V0UGFkZGluZ1RvcCA9IHNldFlvZ2FWYWx1ZSgncGFkZGluZycsIFlvZ2EuRWRnZS5Ub3ApO1xuLyoqXG4gKiBTZXQgcGFkZGluZyByaWdodCBhdHRyaWJ1dGUgdG8gbm9kZSdzIFlvZ2EgaW5zdGFuY2VcbiAqXG4gKiBAcGFyYW0gcGFkZGluZyAtIFBhZGRpbmcgcmlnaHRcbiAqIEBwYXJhbSBub2RlIC0gTm9kZSBpbnN0YW5jZVxuICogQHJldHVybnMgTm9kZSBpbnN0YW5jZVxuICovXG5jb25zdCBzZXRQYWRkaW5nUmlnaHQgPSBzZXRZb2dhVmFsdWUoJ3BhZGRpbmcnLCBZb2dhLkVkZ2UuUmlnaHQpO1xuLyoqXG4gKiBTZXQgcGFkZGluZyBib3R0b20gYXR0cmlidXRlIHRvIG5vZGUncyBZb2dhIGluc3RhbmNlXG4gKlxuICogQHBhcmFtIHBhZGRpbmcgLSBQYWRkaW5nIGJvdHRvbVxuICogQHBhcmFtIG5vZGUgTm9kZSBpbnN0YW5jZVxuICogQHJldHVybnMgTm9kZSBpbnN0YW5jZVxuICovXG5jb25zdCBzZXRQYWRkaW5nQm90dG9tID0gc2V0WW9nYVZhbHVlKCdwYWRkaW5nJywgWW9nYS5FZGdlLkJvdHRvbSk7XG4vKipcbiAqIFNldCBwYWRkaW5nIGxlZnQgYXR0cmlidXRlIHRvIG5vZGUncyBZb2dhIGluc3RhbmNlXG4gKlxuICogQHBhcmFtIHBhZGRpbmcgLSBQYWRkaW5nIGxlZnRcbiAqIEBwYXJhbSBub2RlIC0gTm9kZSBpbnN0YW5jZVxuICogQHJldHVybnMgTm9kZSBpbnN0YW5jZVxuICovXG5jb25zdCBzZXRQYWRkaW5nTGVmdCA9IHNldFlvZ2FWYWx1ZSgncGFkZGluZycsIFlvZ2EuRWRnZS5MZWZ0KTtcblxuLyoqXG4gKiBTZXQgYm9yZGVyIHRvcCBhdHRyaWJ1dGUgdG8gbm9kZSdzIFlvZ2EgaW5zdGFuY2VcbiAqXG4gKiBAcGFyYW0gYm9yZGVyIC0gQm9yZGVyIHRvcCB3aWR0aFxuICogQHBhcmFtIG5vZGUgLSBOb2RlIGluc3RhbmNlXG4gKiBAcmV0dXJucyBOb2RlIGluc3RhbmNlXG4gKi9cbmNvbnN0IHNldEJvcmRlclRvcCA9IHNldFlvZ2FWYWx1ZSgnYm9yZGVyJywgWW9nYS5FZGdlLlRvcCk7XG4vKipcbiAqIFNldCBib3JkZXIgcmlnaHQgYXR0cmlidXRlIHRvIG5vZGUncyBZb2dhIGluc3RhbmNlXG4gKlxuICogQHBhcmFtIGJvcmRlciAtIEJvcmRlciByaWdodCB3aWR0aFxuICogQHBhcmFtIG5vZGUgLSBOb2RlIGluc3RhbmNlXG4gKiBAcmV0dXJucyBOb2RlIGluc3RhbmNlXG4gKi9cbmNvbnN0IHNldEJvcmRlclJpZ2h0ID0gc2V0WW9nYVZhbHVlKCdib3JkZXInLCBZb2dhLkVkZ2UuUmlnaHQpO1xuLyoqXG4gKiBTZXQgYm9yZGVyIGJvdHRvbSBhdHRyaWJ1dGUgdG8gbm9kZSdzIFlvZ2EgaW5zdGFuY2VcbiAqXG4gKiBAcGFyYW0gYm9yZGVyIC0gQm9yZGVyIGJvdHRvbSB3aWR0aFxuICogQHBhcmFtIG5vZGUgLSBOb2RlIGluc3RhbmNlXG4gKiBAcmV0dXJucyBOb2RlIGluc3RhbmNlXG4gKi9cbmNvbnN0IHNldEJvcmRlckJvdHRvbSA9IHNldFlvZ2FWYWx1ZSgnYm9yZGVyJywgWW9nYS5FZGdlLkJvdHRvbSk7XG4vKipcbiAqIFNldCBib3JkZXIgbGVmdCBhdHRyaWJ1dGUgdG8gbm9kZSdzIFlvZ2EgaW5zdGFuY2VcbiAqXG4gKiBAcGFyYW0gYm9yZGVyIC0gQm9yZGVyIGxlZnQgd2lkdGhcbiAqIEBwYXJhbSBub2RlIC0gTm9kZSBpbnN0YW5jZVxuICogQHJldHVybnMgTm9kZSBpbnN0YW5jZVxuICovXG5jb25zdCBzZXRCb3JkZXJMZWZ0ID0gc2V0WW9nYVZhbHVlKCdib3JkZXInLCBZb2dhLkVkZ2UuTGVmdCk7XG5cbi8qKlxuICogU2V0IHBvc2l0aW9uIHRvcCBhdHRyaWJ1dGUgdG8gbm9kZSdzIFlvZ2EgaW5zdGFuY2VcbiAqXG4gKiBAcGFyYW0gcG9zaXRpb24gLSBQb3NpdGlvbiB0b3BcbiAqIEBwYXJhbSBub2RlIC0gTm9kZSBpbnN0YW5jZVxuICogQHJldHVybnMgTm9kZSBpbnN0YW5jZVxuICovXG5jb25zdCBzZXRQb3NpdGlvblRvcCA9IHNldFlvZ2FWYWx1ZSgncG9zaXRpb24nLCBZb2dhLkVkZ2UuVG9wKTtcbi8qKlxuICogU2V0IHBvc2l0aW9uIHJpZ2h0IGF0dHJpYnV0ZSB0byBub2RlJ3MgWW9nYSBpbnN0YW5jZVxuICpcbiAqIEBwYXJhbSBwb3NpdGlvbiAtIFBvc2l0aW9uIHJpZ2h0XG4gKiBAcGFyYW0gbm9kZSAtIE5vZGUgaW5zdGFuY2VcbiAqIEByZXR1cm5zIE5vZGUgaW5zdGFuY2VcbiAqL1xuY29uc3Qgc2V0UG9zaXRpb25SaWdodCA9IHNldFlvZ2FWYWx1ZSgncG9zaXRpb24nLCBZb2dhLkVkZ2UuUmlnaHQpO1xuLyoqXG4gKiBTZXQgcG9zaXRpb24gYm90dG9tIGF0dHJpYnV0ZSB0byBub2RlJ3MgWW9nYSBpbnN0YW5jZVxuICpcbiAqIEBwYXJhbSBwb3NpdGlvbiAtIFBvc2l0aW9uIGJvdHRvbVxuICogQHBhcmFtIG5vZGUgLSBOb2RlIGluc3RhbmNlXG4gKiBAcmV0dXJucyBOb2RlIGluc3RhbmNlXG4gKi9cbmNvbnN0IHNldFBvc2l0aW9uQm90dG9tID0gc2V0WW9nYVZhbHVlKCdwb3NpdGlvbicsIFlvZ2EuRWRnZS5Cb3R0b20pO1xuLyoqXG4gKiBTZXQgcG9zaXRpb24gbGVmdCBhdHRyaWJ1dGUgdG8gbm9kZSdzIFlvZ2EgaW5zdGFuY2VcbiAqXG4gKiBAcGFyYW0gcG9zaXRpb24gLSBQb3NpdGlvbiBsZWZ0XG4gKiBAcGFyYW0gbm9kZSAtIE5vZGUgaW5zdGFuY2VcbiAqIEByZXR1cm5zIE5vZGUgaW5zdGFuY2VcbiAqL1xuY29uc3Qgc2V0UG9zaXRpb25MZWZ0ID0gc2V0WW9nYVZhbHVlKCdwb3NpdGlvbicsIFlvZ2EuRWRnZS5MZWZ0KTtcblxuLyoqXG4gKiBTZXQgd2lkdGggdG8gbm9kZSdzIFlvZ2EgaW5zdGFuY2VcbiAqXG4gKiBAcGFyYW0gd2lkdGggLSBXaWR0aFxuICogQHBhcmFtIG5vZGUgLSBOb2RlIGluc3RhbmNlXG4gKiBAcmV0dXJucyBOb2RlIGluc3RhbmNlXG4gKi9cbmNvbnN0IHNldFdpZHRoID0gc2V0WW9nYVZhbHVlKCd3aWR0aCcpO1xuLyoqXG4gKiBTZXQgbWluIHdpZHRoIHRvIG5vZGUncyBZb2dhIGluc3RhbmNlXG4gKlxuICogQHBhcmFtIG1pbiAtIFdpZHRoXG4gKiBAcGFyYW0gbm9kZSAtIE5vZGUgaW5zdGFuY2VcbiAqIEByZXR1cm5zIE5vZGUgaW5zdGFuY2VcbiAqL1xuY29uc3Qgc2V0TWluV2lkdGggPSBzZXRZb2dhVmFsdWUoJ21pbldpZHRoJyk7XG4vKipcbiAqIFNldCBtYXggd2lkdGggdG8gbm9kZSdzIFlvZ2EgaW5zdGFuY2VcbiAqXG4gKiBAcGFyYW0gbWF4IC0gV2lkdGhcbiAqIEBwYXJhbSBub2RlIC0gTm9kZSBpbnN0YW5jZVxuICogQHJldHVybnMgTm9kZSBpbnN0YW5jZVxuICovXG5jb25zdCBzZXRNYXhXaWR0aCA9IHNldFlvZ2FWYWx1ZSgnbWF4V2lkdGgnKTtcbi8qKlxuICogU2V0IGhlaWdodCB0byBub2RlJ3MgWW9nYSBpbnN0YW5jZVxuICpcbiAqIEBwYXJhbSBoZWlnaHQgLSBIZWlnaHRcbiAqIEBwYXJhbSBub2RlIC0gTm9kZSBpbnN0YW5jZVxuICogQHJldHVybnMgTm9kZSBpbnN0YW5jZVxuICovXG5jb25zdCBzZXRIZWlnaHQgPSBzZXRZb2dhVmFsdWUoJ2hlaWdodCcpO1xuLyoqXG4gKiBTZXQgbWluIGhlaWdodCB0byBub2RlJ3MgWW9nYSBpbnN0YW5jZVxuICpcbiAqIEBwYXJhbSBtaW4gLSBIZWlnaHRcbiAqIEBwYXJhbSBub2RlIC0gTm9kZSBpbnN0YW5jZVxuICogQHJldHVybnMgTm9kZSBpbnN0YW5jZVxuICovXG5jb25zdCBzZXRNaW5IZWlnaHQgPSBzZXRZb2dhVmFsdWUoJ21pbkhlaWdodCcpO1xuLyoqXG4gKiBTZXQgbWF4IGhlaWdodCB0byBub2RlJ3MgWW9nYSBpbnN0YW5jZVxuICpcbiAqIEBwYXJhbSBtYXggLSBIZWlnaHRcbiAqIEBwYXJhbSBub2RlIC0gTm9kZSBpbnN0YW5jZVxuICogQHJldHVybnMgTm9kZSBpbnN0YW5jZVxuICovXG5jb25zdCBzZXRNYXhIZWlnaHQgPSBzZXRZb2dhVmFsdWUoJ21heEhlaWdodCcpO1xuXG4vKipcbiAqIFNldCByb3dHYXAgdmFsdWUgdG8gbm9kZSdzIFlvZ2EgaW5zdGFuY2VcbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBHYXAgdmFsdWVcbiAqIEByZXR1cm5zIE5vZGUgaW5zdGFuY2Ugd3JhcHBlclxuICovXG5jb25zdCBzZXRSb3dHYXAgPSBzZXRZb2dhVmFsdWUoJ2dhcCcsIFlvZ2EuR3V0dGVyLlJvdyk7XG4vKipcbiAqIFNldCBjb2x1bW5HYXAgdmFsdWUgdG8gbm9kZSdzIFlvZ2EgaW5zdGFuY2VcbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBHYXAgdmFsdWVcbiAqIEByZXR1cm5zIE5vZGUgaW5zdGFuY2Ugd3JhcHBlclxuICovXG5jb25zdCBzZXRDb2x1bW5HYXAgPSBzZXRZb2dhVmFsdWUoJ2dhcCcsIFlvZ2EuR3V0dGVyLkNvbHVtbik7XG5cbmNvbnN0IGdldEFzcGVjdFJhdGlvID0gKHZpZXdib3gpID0+IHtcbiAgICBpZiAoIXZpZXdib3gpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIGlmICh0eXBlb2Ygdmlld2JveCA9PT0gJ3N0cmluZycpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIHJldHVybiAodmlld2JveC5tYXhYIC0gdmlld2JveC5taW5YKSAvICh2aWV3Ym94Lm1heFkgLSB2aWV3Ym94Lm1pblkpO1xufTtcbi8qKlxuICogWW9nYSBzdmcgbWVhc3VyZSBmdW5jdGlvblxuICpcbiAqIEBwYXJhbSBwYWdlXG4gKiBAcGFyYW0gbm9kZVxuICogQHJldHVybnMgTWVhc3VyZSBzdmdcbiAqL1xuY29uc3QgbWVhc3VyZUNhbnZhcyQxID0gKHBhZ2UsIG5vZGUpID0+ICh3aWR0aCwgd2lkdGhNb2RlLCBoZWlnaHQsIGhlaWdodE1vZGUpID0+IHtcbiAgICBjb25zdCBhc3BlY3RSYXRpbyA9IGdldEFzcGVjdFJhdGlvKG5vZGUucHJvcHMudmlld0JveCkgfHwgMTtcbiAgICBpZiAod2lkdGhNb2RlID09PSBZb2dhLk1lYXN1cmVNb2RlLkV4YWN0bHkgfHxcbiAgICAgICAgd2lkdGhNb2RlID09PSBZb2dhLk1lYXN1cmVNb2RlLkF0TW9zdCkge1xuICAgICAgICByZXR1cm4geyB3aWR0aCwgaGVpZ2h0OiB3aWR0aCAvIGFzcGVjdFJhdGlvIH07XG4gICAgfVxuICAgIGlmIChoZWlnaHRNb2RlID09PSBZb2dhLk1lYXN1cmVNb2RlLkV4YWN0bHkpIHtcbiAgICAgICAgcmV0dXJuIHsgd2lkdGg6IGhlaWdodCAqIGFzcGVjdFJhdGlvIH07XG4gICAgfVxuICAgIHJldHVybiB7fTtcbn07XG5cbi8qKlxuICogR2V0IGxpbmVzIHdpZHRoIChpZiBhbnkpXG4gKlxuICogQHBhcmFtIG5vZGVcbiAqIEByZXR1cm5zIExpbmVzIHdpZHRoXG4gKi9cbmNvbnN0IGxpbmVzV2lkdGggPSAobm9kZSkgPT4ge1xuICAgIGlmICghbm9kZS5saW5lcylcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgcmV0dXJuIE1hdGgubWF4KDAsIC4uLm5vZGUubGluZXMubWFwKChsaW5lKSA9PiBsaW5lLnhBZHZhbmNlKSk7XG59O1xuXG4vKipcbiAqIEdldCBsaW5lcyBoZWlnaHQgKGlmIGFueSlcbiAqXG4gKiBAcGFyYW0gbm9kZVxuICogQHJldHVybnMgTGluZXMgaGVpZ2h0XG4gKi9cbmNvbnN0IGxpbmVzSGVpZ2h0ID0gKG5vZGUpID0+IHtcbiAgICBpZiAoIW5vZGUubGluZXMpXG4gICAgICAgIHJldHVybiAtMTtcbiAgICByZXR1cm4gbm9kZS5saW5lcy5yZWR1Y2UoKGFjYywgbGluZSkgPT4gYWNjICsgbGluZS5ib3guaGVpZ2h0LCAwKTtcbn07XG5cbmNvbnN0IEFMSUdOTUVOVF9GQUNUT1JTID0geyBjZW50ZXI6IDAuNSwgcmlnaHQ6IDEgfTtcbi8qKlxuICogWW9nYSB0ZXh0IG1lYXN1cmUgZnVuY3Rpb25cbiAqXG4gKiBAcGFyYW0gcGFnZVxuICogQHBhcmFtIG5vZGVcbiAqIEBwYXJhbSBmb250U3RvcmVcbiAqIEByZXR1cm5zIHtNZWFzdXJlVGV4dH0gbWVhc3VyZSB0ZXh0IGZ1bmN0aW9uXG4gKi9cbmNvbnN0IG1lYXN1cmVUZXh0ID0gKHBhZ2UsIG5vZGUsIGZvbnRTdG9yZSkgPT4gKHdpZHRoLCB3aWR0aE1vZGUsIGhlaWdodCkgPT4ge1xuICAgIGlmICh3aWR0aE1vZGUgPT09IFlvZ2EuTWVhc3VyZU1vZGUuRXhhY3RseSkge1xuICAgICAgICBpZiAoIW5vZGUubGluZXMpXG4gICAgICAgICAgICBub2RlLmxpbmVzID0gbGF5b3V0VGV4dChub2RlLCB3aWR0aCwgaGVpZ2h0LCBmb250U3RvcmUpO1xuICAgICAgICByZXR1cm4geyBoZWlnaHQ6IGxpbmVzSGVpZ2h0KG5vZGUpIH07XG4gICAgfVxuICAgIGlmICh3aWR0aE1vZGUgPT09IFlvZ2EuTWVhc3VyZU1vZGUuQXRNb3N0KSB7XG4gICAgICAgIGNvbnN0IGFsaWduRmFjdG9yID0gQUxJR05NRU5UX0ZBQ1RPUlNbbm9kZS5zdHlsZT8udGV4dEFsaWduXSB8fCAwO1xuICAgICAgICBpZiAoIW5vZGUubGluZXMpIHtcbiAgICAgICAgICAgIG5vZGUubGluZXMgPSBsYXlvdXRUZXh0KG5vZGUsIHdpZHRoLCBoZWlnaHQsIGZvbnRTdG9yZSk7XG4gICAgICAgICAgICBub2RlLmFsaWduT2Zmc2V0ID0gKHdpZHRoIC0gbGluZXNXaWR0aChub2RlKSkgKiBhbGlnbkZhY3RvcjsgLy8gQ29tcGVuc2F0ZSBhbGlnbiBpbiB2YXJpYWJsZSB3aWR0aCBjb250YWluZXJzXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGhlaWdodDogbGluZXNIZWlnaHQobm9kZSksXG4gICAgICAgICAgICB3aWR0aDogTWF0aC5taW4od2lkdGgsIGxpbmVzV2lkdGgobm9kZSkpLFxuICAgICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4ge307XG59O1xuXG4vKipcbiAqIEdldCBpbWFnZSByYXRpb1xuICpcbiAqIEBwYXJhbSBub2RlIC0gSW1hZ2Ugbm9kZVxuICogQHJldHVybnMgSW1hZ2UgcmF0aW9cbiAqL1xuY29uc3QgZ2V0UmF0aW8gPSAobm9kZSkgPT4ge1xuICAgIHJldHVybiBub2RlLmltYWdlPy5kYXRhID8gbm9kZS5pbWFnZS53aWR0aCAvIG5vZGUuaW1hZ2UuaGVpZ2h0IDogMTtcbn07XG5cbi8qKlxuICogQ2hlY2tzIGlmIHBhZ2UgaGFzIGF1dG8gaGVpZ2h0XG4gKlxuICogQHBhcmFtIHBhZ2VcbiAqIEByZXR1cm5zIElzIHBhZ2UgaGVpZ2h0IGF1dG9cbiAqL1xuY29uc3QgaXNIZWlnaHRBdXRvID0gKHBhZ2UpID0+IGlzTmlsKHBhZ2UuYm94Py5oZWlnaHQpO1xuXG5jb25zdCBTQUZFVFlfSEVJR0hUJDEgPSAxMDtcbi8qKlxuICogWW9nYSBpbWFnZSBtZWFzdXJlIGZ1bmN0aW9uXG4gKlxuICogQHBhcmFtIHBhZ2UgLSBQYWdlXG4gKiBAcGFyYW0gbm9kZSAtIE5vZGVcbiAqIEByZXR1cm5zIE1lYXN1cmUgaW1hZ2VcbiAqL1xuY29uc3QgbWVhc3VyZUltYWdlID0gKHBhZ2UsIG5vZGUpID0+ICh3aWR0aCwgd2lkdGhNb2RlLCBoZWlnaHQsIGhlaWdodE1vZGUpID0+IHtcbiAgICBjb25zdCBpbWFnZVJhdGlvID0gZ2V0UmF0aW8obm9kZSk7XG4gICAgY29uc3QgaW1hZ2VNYXJnaW4gPSBnZXRNYXJnaW4obm9kZSk7XG4gICAgY29uc3QgcGFnZVBhZGRpbmcgPSBnZXRQYWRkaW5nKHBhZ2UpO1xuICAgIC8vIFRPRE86IENoZWNrIGltYWdlIHBlcmNlbnRhZ2UgbWFyZ2luc1xuICAgIGNvbnN0IHBhZ2VBcmVhID0gaXNIZWlnaHRBdXRvKHBhZ2UpXG4gICAgICAgID8gSW5maW5pdHlcbiAgICAgICAgOiAocGFnZS5ib3g/LmhlaWdodCB8fCAwKSAtXG4gICAgICAgICAgICBwYWdlUGFkZGluZy5wYWRkaW5nVG9wIC1cbiAgICAgICAgICAgIHBhZ2VQYWRkaW5nLnBhZGRpbmdCb3R0b20gLVxuICAgICAgICAgICAgaW1hZ2VNYXJnaW4ubWFyZ2luVG9wIC1cbiAgICAgICAgICAgIGltYWdlTWFyZ2luLm1hcmdpbkJvdHRvbSAtXG4gICAgICAgICAgICBTQUZFVFlfSEVJR0hUJDE7XG4gICAgLy8gU2tpcCBtZWFzdXJlIGlmIGltYWdlIGRhdGEgbm90IHByZXNlbnQgeWV0XG4gICAgaWYgKCFub2RlLmltYWdlKVxuICAgICAgICByZXR1cm4geyB3aWR0aDogMCwgaGVpZ2h0OiAwIH07XG4gICAgaWYgKHdpZHRoTW9kZSA9PT0gWW9nYS5NZWFzdXJlTW9kZS5FeGFjdGx5ICYmXG4gICAgICAgIGhlaWdodE1vZGUgPT09IFlvZ2EuTWVhc3VyZU1vZGUuVW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnN0IHNjYWxlZEhlaWdodCA9IHdpZHRoIC8gaW1hZ2VSYXRpbztcbiAgICAgICAgcmV0dXJuIHsgaGVpZ2h0OiBNYXRoLm1pbihwYWdlQXJlYSwgc2NhbGVkSGVpZ2h0KSB9O1xuICAgIH1cbiAgICBpZiAoaGVpZ2h0TW9kZSA9PT0gWW9nYS5NZWFzdXJlTW9kZS5FeGFjdGx5ICYmXG4gICAgICAgICh3aWR0aE1vZGUgPT09IFlvZ2EuTWVhc3VyZU1vZGUuQXRNb3N0IHx8XG4gICAgICAgICAgICB3aWR0aE1vZGUgPT09IFlvZ2EuTWVhc3VyZU1vZGUuVW5kZWZpbmVkKSkge1xuICAgICAgICByZXR1cm4geyB3aWR0aDogTWF0aC5taW4oaGVpZ2h0ICogaW1hZ2VSYXRpbywgd2lkdGgpIH07XG4gICAgfVxuICAgIGlmICh3aWR0aE1vZGUgPT09IFlvZ2EuTWVhc3VyZU1vZGUuRXhhY3RseSAmJlxuICAgICAgICBoZWlnaHRNb2RlID09PSBZb2dhLk1lYXN1cmVNb2RlLkF0TW9zdCkge1xuICAgICAgICBjb25zdCBzY2FsZWRIZWlnaHQgPSB3aWR0aCAvIGltYWdlUmF0aW87XG4gICAgICAgIHJldHVybiB7IGhlaWdodDogTWF0aC5taW4oaGVpZ2h0LCBwYWdlQXJlYSwgc2NhbGVkSGVpZ2h0KSB9O1xuICAgIH1cbiAgICBpZiAod2lkdGhNb2RlID09PSBZb2dhLk1lYXN1cmVNb2RlLkF0TW9zdCAmJlxuICAgICAgICBoZWlnaHRNb2RlID09PSBZb2dhLk1lYXN1cmVNb2RlLkF0TW9zdCkge1xuICAgICAgICBpZiAoaW1hZ2VSYXRpbyA+IDEpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgd2lkdGgsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBNYXRoLm1pbih3aWR0aCAvIGltYWdlUmF0aW8sIGhlaWdodCksXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBoZWlnaHQsXG4gICAgICAgICAgICB3aWR0aDogTWF0aC5taW4oaGVpZ2h0ICogaW1hZ2VSYXRpbywgd2lkdGgpLFxuICAgICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4geyBoZWlnaHQsIHdpZHRoIH07XG59O1xuXG5jb25zdCBTQUZFVFlfSEVJR0hUID0gMTA7XG5jb25zdCBnZXRNYXggPSAodmFsdWVzKSA9PiBNYXRoLm1heCgtSW5maW5pdHksIC4uLnZhbHVlcyk7XG4vKipcbiAqIEhlbHBlciBvYmplY3QgdG8gcHJlZGljdCBjYW52YXMgc2l6ZVxuICogVE9ETzogSW1wbGVtZW50IHJlbWFpbmluZyBmdW5jdGlvbnMgKGFzIGNsb3NlIGFzIHBvc3NpYmxlKTtcbiAqL1xuY29uc3QgbWVhc3VyZUN0eCA9ICgpID0+IHtcbiAgICBjb25zdCBjdHggPSB7fTtcbiAgICBjb25zdCBwb2ludHMgPSBbXTtcbiAgICBjb25zdCBuaWwgPSAoKSA9PiBjdHg7XG4gICAgY29uc3QgYWRkUG9pbnQgPSAoeCwgeSkgPT4gcG9pbnRzLnB1c2goW3gsIHldKTtcbiAgICBjb25zdCBtb3ZlVG8gPSAoeCwgeSkgPT4ge1xuICAgICAgICBhZGRQb2ludCh4LCB5KTtcbiAgICAgICAgcmV0dXJuIGN0eDtcbiAgICB9O1xuICAgIGNvbnN0IHJlY3QgPSAoeCwgeSwgdywgaCkgPT4ge1xuICAgICAgICBhZGRQb2ludCh4LCB5KTtcbiAgICAgICAgYWRkUG9pbnQoeCArIHcsIHkpO1xuICAgICAgICBhZGRQb2ludCh4LCB5ICsgaCk7XG4gICAgICAgIGFkZFBvaW50KHggKyB3LCB5ICsgaCk7XG4gICAgICAgIHJldHVybiBjdHg7XG4gICAgfTtcbiAgICBjb25zdCBlbGxpcHNlID0gKHgsIHksIHJ4LCByeSkgPT4ge1xuICAgICAgICByeSA9IHJ5IHx8IHJ4O1xuICAgICAgICBhZGRQb2ludCh4IC0gcngsIHkgLSByeSk7XG4gICAgICAgIGFkZFBvaW50KHggKyByeCwgeSAtIHJ5KTtcbiAgICAgICAgYWRkUG9pbnQoeCArIHJ4LCB5ICsgcnkpO1xuICAgICAgICBhZGRQb2ludCh4IC0gcngsIHkgKyByeSk7XG4gICAgICAgIHJldHVybiBjdHg7XG4gICAgfTtcbiAgICBjb25zdCBwb2x5Z29uID0gKC4uLnB0cykgPT4ge1xuICAgICAgICBwb2ludHMucHVzaCguLi5wdHMpO1xuICAgICAgICByZXR1cm4gY3R4O1xuICAgIH07XG4gICAgLy8gQ2hhbmdlIGRpbWVuc2lvbnNcbiAgICBjdHgucmVjdCA9IHJlY3Q7XG4gICAgY3R4Lm1vdmVUbyA9IG1vdmVUbztcbiAgICBjdHgubGluZVRvID0gbW92ZVRvO1xuICAgIGN0eC5jaXJjbGUgPSBlbGxpcHNlO1xuICAgIGN0eC5wb2x5Z29uID0gcG9seWdvbjtcbiAgICBjdHguZWxsaXBzZSA9IGVsbGlwc2U7XG4gICAgY3R4LnJvdW5kZWRSZWN0ID0gcmVjdDtcbiAgICAvLyBUbyBiZSBpbXBsZW1lbnRlZFxuICAgIGN0eC50ZXh0ID0gbmlsO1xuICAgIGN0eC5wYXRoID0gbmlsO1xuICAgIGN0eC5saW5lV2lkdGggPSBuaWw7XG4gICAgY3R4LmJlemllckN1cnZlVG8gPSBuaWw7XG4gICAgY3R4LnF1YWRyYXRpY0N1cnZlVG8gPSBuaWw7XG4gICAgY3R4LnNjYWxlID0gbmlsO1xuICAgIGN0eC5yb3RhdGUgPSBuaWw7XG4gICAgY3R4LnRyYW5zbGF0ZSA9IG5pbDtcbiAgICAvLyBUaGVzZSBkb24ndCBjaGFuZ2UgZGltZW5zaW9uc1xuICAgIGN0eC5kYXNoID0gbmlsO1xuICAgIGN0eC5jbGlwID0gbmlsO1xuICAgIGN0eC5zYXZlID0gbmlsO1xuICAgIGN0eC5maWxsID0gbmlsO1xuICAgIGN0eC5mb250ID0gbmlsO1xuICAgIGN0eC5zdHJva2UgPSBuaWw7XG4gICAgY3R4LmxpbmVDYXAgPSBuaWw7XG4gICAgY3R4Lm9wYWNpdHkgPSBuaWw7XG4gICAgY3R4LnJlc3RvcmUgPSBuaWw7XG4gICAgY3R4LmxpbmVKb2luID0gbmlsO1xuICAgIGN0eC5mb250U2l6ZSA9IG5pbDtcbiAgICBjdHguZmlsbENvbG9yID0gbmlsO1xuICAgIGN0eC5taXRlckxpbWl0ID0gbmlsO1xuICAgIGN0eC5zdHJva2VDb2xvciA9IG5pbDtcbiAgICBjdHguZmlsbE9wYWNpdHkgPSBuaWw7XG4gICAgY3R4LnN0cm9rZU9wYWNpdHkgPSBuaWw7XG4gICAgY3R4LmxpbmVhckdyYWRpZW50ID0gbmlsO1xuICAgIGN0eC5yYWRpYWxHcmFkaWVudCA9IG5pbDtcbiAgICBjdHguZ2V0V2lkdGggPSAoKSA9PiBnZXRNYXgocG9pbnRzLm1hcCgocCkgPT4gcFswXSkpO1xuICAgIGN0eC5nZXRIZWlnaHQgPSAoKSA9PiBnZXRNYXgocG9pbnRzLm1hcCgocCkgPT4gcFsxXSkpO1xuICAgIHJldHVybiBjdHg7XG59O1xuLyoqXG4gKiBAdHlwZWRlZiB7RnVuY3Rpb259IE1lYXN1cmVDYW52YXNcbiAqIEByZXR1cm5zIHt7IHdpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyIH19IGNhbnZhcyB3aWR0aCBhbmQgaGVpZ2h0XG4gKi9cbi8qKlxuICogWW9nYSBjYW52YXMgbWVhc3VyZSBmdW5jdGlvblxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYWdlXG4gKiBAcGFyYW0ge09iamVjdH0gbm9kZVxuICogQHJldHVybnMge01lYXN1cmVDYW52YXN9IG1lYXN1cmUgY2FudmFzXG4gKi9cbmNvbnN0IG1lYXN1cmVDYW52YXMgPSAocGFnZSwgbm9kZSkgPT4gKCkgPT4ge1xuICAgIGNvbnN0IGltYWdlTWFyZ2luID0gZ2V0TWFyZ2luKG5vZGUpO1xuICAgIGNvbnN0IHBhZ2VQYWRkaW5nID0gZ2V0UGFkZGluZyhwYWdlKTtcbiAgICAvLyBUT0RPOiBDaGVjayBpbWFnZSBwZXJjZW50YWdlIG1hcmdpbnNcbiAgICBjb25zdCBwYWdlQXJlYSA9IGlzSGVpZ2h0QXV0byhwYWdlKVxuICAgICAgICA/IEluZmluaXR5XG4gICAgICAgIDogKHBhZ2UuYm94Py5oZWlnaHQgfHwgMCkgLVxuICAgICAgICAgICAgcGFnZVBhZGRpbmcucGFkZGluZ1RvcCAtXG4gICAgICAgICAgICBwYWdlUGFkZGluZy5wYWRkaW5nQm90dG9tIC1cbiAgICAgICAgICAgIGltYWdlTWFyZ2luLm1hcmdpblRvcCAtXG4gICAgICAgICAgICBpbWFnZU1hcmdpbi5tYXJnaW5Cb3R0b20gLVxuICAgICAgICAgICAgU0FGRVRZX0hFSUdIVDtcbiAgICBjb25zdCBjdHggPSBtZWFzdXJlQ3R4KCk7XG4gICAgbm9kZS5wcm9wcy5wYWludChjdHgpO1xuICAgIGNvbnN0IHdpZHRoID0gY3R4LmdldFdpZHRoKCk7XG4gICAgY29uc3QgaGVpZ2h0ID0gTWF0aC5taW4ocGFnZUFyZWEsIGN0eC5nZXRIZWlnaHQoKSk7XG4gICAgcmV0dXJuIHsgd2lkdGgsIGhlaWdodCB9O1xufTtcblxuY29uc3QgaXNUeXBlJDEgPSAodHlwZSkgPT4gKG5vZGUpID0+IG5vZGUudHlwZSA9PT0gdHlwZTtcbmNvbnN0IGlzU3ZnID0gaXNUeXBlJDEoUC5TdmcpO1xuY29uc3QgaXNUZXh0JDIgPSBpc1R5cGUkMShQLlRleHQpO1xuY29uc3QgaXNOb3RlID0gaXNUeXBlJDEoUC5Ob3RlKTtcbmNvbnN0IGlzUGFnZSA9IGlzVHlwZSQxKFAuUGFnZSk7XG5jb25zdCBpc0ltYWdlID0gaXNUeXBlJDEoUC5JbWFnZSk7XG5jb25zdCBpc0NhbnZhcyA9IGlzVHlwZSQxKFAuQ2FudmFzKTtcbmNvbnN0IGlzVGV4dEluc3RhbmNlJDEgPSBpc1R5cGUkMShQLlRleHRJbnN0YW5jZSk7XG5jb25zdCBzZXROb2RlSGVpZ2h0ID0gKG5vZGUpID0+IHtcbiAgICBjb25zdCB2YWx1ZSA9IGlzUGFnZShub2RlKSA/IG5vZGUuYm94Py5oZWlnaHQgOiBub2RlLnN0eWxlPy5oZWlnaHQ7XG4gICAgcmV0dXJuIHNldEhlaWdodCh2YWx1ZSk7XG59O1xuLyoqXG4gKiBTZXQgc3R5bGVzIHZhbGV1cyBpbnRvIHlvZ2Egbm9kZSBiZWZvcmUgbGF5b3V0IGNhbGN1bGF0aW9uXG4gKlxuICogQHBhcmFtIG5vZGVcbiAqL1xuY29uc3Qgc2V0WW9nYVZhbHVlcyA9IChub2RlKSA9PiB7XG4gICAgY29tcG9zZShzZXROb2RlSGVpZ2h0KG5vZGUpLCBzZXRXaWR0aChub2RlLnN0eWxlLndpZHRoKSwgc2V0TWluV2lkdGgobm9kZS5zdHlsZS5taW5XaWR0aCksIHNldE1heFdpZHRoKG5vZGUuc3R5bGUubWF4V2lkdGgpLCBzZXRNaW5IZWlnaHQobm9kZS5zdHlsZS5taW5IZWlnaHQpLCBzZXRNYXhIZWlnaHQobm9kZS5zdHlsZS5tYXhIZWlnaHQpLCBzZXRNYXJnaW5Ub3Aobm9kZS5zdHlsZS5tYXJnaW5Ub3ApLCBzZXRNYXJnaW5SaWdodChub2RlLnN0eWxlLm1hcmdpblJpZ2h0KSwgc2V0TWFyZ2luQm90dG9tKG5vZGUuc3R5bGUubWFyZ2luQm90dG9tKSwgc2V0TWFyZ2luTGVmdChub2RlLnN0eWxlLm1hcmdpbkxlZnQpLCBzZXRQYWRkaW5nVG9wKG5vZGUuc3R5bGUucGFkZGluZ1RvcCksIHNldFBhZGRpbmdSaWdodChub2RlLnN0eWxlLnBhZGRpbmdSaWdodCksIHNldFBhZGRpbmdCb3R0b20obm9kZS5zdHlsZS5wYWRkaW5nQm90dG9tKSwgc2V0UGFkZGluZ0xlZnQobm9kZS5zdHlsZS5wYWRkaW5nTGVmdCksIHNldFBvc2l0aW9uVHlwZShub2RlLnN0eWxlLnBvc2l0aW9uKSwgc2V0UG9zaXRpb25Ub3Aobm9kZS5zdHlsZS50b3ApLCBzZXRQb3NpdGlvblJpZ2h0KG5vZGUuc3R5bGUucmlnaHQpLCBzZXRQb3NpdGlvbkJvdHRvbShub2RlLnN0eWxlLmJvdHRvbSksIHNldFBvc2l0aW9uTGVmdChub2RlLnN0eWxlLmxlZnQpLCBzZXRCb3JkZXJUb3Aobm9kZS5zdHlsZS5ib3JkZXJUb3BXaWR0aCksIHNldEJvcmRlclJpZ2h0KG5vZGUuc3R5bGUuYm9yZGVyUmlnaHRXaWR0aCksIHNldEJvcmRlckJvdHRvbShub2RlLnN0eWxlLmJvcmRlckJvdHRvbVdpZHRoKSwgc2V0Qm9yZGVyTGVmdChub2RlLnN0eWxlLmJvcmRlckxlZnRXaWR0aCksIHNldERpc3BsYXkobm9kZS5zdHlsZS5kaXNwbGF5KSwgc2V0RmxleERpcmVjdGlvbihub2RlLnN0eWxlLmZsZXhEaXJlY3Rpb24pLCBzZXRBbGlnblNlbGYobm9kZS5zdHlsZS5hbGlnblNlbGYpLCBzZXRBbGlnbkNvbnRlbnQobm9kZS5zdHlsZS5hbGlnbkNvbnRlbnQpLCBzZXRBbGlnbkl0ZW1zKG5vZGUuc3R5bGUuYWxpZ25JdGVtcyksIHNldEp1c3RpZnlDb250ZW50KG5vZGUuc3R5bGUuanVzdGlmeUNvbnRlbnQpLCBzZXRGbGV4V3JhcChub2RlLnN0eWxlLmZsZXhXcmFwKSwgc2V0T3ZlcmZsb3cobm9kZS5zdHlsZS5vdmVyZmxvdyksIHNldEFzcGVjdFJhdGlvKG5vZGUuc3R5bGUuYXNwZWN0UmF0aW8pLCBzZXRGbGV4QmFzaXMobm9kZS5zdHlsZS5mbGV4QmFzaXMpLCBzZXRGbGV4R3Jvdyhub2RlLnN0eWxlLmZsZXhHcm93KSwgc2V0RmxleFNocmluayhub2RlLnN0eWxlLmZsZXhTaHJpbmspLCBzZXRSb3dHYXAobm9kZS5zdHlsZS5yb3dHYXApLCBzZXRDb2x1bW5HYXAobm9kZS5zdHlsZS5jb2x1bW5HYXApKShub2RlKTtcbn07XG4vKipcbiAqIEluc2VydHMgY2hpbGQgaW50byBwYXJlbnQnIHlvZ2Egbm9kZVxuICpcbiAqIEBwYXJhbSBwYXJlbnQgcGFyZW50XG4gKiBAcmV0dXJucyBJbnNlcnQgeW9nYSBub2Rlc1xuICovXG5jb25zdCBpbnNlcnRZb2dhTm9kZXMgPSAocGFyZW50KSA9PiAoY2hpbGQpID0+IHtcbiAgICBwYXJlbnQuaW5zZXJ0Q2hpbGQoY2hpbGQueW9nYU5vZGUsIHBhcmVudC5nZXRDaGlsZENvdW50KCkpO1xuICAgIHJldHVybiBjaGlsZDtcbn07XG5jb25zdCBzZXRNZWFzdXJlRnVuYyA9IChub2RlLCBwYWdlLCBmb250U3RvcmUpID0+IHtcbiAgICBjb25zdCB7IHlvZ2FOb2RlIH0gPSBub2RlO1xuICAgIGlmIChpc1RleHQkMihub2RlKSkge1xuICAgICAgICB5b2dhTm9kZS5zZXRNZWFzdXJlRnVuYyhtZWFzdXJlVGV4dChwYWdlLCBub2RlLCBmb250U3RvcmUpKTtcbiAgICB9XG4gICAgaWYgKGlzSW1hZ2Uobm9kZSkpIHtcbiAgICAgICAgeW9nYU5vZGUuc2V0TWVhc3VyZUZ1bmMobWVhc3VyZUltYWdlKHBhZ2UsIG5vZGUpKTtcbiAgICB9XG4gICAgaWYgKGlzQ2FudmFzKG5vZGUpKSB7XG4gICAgICAgIHlvZ2FOb2RlLnNldE1lYXN1cmVGdW5jKG1lYXN1cmVDYW52YXMocGFnZSwgbm9kZSkpO1xuICAgIH1cbiAgICBpZiAoaXNTdmcobm9kZSkpIHtcbiAgICAgICAgeW9nYU5vZGUuc2V0TWVhc3VyZUZ1bmMobWVhc3VyZUNhbnZhcyQxKHBhZ2UsIG5vZGUpKTtcbiAgICB9XG4gICAgcmV0dXJuIG5vZGU7XG59O1xuY29uc3QgaXNMYXlvdXRFbGVtZW50ID0gKG5vZGUpID0+ICFpc1RleHQkMihub2RlKSAmJiAhaXNOb3RlKG5vZGUpICYmICFpc1N2Zyhub2RlKTtcbi8qKlxuICogQHR5cGVkZWYge0Z1bmN0aW9ufSBDcmVhdGVZb2dhTm9kZXNcbiAqIEBwYXJhbSB7T2JqZWN0fSBub2RlXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBub2RlIHdpdGggYXBwZW5kZWQgeW9nYSBub2RlXG4gKi9cbi8qKlxuICogQ3JlYXRlcyBhbmQgYWRkIHlvZ2Egbm9kZSB0byBkb2N1bWVudCB0cmVlXG4gKiBIYW5kbGVzIG1lYXN1cmUgZnVuY3Rpb24gZm9yIHRleHQgYW5kIGltYWdlIG5vZGVzXG4gKlxuICogQHJldHVybnMgQ3JlYXRlIHlvZ2Egbm9kZXNcbiAqL1xuY29uc3QgY3JlYXRlWW9nYU5vZGVzID0gKHBhZ2UsIGZvbnRTdG9yZSwgeW9nYSkgPT4gKG5vZGUpID0+IHtcbiAgICBjb25zdCB5b2dhTm9kZSA9IHlvZ2Eubm9kZS5jcmVhdGUoKTtcbiAgICBjb25zdCByZXN1bHQgPSBPYmplY3QuYXNzaWduKHt9LCBub2RlLCB7IHlvZ2FOb2RlIH0pO1xuICAgIHNldFlvZ2FWYWx1ZXMocmVzdWx0KTtcbiAgICBpZiAoaXNMYXlvdXRFbGVtZW50KG5vZGUpICYmIG5vZGUuY2hpbGRyZW4pIHtcbiAgICAgICAgY29uc3QgcmVzb2x2ZUNoaWxkID0gY29tcG9zZShpbnNlcnRZb2dhTm9kZXMoeW9nYU5vZGUpLCBjcmVhdGVZb2dhTm9kZXMocGFnZSwgZm9udFN0b3JlLCB5b2dhKSk7XG4gICAgICAgIHJlc3VsdC5jaGlsZHJlbiA9IG5vZGUuY2hpbGRyZW4ubWFwKHJlc29sdmVDaGlsZCk7XG4gICAgfVxuICAgIHNldE1lYXN1cmVGdW5jKHJlc3VsdCwgcGFnZSwgZm9udFN0b3JlKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbi8qKlxuICogUGVyZm9ybXMgeW9nYSBjYWxjdWxhdGlvblxuICpcbiAqIEBwYXJhbSBwYWdlIC0gUGFnZSBub2RlXG4gKiBAcmV0dXJucyBQYWdlIG5vZGVcbiAqL1xuY29uc3QgY2FsY3VsYXRlTGF5b3V0ID0gKHBhZ2UpID0+IHtcbiAgICBwYWdlLnlvZ2FOb2RlLmNhbGN1bGF0ZUxheW91dCgpO1xuICAgIHJldHVybiBwYWdlO1xufTtcbi8qKlxuICogU2F2ZXMgWW9nYSBsYXlvdXQgcmVzdWx0IGludG8gJ2JveCcgYXR0cmlidXRlIG9mIG5vZGVcbiAqXG4gKiBAcGFyYW0gbm9kZVxuICogQHJldHVybnMgTm9kZSB3aXRoIGJveCBkYXRhXG4gKi9cbmNvbnN0IHBlcnNpc3REaW1lbnNpb25zID0gKG5vZGUpID0+IHtcbiAgICBpZiAoaXNUZXh0SW5zdGFuY2UkMShub2RlKSlcbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgY29uc3QgYm94ID0gT2JqZWN0LmFzc2lnbihnZXRQYWRkaW5nKG5vZGUpLCBnZXRNYXJnaW4obm9kZSksIGdldEJvcmRlcldpZHRoKG5vZGUpLCBnZXRQb3NpdGlvbihub2RlKSwgZ2V0RGltZW5zaW9uKG5vZGUpKTtcbiAgICBjb25zdCBuZXdOb2RlID0gT2JqZWN0LmFzc2lnbih7fSwgbm9kZSwgeyBib3ggfSk7XG4gICAgaWYgKCFub2RlLmNoaWxkcmVuKVxuICAgICAgICByZXR1cm4gbmV3Tm9kZTtcbiAgICBjb25zdCBjaGlsZHJlbiA9IG5vZGUuY2hpbGRyZW4ubWFwKHBlcnNpc3REaW1lbnNpb25zKTtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgbmV3Tm9kZSwgeyBjaGlsZHJlbiB9KTtcbn07XG4vKipcbiAqIFJlbW92ZXMgeW9nYSBub2RlIGZyb20gZG9jdW1lbnQgdHJlZVxuICpcbiAqIEBwYXJhbSBub2RlXG4gKiBAcmV0dXJucyBOb2RlIHdpdGhvdXQgeW9nYSBub2RlXG4gKi9cbmNvbnN0IGRlc3Ryb3lZb2dhTm9kZXMgPSAobm9kZSkgPT4ge1xuICAgIGNvbnN0IG5ld05vZGUgPSBPYmplY3QuYXNzaWduKHt9LCBub2RlKTtcbiAgICBkZWxldGUgbmV3Tm9kZS55b2dhTm9kZTtcbiAgICBpZiAoIW5vZGUuY2hpbGRyZW4pXG4gICAgICAgIHJldHVybiBuZXdOb2RlO1xuICAgIGNvbnN0IGNoaWxkcmVuID0gbm9kZS5jaGlsZHJlbi5tYXAoZGVzdHJveVlvZ2FOb2Rlcyk7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIG5ld05vZGUsIHsgY2hpbGRyZW4gfSk7XG59O1xuLyoqXG4gKiBGcmVlIHlvZ2Egbm9kZSBmcm9tIGRvY3VtZW50IHRyZWVcbiAqXG4gKiBAcGFyYW0gbm9kZVxuICogQHJldHVybnMgTm9kZSB3aXRob3V0IHlvZ2Egbm9kZVxuICovXG5jb25zdCBmcmVlWW9nYU5vZGVzID0gKG5vZGUpID0+IHtcbiAgICBpZiAobm9kZS55b2dhTm9kZSlcbiAgICAgICAgbm9kZS55b2dhTm9kZS5mcmVlUmVjdXJzaXZlKCk7XG4gICAgcmV0dXJuIG5vZGU7XG59O1xuLyoqXG4gKiBDYWxjdWxhdGVzIHBhZ2Ugb2JqZWN0IGxheW91dCB1c2luZyBZb2dhLlxuICogVGFrZXMgbm9kZSB2YWx1ZXMgZnJvbSAnYm94JyBhbmQgJ3N0eWxlJyBhdHRyaWJ1dGVzLCBhbmQgcGVyc2lzdCB0aGVtIGJhY2sgaW50byAnYm94J1xuICogRGVzdHJveSB5b2dhIHZhbHVlcyBhdCB0aGUgZW5kLlxuICpcbiAqIEBwYXJhbSBwYWdlIC0gT2JqZWN0XG4gKiBAcmV0dXJucyBQYWdlIG9iamVjdCB3aXRoIGNvcnJlY3QgJ2JveCcgbGF5b3V0IGF0dHJpYnV0ZXNcbiAqL1xuY29uc3QgcmVzb2x2ZVBhZ2VEaW1lbnNpb25zID0gKHBhZ2UsIGZvbnRTdG9yZSwgeW9nYSkgPT4ge1xuICAgIGlmIChpc05pbChwYWdlKSlcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgcmV0dXJuIGNvbXBvc2UoZGVzdHJveVlvZ2FOb2RlcywgZnJlZVlvZ2FOb2RlcywgcGVyc2lzdERpbWVuc2lvbnMsIGNhbGN1bGF0ZUxheW91dCwgY3JlYXRlWW9nYU5vZGVzKHBhZ2UsIGZvbnRTdG9yZSwgeW9nYSkpKHBhZ2UpO1xufTtcbi8qKlxuICogQ2FsY3VsYXRlcyByb290IG9iamVjdCBsYXlvdXQgdXNpbmcgWW9nYS5cbiAqXG4gKiBAcGFyYW0gbm9kZSAtIFJvb3Qgb2JqZWN0XG4gKiBAcGFyYW0gZm9udFN0b3JlIC0gRm9udCBzdG9yZVxuICogQHJldHVybnMgUm9vdCBvYmplY3Qgd2l0aCBjb3JyZWN0ICdib3gnIGxheW91dCBhdHRyaWJ1dGVzXG4gKi9cbmNvbnN0IHJlc29sdmVEaW1lbnNpb25zID0gKG5vZGUsIGZvbnRTdG9yZSkgPT4ge1xuICAgIGlmICghbm9kZS5jaGlsZHJlbilcbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgY29uc3QgcmVzb2x2ZUNoaWxkID0gKGNoaWxkKSA9PiByZXNvbHZlUGFnZURpbWVuc2lvbnMoY2hpbGQsIGZvbnRTdG9yZSwgbm9kZS55b2dhKTtcbiAgICBjb25zdCBjaGlsZHJlbiA9IG5vZGUuY2hpbGRyZW4ubWFwKHJlc29sdmVDaGlsZCk7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIG5vZGUsIHsgY2hpbGRyZW4gfSk7XG59O1xuXG5jb25zdCBpc1RleHQkMSA9IChub2RlKSA9PiBub2RlLnR5cGUgPT09IFAuVGV4dDtcbi8vIFByZXZlbnQgc3BsaXR0aW5nIGVsZW1lbnRzIGJ5IGxvdyBkZWNpbWFsIG51bWJlcnNcbmNvbnN0IFNBRkVUWV9USFJFU0hPTEQgPSAwLjAwMTtcbmNvbnN0IGFzc2luZ0NoaWxkcmVuID0gKGNoaWxkcmVuLCBub2RlKSA9PiBPYmplY3QuYXNzaWduKHt9LCBub2RlLCB7IGNoaWxkcmVuIH0pO1xuY29uc3QgZ2V0VG9wID0gKG5vZGUpID0+IG5vZGUuYm94Py50b3AgfHwgMDtcbmNvbnN0IGFsbEZpeGVkID0gKG5vZGVzKSA9PiBub2Rlcy5ldmVyeShpc0ZpeGVkKTtcbmNvbnN0IGlzRHluYW1pYyA9IChub2RlKSA9PiBub2RlLnByb3BzICYmICdyZW5kZXInIGluIG5vZGUucHJvcHM7XG5jb25zdCByZWxheW91dFBhZ2UgPSBjb21wb3NlKHJlc29sdmVUZXh0TGF5b3V0LCByZXNvbHZlUGFnZURpbWVuc2lvbnMsIHJlc29sdmVJbmhlcml0YW5jZSwgcmVzb2x2ZVBhZ2VTdHlsZXMpO1xuY29uc3Qgd2FyblVuYXZhaWxhYmxlU3BhY2UgPSAobm9kZSkgPT4ge1xuICAgIGNvbnNvbGUud2FybihgTm9kZSBvZiB0eXBlICR7bm9kZS50eXBlfSBjYW4ndCB3cmFwIGJldHdlZW4gcGFnZXMgYW5kIGl0J3MgYmlnZ2VyIHRoYW4gYXZhaWxhYmxlIHBhZ2UgaGVpZ2h0YCk7XG59O1xuY29uc3Qgc3BsaXROb2RlcyA9IChoZWlnaHQsIGNvbnRlbnRBcmVhLCBub2RlcykgPT4ge1xuICAgIGNvbnN0IGN1cnJlbnRDaGlsZHJlbiA9IFtdO1xuICAgIGNvbnN0IG5leHRDaGlsZHJlbiA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgY29uc3QgY2hpbGQgPSBub2Rlc1tpXTtcbiAgICAgICAgY29uc3QgZnV0dXJlTm9kZXMgPSBub2Rlcy5zbGljZShpICsgMSk7XG4gICAgICAgIGNvbnN0IGZ1dHVyZUZpeGVkTm9kZXMgPSBmdXR1cmVOb2Rlcy5maWx0ZXIoaXNGaXhlZCk7XG4gICAgICAgIGNvbnN0IG5vZGVUb3AgPSBnZXRUb3AoY2hpbGQpO1xuICAgICAgICBjb25zdCBub2RlSGVpZ2h0ID0gY2hpbGQuYm94LmhlaWdodDtcbiAgICAgICAgY29uc3QgaXNPdXRzaWRlID0gaGVpZ2h0IDw9IG5vZGVUb3A7XG4gICAgICAgIGNvbnN0IHNob3VsZEJyZWFrJDEgPSBzaG91bGRCcmVhayhjaGlsZCwgZnV0dXJlTm9kZXMsIGhlaWdodCk7XG4gICAgICAgIGNvbnN0IHNob3VsZFNwbGl0ID0gaGVpZ2h0ICsgU0FGRVRZX1RIUkVTSE9MRCA8IG5vZGVUb3AgKyBub2RlSGVpZ2h0O1xuICAgICAgICBjb25zdCBjYW5XcmFwID0gZ2V0V3JhcChjaGlsZCk7XG4gICAgICAgIGNvbnN0IGZpdHNJbnNpZGVQYWdlID0gbm9kZUhlaWdodCA8PSBjb250ZW50QXJlYTtcbiAgICAgICAgaWYgKGlzRml4ZWQoY2hpbGQpKSB7XG4gICAgICAgICAgICBuZXh0Q2hpbGRyZW4ucHVzaChjaGlsZCk7XG4gICAgICAgICAgICBjdXJyZW50Q2hpbGRyZW4ucHVzaChjaGlsZCk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNPdXRzaWRlKSB7XG4gICAgICAgICAgICBjb25zdCBib3ggPSBPYmplY3QuYXNzaWduKHt9LCBjaGlsZC5ib3gsIHsgdG9wOiBjaGlsZC5ib3gudG9wIC0gaGVpZ2h0IH0pO1xuICAgICAgICAgICAgY29uc3QgbmV4dCA9IE9iamVjdC5hc3NpZ24oe30sIGNoaWxkLCB7IGJveCB9KTtcbiAgICAgICAgICAgIG5leHRDaGlsZHJlbi5wdXNoKG5leHQpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFmaXRzSW5zaWRlUGFnZSAmJiAhY2FuV3JhcCkge1xuICAgICAgICAgICAgY3VycmVudENoaWxkcmVuLnB1c2goY2hpbGQpO1xuICAgICAgICAgICAgbmV4dENoaWxkcmVuLnB1c2goLi4uZnV0dXJlTm9kZXMpO1xuICAgICAgICAgICAgd2FyblVuYXZhaWxhYmxlU3BhY2UoY2hpbGQpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNob3VsZEJyZWFrJDEpIHtcbiAgICAgICAgICAgIGNvbnN0IGJveCA9IE9iamVjdC5hc3NpZ24oe30sIGNoaWxkLmJveCwgeyB0b3A6IGNoaWxkLmJveC50b3AgLSBoZWlnaHQgfSk7XG4gICAgICAgICAgICBjb25zdCBwcm9wcyA9IE9iamVjdC5hc3NpZ24oe30sIGNoaWxkLnByb3BzLCB7XG4gICAgICAgICAgICAgICAgd3JhcDogdHJ1ZSxcbiAgICAgICAgICAgICAgICBicmVhazogZmFsc2UsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IG5leHQgPSBPYmplY3QuYXNzaWduKHt9LCBjaGlsZCwgeyBib3gsIHByb3BzIH0pO1xuICAgICAgICAgICAgY3VycmVudENoaWxkcmVuLnB1c2goLi4uZnV0dXJlRml4ZWROb2Rlcyk7XG4gICAgICAgICAgICBuZXh0Q2hpbGRyZW4ucHVzaChuZXh0LCAuLi5mdXR1cmVOb2Rlcyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2hvdWxkU3BsaXQpIHtcbiAgICAgICAgICAgIGNvbnN0IFtjdXJyZW50Q2hpbGQsIG5leHRDaGlsZF0gPSBzcGxpdChjaGlsZCwgaGVpZ2h0LCBjb250ZW50QXJlYSk7XG4gICAgICAgICAgICAvLyBBbGwgY2hpbGRyZW4gYXJlIG1vdmVkIHRvIHRoZSBuZXh0IHBhZ2UsIGl0IGRvZXNuJ3QgbWFrZSBzZW5zZSB0byBzaG93IHRoZSBwYXJlbnQgb24gdGhlIGN1cnJlbnQgcGFnZVxuICAgICAgICAgICAgaWYgKGNoaWxkLmNoaWxkcmVuLmxlbmd0aCA+IDAgJiYgY3VycmVudENoaWxkLmNoaWxkcmVuLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIC8vIEJ1dCBpZiB0aGUgY3VycmVudCBwYWdlIGlzIGVtcHR5IHRoZW4gd2UgY2FuIGp1c3QgaW5jbHVkZSB0aGUgcGFyZW50IG9uIHRoZSBjdXJyZW50IHBhZ2VcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudENoaWxkcmVuLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50Q2hpbGRyZW4ucHVzaChjaGlsZCwgLi4uZnV0dXJlRml4ZWROb2Rlcyk7XG4gICAgICAgICAgICAgICAgICAgIG5leHRDaGlsZHJlbi5wdXNoKC4uLmZ1dHVyZU5vZGVzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGJveCA9IE9iamVjdC5hc3NpZ24oe30sIGNoaWxkLmJveCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgdG9wOiBjaGlsZC5ib3gudG9wIC0gaGVpZ2h0LFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV4dCA9IE9iamVjdC5hc3NpZ24oe30sIGNoaWxkLCB7IGJveCB9KTtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudENoaWxkcmVuLnB1c2goLi4uZnV0dXJlRml4ZWROb2Rlcyk7XG4gICAgICAgICAgICAgICAgICAgIG5leHRDaGlsZHJlbi5wdXNoKG5leHQsIC4uLmZ1dHVyZU5vZGVzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY3VycmVudENoaWxkKVxuICAgICAgICAgICAgICAgIGN1cnJlbnRDaGlsZHJlbi5wdXNoKGN1cnJlbnRDaGlsZCk7XG4gICAgICAgICAgICBpZiAobmV4dENoaWxkKVxuICAgICAgICAgICAgICAgIG5leHRDaGlsZHJlbi5wdXNoKG5leHRDaGlsZCk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjdXJyZW50Q2hpbGRyZW4ucHVzaChjaGlsZCk7XG4gICAgfVxuICAgIHJldHVybiBbY3VycmVudENoaWxkcmVuLCBuZXh0Q2hpbGRyZW5dO1xufTtcbmNvbnN0IHNwbGl0Q2hpbGRyZW4gPSAoaGVpZ2h0LCBjb250ZW50QXJlYSwgbm9kZSkgPT4ge1xuICAgIGNvbnN0IGNoaWxkcmVuID0gbm9kZS5jaGlsZHJlbiB8fCBbXTtcbiAgICBjb25zdCBhdmFpbGFibGVIZWlnaHQgPSBoZWlnaHQgLSBnZXRUb3Aobm9kZSk7XG4gICAgcmV0dXJuIHNwbGl0Tm9kZXMoYXZhaWxhYmxlSGVpZ2h0LCBjb250ZW50QXJlYSwgY2hpbGRyZW4pO1xufTtcbmNvbnN0IHNwbGl0VmlldyA9IChub2RlLCBoZWlnaHQsIGNvbnRlbnRBcmVhKSA9PiB7XG4gICAgY29uc3QgW2N1cnJlbnROb2RlLCBuZXh0Tm9kZV0gPSBzcGxpdE5vZGUobm9kZSwgaGVpZ2h0KTtcbiAgICBjb25zdCBbY3VycmVudENoaWxkcywgbmV4dENoaWxkcmVuXSA9IHNwbGl0Q2hpbGRyZW4oaGVpZ2h0LCBjb250ZW50QXJlYSwgbm9kZSk7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgYXNzaW5nQ2hpbGRyZW4oY3VycmVudENoaWxkcywgY3VycmVudE5vZGUpLFxuICAgICAgICBhc3NpbmdDaGlsZHJlbihuZXh0Q2hpbGRyZW4sIG5leHROb2RlKSxcbiAgICBdO1xufTtcbmNvbnN0IHNwbGl0ID0gKG5vZGUsIGhlaWdodCwgY29udGVudEFyZWEpID0+IGlzVGV4dCQxKG5vZGUpID8gc3BsaXRUZXh0KG5vZGUsIGhlaWdodCkgOiBzcGxpdFZpZXcobm9kZSwgaGVpZ2h0LCBjb250ZW50QXJlYSk7XG5jb25zdCBzaG91bGRSZXNvbHZlRHluYW1pY05vZGVzID0gKG5vZGUpID0+IHtcbiAgICBjb25zdCBjaGlsZHJlbiA9IG5vZGUuY2hpbGRyZW4gfHwgW107XG4gICAgcmV0dXJuIGlzRHluYW1pYyhub2RlKSB8fCBjaGlsZHJlbi5zb21lKHNob3VsZFJlc29sdmVEeW5hbWljTm9kZXMpO1xufTtcbmNvbnN0IHJlc29sdmVEeW5hbWljTm9kZXMgPSAocHJvcHMsIG5vZGUpID0+IHtcbiAgICBjb25zdCBpc05vZGVEeW5hbWljID0gaXNEeW5hbWljKG5vZGUpO1xuICAgIC8vIENhbGwgcmVuZGVyIHByb3Agb24gZHluYW1pYyBub2RlcyBhbmQgYXBwZW5kIHJlc3VsdCB0byBjaGlsZHJlblxuICAgIGNvbnN0IHJlc29sdmVDaGlsZHJlbiA9IChjaGlsZHJlbiA9IFtdKSA9PiB7XG4gICAgICAgIGlmIChpc05vZGVEeW5hbWljKSB7XG4gICAgICAgICAgICBjb25zdCByZXMgPSBub2RlLnByb3BzLnJlbmRlcihwcm9wcyk7XG4gICAgICAgICAgICByZXR1cm4gKGNyZWF0ZUluc3RhbmNlcyhyZXMpXG4gICAgICAgICAgICAgICAgLmZpbHRlcihCb29sZWFuKVxuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgcmV3b3JrIGR5bmFtaWMgbm9kZXMuIGNvbmZsaWN0aW5nIHR5cGVzXG4gICAgICAgICAgICAgICAgLm1hcCgobikgPT4gcmVzb2x2ZUR5bmFtaWNOb2Rlcyhwcm9wcywgbikpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2hpbGRyZW4ubWFwKChjKSA9PiByZXNvbHZlRHluYW1pY05vZGVzKHByb3BzLCBjKSk7XG4gICAgfTtcbiAgICAvLyBXZSByZXNldCBkeW5hbWljIHRleHQgYm94IHNvIGl0IGNhbiBiZSBjb21wdXRlZCBhZ2FpbiBsYXRlciBvblxuICAgIGNvbnN0IHJlc2V0SGVpZ2h0ID0gaXNOb2RlRHluYW1pYyAmJiBpc1RleHQkMShub2RlKTtcbiAgICBjb25zdCBib3ggPSByZXNldEhlaWdodCA/IHsgLi4ubm9kZS5ib3gsIGhlaWdodDogMCB9IDogbm9kZS5ib3g7XG4gICAgY29uc3QgY2hpbGRyZW4gPSByZXNvbHZlQ2hpbGRyZW4obm9kZS5jaGlsZHJlbik7XG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvciBoYW5kbGUgdGV4dCBoZXJlIHNwZWNpZmljYWxseVxuICAgIGNvbnN0IGxpbmVzID0gaXNOb2RlRHluYW1pYyA/IG51bGwgOiBub2RlLmxpbmVzO1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBub2RlLCB7IGJveCwgbGluZXMsIGNoaWxkcmVuIH0pO1xufTtcbmNvbnN0IHJlc29sdmVEeW5hbWljUGFnZSA9IChwcm9wcywgcGFnZSwgZm9udFN0b3JlLCB5b2dhKSA9PiB7XG4gICAgaWYgKHNob3VsZFJlc29sdmVEeW5hbWljTm9kZXMocGFnZSkpIHtcbiAgICAgICAgY29uc3QgcmVzb2x2ZWRQYWdlID0gcmVzb2x2ZUR5bmFtaWNOb2Rlcyhwcm9wcywgcGFnZSk7XG4gICAgICAgIHJldHVybiByZWxheW91dFBhZ2UocmVzb2x2ZWRQYWdlLCBmb250U3RvcmUsIHlvZ2EpO1xuICAgIH1cbiAgICByZXR1cm4gcGFnZTtcbn07XG5jb25zdCBzcGxpdFBhZ2UgPSAocGFnZSwgcGFnZU51bWJlciwgZm9udFN0b3JlLCB5b2dhKSA9PiB7XG4gICAgY29uc3Qgd3JhcEFyZWEgPSBnZXRXcmFwQXJlYShwYWdlKTtcbiAgICBjb25zdCBjb250ZW50QXJlYSA9IGdldENvbnRlbnRBcmVhKHBhZ2UpO1xuICAgIGNvbnN0IGR5bmFtaWNQYWdlID0gcmVzb2x2ZUR5bmFtaWNQYWdlKHsgcGFnZU51bWJlciB9LCBwYWdlLCBmb250U3RvcmUsIHlvZ2EpO1xuICAgIGNvbnN0IGhlaWdodCA9IHBhZ2Uuc3R5bGUuaGVpZ2h0O1xuICAgIGNvbnN0IFtjdXJyZW50Q2hpbGRzLCBuZXh0Q2hpbGRzXSA9IHNwbGl0Tm9kZXMod3JhcEFyZWEsIGNvbnRlbnRBcmVhLCBkeW5hbWljUGFnZS5jaGlsZHJlbik7XG4gICAgY29uc3QgcmVsYXlvdXQgPSAobm9kZSkgPT4gXG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvciByZXdvcmsgcGFnaW5hdGlvblxuICAgIHJlbGF5b3V0UGFnZShub2RlLCBmb250U3RvcmUsIHlvZ2EpO1xuICAgIGNvbnN0IGN1cnJlbnRCb3ggPSB7IC4uLnBhZ2UuYm94LCBoZWlnaHQgfTtcbiAgICBjb25zdCBjdXJyZW50UGFnZSA9IHJlbGF5b3V0KE9iamVjdC5hc3NpZ24oe30sIHBhZ2UsIHsgYm94OiBjdXJyZW50Qm94LCBjaGlsZHJlbjogY3VycmVudENoaWxkcyB9KSk7XG4gICAgaWYgKG5leHRDaGlsZHMubGVuZ3RoID09PSAwIHx8IGFsbEZpeGVkKG5leHRDaGlsZHMpKVxuICAgICAgICByZXR1cm4gW2N1cnJlbnRQYWdlLCBudWxsXTtcbiAgICBjb25zdCBuZXh0Qm94ID0gb21pdCgnaGVpZ2h0JywgcGFnZS5ib3gpO1xuICAgIGNvbnN0IG5leHRQcm9wcyA9IG9taXQoJ2Jvb2ttYXJrJywgcGFnZS5wcm9wcyk7XG4gICAgY29uc3QgbmV4dFBhZ2UgPSByZWxheW91dChPYmplY3QuYXNzaWduKHt9LCBwYWdlLCB7XG4gICAgICAgIHByb3BzOiBuZXh0UHJvcHMsXG4gICAgICAgIGJveDogbmV4dEJveCxcbiAgICAgICAgY2hpbGRyZW46IG5leHRDaGlsZHMsXG4gICAgfSkpO1xuICAgIHJldHVybiBbY3VycmVudFBhZ2UsIG5leHRQYWdlXTtcbn07XG5jb25zdCByZXNvbHZlUGFnZUluZGljZXMgPSAoZm9udFN0b3JlLCB5b2dhLCBwYWdlLCBwYWdlTnVtYmVyLCBwYWdlcykgPT4ge1xuICAgIGNvbnN0IHRvdGFsUGFnZXMgPSBwYWdlcy5sZW5ndGg7XG4gICAgY29uc3QgcHJvcHMgPSB7XG4gICAgICAgIHRvdGFsUGFnZXMsXG4gICAgICAgIHBhZ2VOdW1iZXI6IHBhZ2VOdW1iZXIgKyAxLFxuICAgICAgICBzdWJQYWdlTnVtYmVyOiBwYWdlLnN1YlBhZ2VOdW1iZXIgKyAxLFxuICAgICAgICBzdWJQYWdlVG90YWxQYWdlczogcGFnZS5zdWJQYWdlVG90YWxQYWdlcyxcbiAgICB9O1xuICAgIHJldHVybiByZXNvbHZlRHluYW1pY1BhZ2UocHJvcHMsIHBhZ2UsIGZvbnRTdG9yZSwgeW9nYSk7XG59O1xuY29uc3QgYXNzb2NTdWJQYWdlRGF0YSA9IChzdWJwYWdlcykgPT4ge1xuICAgIHJldHVybiBzdWJwYWdlcy5tYXAoKHBhZ2UsIGkpID0+ICh7XG4gICAgICAgIC4uLnBhZ2UsXG4gICAgICAgIHN1YlBhZ2VOdW1iZXI6IGksXG4gICAgICAgIHN1YlBhZ2VUb3RhbFBhZ2VzOiBzdWJwYWdlcy5sZW5ndGgsXG4gICAgfSkpO1xufTtcbmNvbnN0IGRpc3NvY1N1YlBhZ2VEYXRhID0gKHBhZ2UpID0+IHtcbiAgICByZXR1cm4gb21pdChbJ3N1YlBhZ2VOdW1iZXInLCAnc3ViUGFnZVRvdGFsUGFnZXMnXSwgcGFnZSk7XG59O1xuY29uc3QgcGFnaW5hdGUgPSAocGFnZSwgcGFnZU51bWJlciwgZm9udFN0b3JlLCB5b2dhKSA9PiB7XG4gICAgaWYgKCFwYWdlKVxuICAgICAgICByZXR1cm4gW107XG4gICAgaWYgKHBhZ2UucHJvcHM/LndyYXAgPT09IGZhbHNlKVxuICAgICAgICByZXR1cm4gW3BhZ2VdO1xuICAgIGxldCBzcGxpdHRlZFBhZ2UgPSBzcGxpdFBhZ2UocGFnZSwgcGFnZU51bWJlciwgZm9udFN0b3JlLCB5b2dhKTtcbiAgICBjb25zdCBwYWdlcyA9IFtzcGxpdHRlZFBhZ2VbMF1dO1xuICAgIGxldCBuZXh0UGFnZSA9IHNwbGl0dGVkUGFnZVsxXTtcbiAgICB3aGlsZSAobmV4dFBhZ2UgIT09IG51bGwpIHtcbiAgICAgICAgc3BsaXR0ZWRQYWdlID0gc3BsaXRQYWdlKG5leHRQYWdlLCBwYWdlTnVtYmVyICsgcGFnZXMubGVuZ3RoLCBmb250U3RvcmUsIHlvZ2EpO1xuICAgICAgICBwYWdlcy5wdXNoKHNwbGl0dGVkUGFnZVswXSk7XG4gICAgICAgIG5leHRQYWdlID0gc3BsaXR0ZWRQYWdlWzFdO1xuICAgIH1cbiAgICByZXR1cm4gcGFnZXM7XG59O1xuLyoqXG4gKiBQZXJmb3JtcyBwYWdpbmF0aW9uLiBUaGlzIGlzIHRoZSBzdGVwIHJlc3BvbnNpYmxlIG9mIGJyZWFraW5nIHRoZSB3aG9sZSBkb2N1bWVudFxuICogaW50byBwYWdlcyBmb2xsb3dpbmcgcGFnaWF0aW9uIHJ1bGVzLCBzdWNoIGFzIGBmaXhlZGAsIGBicmVha2AgYW5kIGR5bmFtaWMgbm9kZXMuXG4gKlxuICogQHBhcmFtIHJvb3QgLSBEb2N1bWVudCBub2RlXG4gKiBAcGFyYW0gZm9udFN0b3JlIC0gRm9udCBzdG9yZVxuICogQHJldHVybnMgTGF5b3V0IG5vZGVcbiAqL1xuY29uc3QgcmVzb2x2ZVBhZ2luYXRpb24gPSAocm9vdCwgZm9udFN0b3JlKSA9PiB7XG4gICAgbGV0IHBhZ2VzID0gW107XG4gICAgbGV0IHBhZ2VOdW1iZXIgPSAxO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcm9vdC5jaGlsZHJlbi5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBjb25zdCBwYWdlID0gcm9vdC5jaGlsZHJlbltpXTtcbiAgICAgICAgbGV0IHN1YnBhZ2VzID0gcGFnaW5hdGUocGFnZSwgcGFnZU51bWJlciwgZm9udFN0b3JlLCByb290LnlvZ2EpO1xuICAgICAgICBzdWJwYWdlcyA9IGFzc29jU3ViUGFnZURhdGEoc3VicGFnZXMpO1xuICAgICAgICBwYWdlTnVtYmVyICs9IHN1YnBhZ2VzLmxlbmd0aDtcbiAgICAgICAgcGFnZXMgPSBwYWdlcy5jb25jYXQoc3VicGFnZXMpO1xuICAgIH1cbiAgICBwYWdlcyA9IHBhZ2VzLm1hcCgoLi4uYXJncykgPT4gZGlzc29jU3ViUGFnZURhdGEocmVzb2x2ZVBhZ2VJbmRpY2VzKGZvbnRTdG9yZSwgcm9vdC55b2dhLCAuLi5hcmdzKSkpO1xuICAgIHJldHVybiBhc3NpbmdDaGlsZHJlbihwYWdlcywgcm9vdCk7XG59O1xuXG4vKipcbiAqIFRyYW5zbGF0ZXMgcGFnZSBwZXJjZW50YWdlIGhvcml6b250YWwgcGFkZGluZ3MgaW4gZml4ZWQgb25lc1xuICpcbiAqIEBwYXJhbSBjb250YWluZXIgLSBQYWdlIGNvbnRhaW5lclxuICogQHJldHVybnMgUmVzb2x2ZSBwYWdlIGhvcml6b250YWwgcGFkZGluZ1xuICovXG5jb25zdCByZXNvbHZlUGFnZUhvcml6b250YWxQYWRkaW5nID0gKGNvbnRhaW5lcikgPT4gKHZhbHVlKSA9PiB7XG4gICAgY29uc3QgbWF0Y2ggPSBtYXRjaFBlcmNlbnQodmFsdWUpO1xuICAgIGNvbnN0IHdpZHRoID0gY29udGFpbmVyLndpZHRoO1xuICAgIHJldHVybiBtYXRjaCA/IG1hdGNoLnBlcmNlbnQgKiB3aWR0aCA6IHZhbHVlO1xufTtcbi8qKlxuICogVHJhbnNsYXRlcyBwYWdlIHBlcmNlbnRhZ2UgdmVydGljYWwgcGFkZGluZ3MgaW4gZml4ZWQgb25lc1xuICpcbiAqIEBwYXJhbSBjb250YWluZXIgLSBQYWdlIGNvbnRhaW5lclxuICogQHJldHVybnMgUmVzb2x2ZSBwYWdlIHZlcnRpY2FsIHBhZGRpbmdcbiAqL1xuY29uc3QgcmVzb2x2ZVBhZ2VWZXJ0aWNhbFBhZGRpbmcgPSAoY29udGFpbmVyKSA9PiAodmFsdWUpID0+IHtcbiAgICBjb25zdCBtYXRjaCA9IG1hdGNoUGVyY2VudCh2YWx1ZSk7XG4gICAgY29uc3QgaGVpZ2h0ID0gY29udGFpbmVyLmhlaWdodDtcbiAgICByZXR1cm4gbWF0Y2ggPyBtYXRjaC5wZXJjZW50ICogaGVpZ2h0IDogdmFsdWU7XG59O1xuLyoqXG4gKiBUcmFuc2xhdGVzIHBhZ2UgcGVyY2VudGFnZSBwYWRkaW5ncyBpbiBmaXhlZCBvbmVzXG4gKlxuICogQHBhcmFtIHBhZ2VcbiAqIEByZXR1cm5zIFBhZ2Ugd2l0aCBmaXhlZCBwYWRkaW5nc1xuICovXG5jb25zdCByZXNvbHZlUGFnZVBhZGRpbmdzID0gKHBhZ2UpID0+IHtcbiAgICBjb25zdCBjb250YWluZXIgPSBwYWdlLnN0eWxlO1xuICAgIGNvbnN0IHN0eWxlID0gZXZvbHZlKHtcbiAgICAgICAgcGFkZGluZ1RvcDogcmVzb2x2ZVBhZ2VWZXJ0aWNhbFBhZGRpbmcoY29udGFpbmVyKSxcbiAgICAgICAgcGFkZGluZ0xlZnQ6IHJlc29sdmVQYWdlSG9yaXpvbnRhbFBhZGRpbmcoY29udGFpbmVyKSxcbiAgICAgICAgcGFkZGluZ1JpZ2h0OiByZXNvbHZlUGFnZUhvcml6b250YWxQYWRkaW5nKGNvbnRhaW5lciksXG4gICAgICAgIHBhZGRpbmdCb3R0b206IHJlc29sdmVQYWdlVmVydGljYWxQYWRkaW5nKGNvbnRhaW5lciksXG4gICAgfSwgcGFnZS5zdHlsZSk7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIHBhZ2UsIHsgc3R5bGUgfSk7XG59O1xuLyoqXG4gKiBUcmFuc2xhdGVzIGFsbCBwYWdlcyBwZXJjZW50YWdlIHBhZGRpbmdzIGluIGZpeGVkIG9uZXNcbiAqIFRoaXMgaGFzIHRvIGJlIGNvbXB1dGVkIGZyb20gcGFnZXMgY2FsY3VsYXRlZCBzaXplIGFuZCBub3QgYnkgWW9nYVxuICogYmVjYXVzZSBhdCB0aGlzIHBvaW50IHdlIGRpZG4ndCBwZXJmb3JtZWQgcGFnaW5hdGlvbiB5ZXQuXG4gKlxuICogQHBhcmFtIHJvb3QgLSBEb2N1bWVudCByb290XG4gKiBAcmV0dXJucyBEb2N1bWVudCByb290IHdpdGggdHJhbnNsYXRlZCBwYWdlIHBhZGRpbmdzXG4gKi9cbmNvbnN0IHJlc29sdmVQYWdlc1BhZGRpbmdzID0gKHJvb3QpID0+IHtcbiAgICBpZiAoIXJvb3QuY2hpbGRyZW4pXG4gICAgICAgIHJldHVybiByb290O1xuICAgIGNvbnN0IGNoaWxkcmVuID0gcm9vdC5jaGlsZHJlbi5tYXAocmVzb2x2ZVBhZ2VQYWRkaW5ncyk7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIHJvb3QsIHsgY2hpbGRyZW4gfSk7XG59O1xuXG5jb25zdCByZXNvbHZlUmFkaXVzID0gKGJveCkgPT4gKHZhbHVlKSA9PiB7XG4gICAgaWYgKCF2YWx1ZSlcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICBjb25zdCBtYXRjaCA9IG1hdGNoUGVyY2VudCh2YWx1ZSk7XG4gICAgcmV0dXJuIG1hdGNoID8gbWF0Y2gucGVyY2VudCAqIE1hdGgubWluKGJveC53aWR0aCwgYm94LmhlaWdodCkgOiB2YWx1ZTtcbn07XG4vKipcbiAqIFRyYW5zZm9ybXMgcGVyY2VudCBib3JkZXIgcmFkaXVzIGludG8gZml4ZWQgdmFsdWVzXG4gKlxuICogQHBhcmFtIG5vZGVcbiAqIEByZXR1cm5zIE5vZGVcbiAqL1xuY29uc3QgcmVzb2x2ZVBlcmNlbnRSYWRpdXMgPSAobm9kZSkgPT4ge1xuICAgIGNvbnN0IHN0eWxlID0gZXZvbHZlKHtcbiAgICAgICAgYm9yZGVyVG9wTGVmdFJhZGl1czogcmVzb2x2ZVJhZGl1cyhub2RlLmJveCksXG4gICAgICAgIGJvcmRlclRvcFJpZ2h0UmFkaXVzOiByZXNvbHZlUmFkaXVzKG5vZGUuYm94KSxcbiAgICAgICAgYm9yZGVyQm90dG9tUmlnaHRSYWRpdXM6IHJlc29sdmVSYWRpdXMobm9kZS5ib3gpLFxuICAgICAgICBib3JkZXJCb3R0b21MZWZ0UmFkaXVzOiByZXNvbHZlUmFkaXVzKG5vZGUuYm94KSxcbiAgICB9LCBub2RlLnN0eWxlIHx8IHt9KTtcbiAgICBjb25zdCBuZXdOb2RlID0gT2JqZWN0LmFzc2lnbih7fSwgbm9kZSwgeyBzdHlsZSB9KTtcbiAgICBpZiAoIW5vZGUuY2hpbGRyZW4pXG4gICAgICAgIHJldHVybiBuZXdOb2RlO1xuICAgIGNvbnN0IGNoaWxkcmVuID0gbm9kZS5jaGlsZHJlbi5tYXAocmVzb2x2ZVBlcmNlbnRSYWRpdXMpO1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBuZXdOb2RlLCB7IGNoaWxkcmVuIH0pO1xufTtcblxuLyoqXG4gKiBUcmFuc2Zvcm0gcGVyY2VudCBoZWlnaHQgaW50byBmaXhlZFxuICpcbiAqIEBwYXJhbSBoZWlnaHRcbiAqIEByZXR1cm5zIEhlaWdodFxuICovXG5jb25zdCB0cmFuc2Zvcm1IZWlnaHQgPSAocGFnZUFyZWEsIGhlaWdodCkgPT4ge1xuICAgIGNvbnN0IG1hdGNoID0gbWF0Y2hQZXJjZW50KGhlaWdodCk7XG4gICAgcmV0dXJuIG1hdGNoID8gbWF0Y2gucGVyY2VudCAqIHBhZ2VBcmVhIDogaGVpZ2h0O1xufTtcbi8qKlxuICogR2V0IHBhZ2UgYXJlYSAoaGVpZ2h0IG1pbnVzIHBhZGRpbmdzKVxuICpcbiAqIEBwYXJhbSBwYWdlXG4gKiBAcmV0dXJucyBQYWdlIGFyZWFcbiAqL1xuY29uc3QgZ2V0UGFnZUFyZWEgPSAocGFnZSkgPT4ge1xuICAgIGNvbnN0IHBhZ2VIZWlnaHQgPSBwYWdlLnN0eWxlLmhlaWdodDtcbiAgICBjb25zdCBwYWdlUGFkZGluZ1RvcCA9IChwYWdlLnN0eWxlPy5wYWRkaW5nVG9wIHx8IDApO1xuICAgIGNvbnN0IHBhZ2VQYWRkaW5nQm90dG9tID0gKHBhZ2Uuc3R5bGU/LnBhZGRpbmdCb3R0b20gfHwgMCk7XG4gICAgcmV0dXJuIHBhZ2VIZWlnaHQgLSBwYWdlUGFkZGluZ1RvcCAtIHBhZ2VQYWRkaW5nQm90dG9tO1xufTtcbi8qKlxuICogVHJhbnNmb3JtIG5vZGUgcGVyY2VudCBoZWlnaHQgdG8gZml4ZWRcbiAqXG4gKiBAcGFyYW0gcGFnZVxuICogQHBhcmFtIG5vZGVcbiAqIEByZXR1cm5zIFRyYW5zZm9ybWVkIG5vZGVcbiAqL1xuY29uc3QgcmVzb2x2ZU5vZGVQZXJjZW50SGVpZ2h0ID0gKHBhZ2UsIG5vZGUpID0+IHtcbiAgICBpZiAoaXNOaWwocGFnZS5zdHlsZT8uaGVpZ2h0KSlcbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgaWYgKGlzTmlsKG5vZGUuc3R5bGU/LmhlaWdodCkpXG4gICAgICAgIHJldHVybiBub2RlO1xuICAgIGNvbnN0IHBhZ2VBcmVhID0gZ2V0UGFnZUFyZWEocGFnZSk7XG4gICAgY29uc3QgaGVpZ2h0ID0gdHJhbnNmb3JtSGVpZ2h0KHBhZ2VBcmVhLCBub2RlLnN0eWxlLmhlaWdodCk7XG4gICAgY29uc3Qgc3R5bGUgPSBPYmplY3QuYXNzaWduKHt9LCBub2RlLnN0eWxlLCB7IGhlaWdodCB9KTtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgbm9kZSwgeyBzdHlsZSB9KTtcbn07XG4vKipcbiAqIFRyYW5zZm9ybSBwYWdlIGltbWVkaWF0ZSBjaGlsZHJlbiB3aXRoIHBlcmNlbnQgaGVpZ2h0IHRvIGZpeGVkXG4gKlxuICogQHBhcmFtIHBhZ2VcbiAqIEByZXR1cm5zIFRyYW5zZm9ybWVkIHBhZ2VcbiAqL1xuY29uc3QgcmVzb2x2ZVBhZ2VQZXJjZW50SGVpZ2h0ID0gKHBhZ2UpID0+IHtcbiAgICBpZiAoIXBhZ2UuY2hpbGRyZW4pXG4gICAgICAgIHJldHVybiBwYWdlO1xuICAgIGNvbnN0IHJlc29sdmVDaGlsZCA9IChjaGlsZCkgPT4gcmVzb2x2ZU5vZGVQZXJjZW50SGVpZ2h0KHBhZ2UsIGNoaWxkKTtcbiAgICBjb25zdCBjaGlsZHJlbiA9IHBhZ2UuY2hpbGRyZW4ubWFwKHJlc29sdmVDaGlsZCk7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIHBhZ2UsIHsgY2hpbGRyZW4gfSk7XG59O1xuLyoqXG4gKiBUcmFuc2Zvcm0gYWxsIHBhZ2UgaW1tZWRpYXRlIGNoaWxkcmVuIHdpdGggcGVyY2VudCBoZWlnaHQgdG8gZml4ZWQuXG4gKiBUaGlzIGlzIG5lZWRlZCBmb3IgY29tcHV0aW5nIGNvcnJlY3QgZGltZW5zaW9ucyBvbiBwcmUtcGFnaW5hdGlvbiBsYXlvdXQuXG4gKlxuICogQHBhcmFtIHJvb3QgLSBEb2N1bWVudCByb290XG4gKiBAcmV0dXJucyBUcmFuc2Zvcm1lZCBkb2N1bWVudCByb290XG4gKi9cbmNvbnN0IHJlc29sdmVQZXJjZW50SGVpZ2h0ID0gKHJvb3QpID0+IHtcbiAgICBpZiAoIXJvb3QuY2hpbGRyZW4pXG4gICAgICAgIHJldHVybiByb290O1xuICAgIGNvbnN0IGNoaWxkcmVuID0gcm9vdC5jaGlsZHJlbi5tYXAocmVzb2x2ZVBhZ2VQZXJjZW50SGVpZ2h0KTtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgcm9vdCwgeyBjaGlsZHJlbiB9KTtcbn07XG5cbmNvbnN0IGlzVHlwZSA9ICh0eXBlKSA9PiAobm9kZSkgPT4gbm9kZS50eXBlID09PSB0eXBlO1xuY29uc3QgaXNMaW5rID0gaXNUeXBlKFAuTGluayk7XG5jb25zdCBpc1RleHQgPSBpc1R5cGUoUC5UZXh0KTtcbmNvbnN0IGlzVGV4dEluc3RhbmNlID0gaXNUeXBlKFAuVGV4dEluc3RhbmNlKTtcbi8qKlxuICogQ2hlY2tzIGlmIG5vZGUgaGFzIHJlbmRlciBwcm9wXG4gKlxuICogQHBhcmFtIG5vZGVcbiAqIEByZXR1cm5zIEhhcyByZW5kZXIgcHJvcD9cbiAqL1xuY29uc3QgaGFzUmVuZGVyUHJvcCA9IChub2RlKSA9PiAncmVuZGVyJyBpbiBub2RlLnByb3BzO1xuLyoqXG4gKiBDaGVja3MgaWYgbm9kZSBpcyB0ZXh0IHR5cGUgKFRleHQgb3IgVGV4dEluc3RhbmNlKVxuICpcbiAqIEBwYXJhbSBub2RlXG4gKiBAcmV0dXJucyBBcmUgYWxsIGNoaWxkcmVuIHRleHQgaW5zdGFuY2VzP1xuICovXG5jb25zdCBpc1RleHRUeXBlID0gKG5vZGUpID0+IGlzVGV4dChub2RlKSB8fCBpc1RleHRJbnN0YW5jZShub2RlKTtcbi8qKlxuICogQ2hlY2tzIGlmIGlzIHRldCBsaW5rIHRoYXQgbmVlZHMgdG8gYmUgd3JhcHBlZCBpbiBUZXh0XG4gKlxuICogQHBhcmFtIG5vZGVcbiAqIEByZXR1cm5zIEFyZSBhbGwgY2hpbGRyZW4gdGV4dCBpbnN0YW5jZXM/XG4gKi9cbmNvbnN0IGlzVGV4dExpbmsgPSAobm9kZSkgPT4ge1xuICAgIGNvbnN0IGNoaWxkcmVuID0gbm9kZS5jaGlsZHJlbiB8fCBbXTtcbiAgICAvLyBUZXh0IHN0cmluZyBpbnNpZGUgYSBMaW5rXG4gICAgaWYgKGNoaWxkcmVuLmV2ZXJ5KGlzVGV4dEluc3RhbmNlKSlcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgLy8gVGV4dCBub2RlIGluc2lkZSBhIExpbmtcbiAgICBpZiAoY2hpbGRyZW4uZXZlcnkoaXNUZXh0KSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiBjaGlsZHJlbi5ldmVyeShpc1RleHRUeXBlKTtcbn07XG4vKipcbiAqIFdyYXBzIG5vZGUgY2hpbGRyZW4gaW5zaWRlIFRleHQgbm9kZVxuICpcbiAqIEBwYXJhbSBub2RlXG4gKiBAcmV0dXJucyBOb2RlIHdpdGggaW50ZXJtZWRpYXRlIFRleHQgY2hpbGRcbiAqL1xuY29uc3Qgd3JhcFRleHQgPSAobm9kZSkgPT4ge1xuICAgIGNvbnN0IHRleHRFbGVtZW50ID0ge1xuICAgICAgICB0eXBlOiBQLlRleHQsXG4gICAgICAgIHByb3BzOiB7fSxcbiAgICAgICAgc3R5bGU6IHt9LFxuICAgICAgICBib3g6IHt9LFxuICAgICAgICBjaGlsZHJlbjogbm9kZS5jaGlsZHJlbixcbiAgICB9O1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBub2RlLCB7IGNoaWxkcmVuOiBbdGV4dEVsZW1lbnRdIH0pO1xufTtcbmNvbnN0IHRyYW5zZm9ybUxpbmsgPSAobm9kZSkgPT4ge1xuICAgIGlmICghaXNMaW5rKG5vZGUpKVxuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAvLyBJZiBoYXMgcmVuZGVyIHByb3Agc3Vic3RpdHV0ZSB0aGUgaW5zdGFuY2UgYnkgYSBUZXh0LCB0aGF0IHdpbGxcbiAgICAvLyB1bHRpbWF0ZWx5IHJlbmRlciB0aGUgaW5saW5lIExpbmsgdmlhIHRoZSB0ZXh0a2l0IFBERiByZW5kZXJlci5cbiAgICBpZiAoaGFzUmVuZGVyUHJvcChub2RlKSlcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIG5vZGUsIHsgdHlwZTogUC5UZXh0IH0pO1xuICAgIC8vIElmIGlzIGEgdGV4dCBsaW5rIChlaXRoZXIgY29udGFpbnMgVGV4dCBvciBUZXh0SW5zdGFuY2UpLCB3cmFwIGl0XG4gICAgLy8gaW5zaWRlIGEgVGV4dCBlbGVtZW50IHNvIHN0eWxlcyBhcmUgYXBwbGllZCBjb3JyZWN0bHlcbiAgICBpZiAoaXNUZXh0TGluayhub2RlKSlcbiAgICAgICAgcmV0dXJuIHdyYXBUZXh0KG5vZGUpO1xuICAgIHJldHVybiBub2RlO1xufTtcbi8qKlxuICogVHJhbnNmb3JtcyBMaW5rIGxheW91dCB0byBjb3JyZWN0bHkgcmVuZGVyIHRleHQgYW5kIGR5bmFtaWMgcmVuZGVyZWQgbGlua3NcbiAqXG4gKiBAcGFyYW0gbm9kZVxuICogQHJldHVybnMgTm9kZSB3aXRoIGxpbmsgc3Vic3RpdHV0aW9uXG4gKi9cbmNvbnN0IHJlc29sdmVMaW5rU3Vic3RpdHV0aW9uID0gKG5vZGUpID0+IHtcbiAgICBpZiAoIW5vZGUuY2hpbGRyZW4pXG4gICAgICAgIHJldHVybiBub2RlO1xuICAgIGNvbnN0IHJlc29sdmVDaGlsZCA9IGNvbXBvc2UodHJhbnNmb3JtTGluaywgcmVzb2x2ZUxpbmtTdWJzdGl0dXRpb24pO1xuICAgIGNvbnN0IGNoaWxkcmVuID0gbm9kZS5jaGlsZHJlbi5tYXAocmVzb2x2ZUNoaWxkKTtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgbm9kZSwgeyBjaGlsZHJlbiB9KTtcbn07XG5cbmNvbnN0IGxheW91dCA9IGFzeW5jQ29tcG9zZShyZXNvbHZlWkluZGV4LCByZXNvbHZlT3JpZ2luLCByZXNvbHZlQXNzZXRzLCByZXNvbHZlUGFnaW5hdGlvbiwgcmVzb2x2ZVRleHRMYXlvdXQsIHJlc29sdmVQZXJjZW50UmFkaXVzLCByZXNvbHZlRGltZW5zaW9ucywgcmVzb2x2ZVN2ZywgcmVzb2x2ZUFzc2V0cywgcmVzb2x2ZUluaGVyaXRhbmNlLCByZXNvbHZlUGVyY2VudEhlaWdodCwgcmVzb2x2ZVBhZ2VzUGFkZGluZ3MsIHJlc29sdmVTdHlsZXMsIHJlc29sdmVMaW5rU3Vic3RpdHV0aW9uLCByZXNvbHZlQm9va21hcmtzLCByZXNvbHZlUGFnZVNpemVzLCByZXNvbHZlWW9nYSk7XG5cbmV4cG9ydCB7IGxheW91dCBhcyBkZWZhdWx0IH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@react-pdf+layout@4.4.0/node_modules/@react-pdf/layout/lib/index.js\n");

/***/ })

};
;