"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@react-pdf+render@4.3.0";
exports.ids = ["vendor-chunks/@react-pdf+render@4.3.0"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/@react-pdf+render@4.3.0/node_modules/@react-pdf/render/lib/index.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@react-pdf+render@4.3.0/node_modules/@react-pdf/render/lib/index.js ***!
  \************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ render)\n/* harmony export */ });\n/* harmony import */ var _react_pdf_primitives__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @react-pdf/primitives */ \"(ssr)/./node_modules/.pnpm/@react-pdf+primitives@4.1.1/node_modules/@react-pdf/primitives/lib/index.js\");\n/* harmony import */ var _react_pdf_fns__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @react-pdf/fns */ \"(ssr)/./node_modules/.pnpm/@react-pdf+fns@3.1.2/node_modules/@react-pdf/fns/lib/index.js\");\n/* harmony import */ var abs_svg_path__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! abs-svg-path */ \"(ssr)/./node_modules/.pnpm/abs-svg-path@0.1.1/node_modules/abs-svg-path/index.js\");\n/* harmony import */ var parse_svg_path__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! parse-svg-path */ \"(ssr)/./node_modules/.pnpm/parse-svg-path@0.1.2/node_modules/parse-svg-path/index.js\");\n/* harmony import */ var normalize_svg_path__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! normalize-svg-path */ \"(ssr)/./node_modules/.pnpm/normalize-svg-path@1.1.0/node_modules/normalize-svg-path/index.mjs\");\n/* harmony import */ var color_string__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! color-string */ \"(ssr)/./node_modules/.pnpm/color-string@1.9.1/node_modules/color-string/index.js\");\n\n\n\n\n\n\n\nconst renderPath = (ctx, node) => {\n    const d = node.props?.d;\n    if (d)\n        ctx.path(node.props.d);\n};\n\nconst KAPPA$3 = 4.0 * ((Math.sqrt(2) - 1.0) / 3.0);\nconst renderRect = (ctx, node) => {\n    const x = node.props?.x || 0;\n    const y = node.props?.y || 0;\n    const rx = node.props?.rx || 0;\n    const ry = node.props?.ry || 0;\n    const width = node.props?.width || 0;\n    const height = node.props?.height || 0;\n    if (!width || !height)\n        return;\n    if (rx && ry) {\n        const krx = rx * KAPPA$3;\n        const kry = ry * KAPPA$3;\n        ctx.moveTo(x + rx, y);\n        ctx.lineTo(x - rx + width, y);\n        ctx.bezierCurveTo(x - rx + width + krx, y, x + width, y + ry - kry, x + width, y + ry);\n        ctx.lineTo(x + width, y + height - ry);\n        ctx.bezierCurveTo(x + width, y + height - ry + kry, x - rx + width + krx, y + height, x - rx + width, y + height);\n        ctx.lineTo(x + rx, y + height);\n        ctx.bezierCurveTo(x + rx - krx, y + height, x, y + height - ry + kry, x, y + height - ry);\n        ctx.lineTo(x, y + ry);\n        ctx.bezierCurveTo(x, y + ry - kry, x + rx - krx, y, x + rx, y);\n    }\n    else {\n        ctx.moveTo(x, y);\n        ctx.lineTo(x + width, y);\n        ctx.lineTo(x + width, y + height);\n        ctx.lineTo(x, y + height);\n    }\n    ctx.closePath();\n};\n\nconst renderLine$1 = (ctx, node) => {\n    const { x1, x2, y1, y2 } = node.props || {};\n    ctx.moveTo(x1, y1);\n    ctx.lineTo(x2, y2);\n};\n\nconst renderGroup = () => {\n    // noop\n};\n\nconst KAPPA$2 = 4.0 * ((Math.sqrt(2) - 1.0) / 3.0);\nconst drawEllipse = (ctx, rx, ry, cx = 0, cy = 0) => {\n    const x = cx - rx;\n    const y = cy - ry;\n    const ox = rx * KAPPA$2;\n    const oy = ry * KAPPA$2;\n    const xe = x + rx * 2;\n    const ye = y + ry * 2;\n    const xm = x + rx;\n    const ym = y + ry;\n    ctx.moveTo(x, ym);\n    ctx.bezierCurveTo(x, ym - oy, xm - ox, y, xm, y);\n    ctx.bezierCurveTo(xm + ox, y, xe, ym - oy, xe, ym);\n    ctx.bezierCurveTo(xe, ym + oy, xm + ox, ye, xm, ye);\n    ctx.bezierCurveTo(xm - ox, ye, x, ym + oy, x, ym);\n    ctx.closePath();\n};\nconst renderEllipse = (ctx, node) => {\n    const { cx, cy, rx, ry } = node.props || {};\n    drawEllipse(ctx, rx, ry, cx, cy);\n};\n\nconst renderCircle = (ctx, node) => {\n    const cx = node.props?.cx;\n    const cy = node.props?.cy;\n    const r = node.props?.r;\n    drawEllipse(ctx, r, r, cx, cy);\n};\n\n/* eslint-disable no-return-assign */\nconst number = (n) => {\n    if (n > -1e21 && n < 1e21) {\n        return Math.round(n * 1e6) / 1e6;\n    }\n    throw new Error(`unsupported number: ${n}`);\n};\nconst _renderGlyphs = (ctx, encoded, positions, x, y) => {\n    const commands = [];\n    const scale = ctx._fontSize / 1000;\n    let i;\n    let last = 0;\n    let hadOffset = false;\n    ctx.save();\n    // flip coordinate system\n    ctx.transform(1, 0, 0, -1, 0, ctx.page.height);\n    y = ctx.page.height - y;\n    // add current font to page if necessary\n    if (ctx.page.fonts[ctx._font.id] == null) {\n        ctx.page.fonts[ctx._font.id] = ctx._font.ref();\n    }\n    // begin the text object\n    ctx.addContent('BT');\n    // text position\n    ctx.addContent(`1 0 0 1 ${number(x)} ${number(y)} Tm`);\n    // font and font size\n    ctx.addContent(`/${ctx._font.id} ${number(ctx._fontSize)} Tf`);\n    // Adds a segment of text to the TJ command buffer\n    const addSegment = (cur) => {\n        if (last < cur) {\n            const hex = encoded.slice(last, cur).join('');\n            const advance = positions[cur - 1].xAdvance - positions[cur - 1].advanceWidth;\n            commands.push(`<${hex}> ${number(-advance)}`);\n        }\n        return (last = cur);\n    };\n    // Flushes the current TJ commands to the output stream\n    const flush = (s) => {\n        addSegment(s);\n        if (commands.length > 0) {\n            ctx.addContent(`[${commands.join(' ')}] TJ`);\n            return (commands.length = 0);\n        }\n    };\n    for (i = 0; i < positions.length; i += 1) {\n        // If we have an x or y offset, we have to break out of the current TJ command\n        // so we can move the text position.\n        const pos = positions[i];\n        if (pos.xOffset || pos.yOffset) {\n            // Flush the current buffer\n            flush(i);\n            // Move the text position and flush just the current character\n            ctx.addContent(`1 0 0 1 ${number(x + pos.xOffset * scale)} ${number(y + pos.yOffset * scale)} Tm`);\n            flush(i + 1);\n            hadOffset = true;\n        }\n        else {\n            // If the last character had an offset, reset the text position\n            if (hadOffset) {\n                ctx.addContent(`1 0 0 1 ${number(x)} ${number(y)} Tm`);\n                hadOffset = false;\n            }\n            // Group segments that don't have any advance adjustments\n            if (pos.xAdvance - pos.advanceWidth !== 0) {\n                addSegment(i + 1);\n            }\n        }\n        x += pos.xAdvance * scale;\n    }\n    // Flush any remaining commands\n    flush(i);\n    // end the text object\n    ctx.addContent('ET');\n    // restore flipped coordinate system\n    return ctx.restore();\n};\nconst renderGlyphs = (ctx, glyphs, positions, x, y) => {\n    const scale = 1000 / ctx._fontSize;\n    const unitsPerEm = ctx._font.font.unitsPerEm || 1000;\n    const advanceWidthScale = 1000 / unitsPerEm;\n    // Glyph encoding and positioning\n    const encodedGlyphs = ctx._font.encodeGlyphs(glyphs);\n    const encodedPositions = positions.map((pos, i) => ({\n        xAdvance: pos.xAdvance * scale,\n        yAdvance: pos.yAdvance * scale,\n        xOffset: pos.xOffset,\n        yOffset: pos.yOffset,\n        advanceWidth: glyphs[i].advanceWidth * advanceWidthScale,\n    }));\n    return _renderGlyphs(ctx, encodedGlyphs, encodedPositions, x, y);\n};\n\nconst renderRun$1 = (ctx, run) => {\n    if (!run.glyphs)\n        return;\n    if (!run.positions)\n        return;\n    const runAdvanceWidth = run.xAdvance;\n    const font = run.attributes.font?.[0];\n    const { fontSize, color, opacity } = run.attributes;\n    if (color)\n        ctx.fillColor(color);\n    ctx.fillOpacity(opacity);\n    if (font) {\n        ctx.font(font.type === 'STANDARD' ? font.fullName : font, fontSize);\n    }\n    try {\n        renderGlyphs(ctx, run.glyphs, run.positions, 0, 0);\n    }\n    catch (error) {\n        console.log(error);\n    }\n    ctx.translate(runAdvanceWidth, 0);\n};\nconst renderSpan = (ctx, line, textAnchor, dominantBaseline) => {\n    ctx.save();\n    const x = line.box?.x || 0;\n    const y = line.box?.y || 0;\n    const font = line.runs[0]?.attributes.font?.[0];\n    const scale = line.runs[0]?.attributes?.scale || 1;\n    const width = line.xAdvance;\n    if (!font)\n        return;\n    const ascent = font.ascent * scale;\n    const xHeight = font.xHeight * scale;\n    const descent = font.descent * scale;\n    const capHeight = font.capHeight * scale;\n    let xTranslate = x;\n    let yTranslate = y;\n    switch (textAnchor) {\n        case 'middle':\n            xTranslate = x - width / 2;\n            break;\n        case 'end':\n            xTranslate = x - width;\n            break;\n        default:\n            xTranslate = x;\n            break;\n    }\n    switch (dominantBaseline) {\n        case 'middle':\n        case 'central':\n            yTranslate = y + capHeight / 2;\n            break;\n        case 'hanging':\n            yTranslate = y + capHeight;\n            break;\n        case 'mathematical':\n            yTranslate = y + xHeight;\n            break;\n        case 'text-after-edge':\n            yTranslate = y + descent;\n            break;\n        case 'text-before-edge':\n            yTranslate = y + ascent;\n            break;\n        default:\n            yTranslate = y;\n            break;\n    }\n    ctx.translate(xTranslate, yTranslate);\n    line.runs.forEach((run) => renderRun$1(ctx, run));\n    ctx.restore();\n};\nconst renderSvgText = (ctx, node) => {\n    const children = node.children;\n    children.forEach((span) => renderSpan(ctx, span.lines[0], span.props.textAnchor, span.props.dominantBaseline));\n};\n\nconst pairs = (values) => {\n    const result = [];\n    for (let i = 0; i < values.length; i += 2) {\n        result.push([values[i], values[i + 1]]);\n    }\n    return result;\n};\n/**\n * Parse svg-like points into number arrays\n *\n * @param points string ex. \"20,30 50,60\"\n * @returns points array ex. [[20, 30], [50, 60]]\n */\nconst parsePoints = (points) => {\n    let values = (points || '')\n        .trim()\n        .replace(/,/g, ' ')\n        .replace(/(\\d)-(\\d)/g, '$1 -$2')\n        .split(/\\s+/);\n    if (values.length % 2 !== 0) {\n        values = values.slice(0, -1);\n    }\n    const mappedValues = values.map(parseFloat);\n    return pairs(mappedValues);\n};\n\nconst drawPolyline = (ctx, points) => {\n    if (points.length > 0) {\n        ctx.moveTo(points[0][0], points[0][1]);\n        points.slice(1).forEach((p) => ctx.lineTo(p[0], p[1]));\n    }\n};\nconst renderPolyline = (ctx, node) => {\n    const points = parsePoints(node.props.points || '');\n    drawPolyline(ctx, points);\n};\n\nconst renderPolygon = (ctx, node) => {\n    const points = parsePoints(node.props.points || '');\n    drawPolyline(ctx, points);\n    ctx.closePath();\n};\n\nconst renderImage$1 = (ctx, node) => {\n    if (!node.box)\n        return;\n    if (!node.image?.data)\n        return;\n    const { x = 0, y = 0 } = node.props;\n    const { width, height, opacity } = node.style;\n    const paddingTop = node.box.paddingLeft || 0;\n    const paddingLeft = node.box.paddingLeft || 0;\n    if (width === 0 || height === 0) {\n        console.warn(`Image with src '${node.props.href}' skipped due to invalid dimensions`);\n        return;\n    }\n    if (typeof width === 'string' || typeof height === 'string') {\n        console.warn(`Image with src '${node.props.href}' skipped due to percentage width or height`);\n        return;\n    }\n    ctx.save();\n    ctx\n        .fillOpacity(opacity || 1)\n        .image(node.image.data, x + paddingLeft, y + paddingTop, {\n        width,\n        height,\n    });\n    ctx.restore();\n};\n\n// This constant is used to approximate a symmetrical arc using a cubic\n// Bezier curve.\nconst KAPPA$1 = 4.0 * ((Math.sqrt(2) - 1.0) / 3.0);\nconst clipNode = (ctx, node) => {\n    if (!node.box)\n        return;\n    if (!node.style)\n        return;\n    const { top, left, width, height } = node.box;\n    const { borderTopLeftRadius = 0, borderTopRightRadius = 0, borderBottomRightRadius = 0, borderBottomLeftRadius = 0, } = node.style;\n    // Border top\n    // @ts-expect-error this is always a number due to resolve border radius step\n    const rtr = Math.min(borderTopRightRadius, 0.5 * width, 0.5 * height);\n    const ctr = rtr * (1.0 - KAPPA$1);\n    ctx.moveTo(left + rtr, top);\n    ctx.lineTo(left + width - rtr, top);\n    ctx.bezierCurveTo(left + width - ctr, top, left + width, top + ctr, left + width, top + rtr);\n    // Border right\n    // @ts-expect-error this is always a number due to resolve border radius step\n    const rbr = Math.min(borderBottomRightRadius, 0.5 * width, 0.5 * height);\n    const cbr = rbr * (1.0 - KAPPA$1);\n    ctx.lineTo(left + width, top + height - rbr);\n    ctx.bezierCurveTo(left + width, top + height - cbr, left + width - cbr, top + height, left + width - rbr, top + height);\n    // Border bottom\n    // @ts-expect-error this is always a number due to resolve border radius step\n    const rbl = Math.min(borderBottomLeftRadius, 0.5 * width, 0.5 * height);\n    const cbl = rbl * (1.0 - KAPPA$1);\n    ctx.lineTo(left + rbl, top + height);\n    ctx.bezierCurveTo(left + cbl, top + height, left, top + height - cbl, left, top + height - rbl);\n    // Border left\n    // @ts-expect-error this is always a number due to resolve border radius step\n    const rtl = Math.min(borderTopLeftRadius, 0.5 * width, 0.5 * height);\n    const ctl = rtl * (1.0 - KAPPA$1);\n    ctx.lineTo(left, top + rtl);\n    ctx.bezierCurveTo(left, top + ctl, left + ctl, top, left + rtl, top);\n    ctx.closePath();\n    ctx.clip();\n};\n\nconst applySingleTransformation = (ctx, transform, origin) => {\n    const { operation, value } = transform;\n    switch (operation) {\n        case 'scale': {\n            const [scaleX, scaleY] = value;\n            ctx.scale(scaleX, scaleY, { origin });\n            break;\n        }\n        case 'rotate': {\n            const [angle] = value;\n            ctx.rotate(angle, { origin });\n            break;\n        }\n        case 'translate': {\n            const [x, y = 0] = value;\n            ctx.translate(x, y, { origin });\n            break;\n        }\n        case 'skew': {\n            const [xAngle = 0, yAngle = 0] = value;\n            const radx = (xAngle * Math.PI) / 180;\n            const rady = (yAngle * Math.PI) / 180;\n            const tanx = Math.tan(radx);\n            const tany = Math.tan(rady);\n            let x = 0;\n            let y = 0;\n            if (origin != null) {\n                [x, y] = Array.from(origin);\n                const x1 = x + tanx * y;\n                const y1 = y + tany * x;\n                x -= x1;\n                y -= y1;\n            }\n            ctx.transform(1, tany, tanx, 1, x, y);\n            break;\n        }\n        case 'matrix': {\n            ctx.transform(...value);\n            break;\n        }\n        default: {\n            console.error(`Transform operation: '${operation}' doesn't supported`);\n        }\n    }\n};\nconst applyTransformations = (ctx, node) => {\n    if (!node.origin)\n        return;\n    const { props, style } = node;\n    const origin = [node.origin.left, node.origin.top];\n    const propsTransform = 'transform' in props ? props.transform : undefined;\n    const operations = style?.transform || propsTransform || [];\n    operations.forEach((operation) => {\n        applySingleTransformation(ctx, operation, origin);\n    });\n};\n\n// From https://github.com/dy/svg-path-bounds/blob/master/index.js\nconst getPathBoundingBox = (node) => {\n    const path = (0,normalize_svg_path__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(abs_svg_path__WEBPACK_IMPORTED_MODULE_2__(parse_svg_path__WEBPACK_IMPORTED_MODULE_3__(node.props?.d || '')));\n    if (!path.length)\n        return [0, 0, 0, 0];\n    const bounds = [Infinity, Infinity, -Infinity, -Infinity];\n    for (let i = 0, l = path.length; i < l; i += 1) {\n        const points = path[i].slice(1);\n        for (let j = 0; j < points.length; j += 2) {\n            if (points[j + 0] < bounds[0])\n                bounds[0] = points[j + 0];\n            if (points[j + 1] < bounds[1])\n                bounds[1] = points[j + 1];\n            if (points[j + 0] > bounds[2])\n                bounds[2] = points[j + 0];\n            if (points[j + 1] > bounds[3])\n                bounds[3] = points[j + 1];\n        }\n    }\n    return bounds;\n};\nconst getCircleBoundingBox = (node) => {\n    const r = node.props?.r || 0;\n    const cx = node.props?.cx || 0;\n    const cy = node.props?.cy || 0;\n    return [cx - r, cy - r, cx + r, cy + r];\n};\nconst getEllipseBoundingBox = (node) => {\n    const cx = node.props?.cx || 0;\n    const cy = node.props?.cy || 0;\n    const rx = node.props?.rx || 0;\n    const ry = node.props?.ry || 0;\n    return [cx - rx, cy - ry, cx + rx, cy + ry];\n};\nconst getLineBoundingBox = (node) => {\n    const x1 = node.props?.x1 || 0;\n    const y1 = node.props?.y1 || 0;\n    const x2 = node.props?.x2 || 0;\n    const y2 = node.props?.y2 || 0;\n    return [\n        Math.min(x1, x2),\n        Math.min(y1, y2),\n        Math.max(x1, x2),\n        Math.max(y1, y2),\n    ];\n};\nconst getRectBoundingBox = (node) => {\n    const x = node.props?.x || 0;\n    const y = node.props?.y || 0;\n    const width = node.props?.width || 0;\n    const height = node.props?.height || 0;\n    return [x, y, x + width, y + height];\n};\nconst max = (values) => Math.max(-Infinity, ...values);\nconst min = (values) => Math.min(Infinity, ...values);\nconst getPolylineBoundingBox = (node) => {\n    const points = parsePoints(node.props?.points);\n    const xValues = points.map((p) => p[0]);\n    const yValues = points.map((p) => p[1]);\n    return [min(xValues), min(yValues), max(xValues), max(yValues)];\n};\nconst boundingBoxFns = {\n    [_react_pdf_primitives__WEBPACK_IMPORTED_MODULE_0__.Rect]: getRectBoundingBox,\n    [_react_pdf_primitives__WEBPACK_IMPORTED_MODULE_0__.Line]: getLineBoundingBox,\n    [_react_pdf_primitives__WEBPACK_IMPORTED_MODULE_0__.Path]: getPathBoundingBox,\n    [_react_pdf_primitives__WEBPACK_IMPORTED_MODULE_0__.Circle]: getCircleBoundingBox,\n    [_react_pdf_primitives__WEBPACK_IMPORTED_MODULE_0__.Ellipse]: getEllipseBoundingBox,\n    [_react_pdf_primitives__WEBPACK_IMPORTED_MODULE_0__.Polygon]: getPolylineBoundingBox,\n    [_react_pdf_primitives__WEBPACK_IMPORTED_MODULE_0__.Polyline]: getPolylineBoundingBox,\n};\nconst getBoundingBox = (node) => {\n    const boundingBoxFn = boundingBoxFns[node.type];\n    return boundingBoxFn ? boundingBoxFn(node) : [0, 0, 0, 0];\n};\n\nconst setStrokeWidth = (ctx, node) => {\n    if (!node.props)\n        return;\n    if (!('strokeWidth' in node.props))\n        return;\n    const lineWidth = node.props.strokeWidth;\n    if (lineWidth)\n        ctx.lineWidth(lineWidth);\n};\nconst setStrokeColor = (ctx, node) => {\n    if (!node.props)\n        return;\n    if (!('stroke' in node.props))\n        return;\n    const strokeColor = node.props.stroke;\n    if (strokeColor)\n        ctx.strokeColor(strokeColor);\n};\nconst setOpacity = (ctx, node) => {\n    if (!node.props)\n        return;\n    if (!('opacity' in node.props))\n        return;\n    const opacity = node.props.opacity;\n    if (!(0,_react_pdf_fns__WEBPACK_IMPORTED_MODULE_1__.isNil)(opacity))\n        ctx.opacity(opacity);\n};\nconst setFillOpacity = (ctx, node) => {\n    if (!node.props)\n        return;\n    if (!('fillOpacity' in node.props))\n        return;\n    const fillOpacity = node.props.fillOpacity || null;\n    if (!(0,_react_pdf_fns__WEBPACK_IMPORTED_MODULE_1__.isNil)(fillOpacity))\n        ctx.fillOpacity(fillOpacity);\n};\nconst setStrokeOpacity = (ctx, node) => {\n    if (!node.props)\n        return;\n    if (!('strokeOpacity' in node.props))\n        return;\n    const strokeOpacity = node.props?.strokeOpacity;\n    if (!(0,_react_pdf_fns__WEBPACK_IMPORTED_MODULE_1__.isNil)(strokeOpacity))\n        ctx.strokeOpacity(strokeOpacity);\n};\nconst setLineJoin = (ctx, node) => {\n    if (!node.props)\n        return;\n    if (!('strokeLinejoin' in node.props))\n        return;\n    const lineJoin = node.props.strokeLinejoin;\n    if (lineJoin)\n        ctx.lineJoin(lineJoin);\n};\nconst setLineCap = (ctx, node) => {\n    if (!node.props)\n        return;\n    if (!('strokeLinecap' in node.props))\n        return;\n    const lineCap = node.props?.strokeLinecap;\n    if (lineCap)\n        ctx.lineCap(lineCap);\n};\nconst setLineDash = (ctx, node) => {\n    if (!node.props)\n        return;\n    if (!('strokeDasharray' in node.props))\n        return;\n    const value = node.props?.strokeDasharray || null;\n    // @ts-expect-error check this works as expected\n    if (value)\n        ctx.dash(value.split(/[\\s,]+/).map(Number));\n};\nconst hasLinearGradientFill = (node) => {\n    if (!node.props)\n        return false;\n    if (!('fill' in node.props))\n        return false;\n    if (typeof node.props.fill === 'string')\n        return false;\n    return node.props.fill?.type === _react_pdf_primitives__WEBPACK_IMPORTED_MODULE_0__.LinearGradient;\n};\nconst hasRadialGradientFill = (node) => {\n    if (!node.props)\n        return false;\n    if (!('fill' in node.props))\n        return false;\n    if (typeof node.props.fill === 'string')\n        return false;\n    return node.props.fill?.type === _react_pdf_primitives__WEBPACK_IMPORTED_MODULE_0__.RadialGradient;\n};\nfunction multiplyMatrices(m1, m2) {\n    const a = m1[0] * m2[0] + m1[2] * m2[1];\n    const b = m1[1] * m2[0] + m1[3] * m2[1];\n    const c = m1[0] * m2[2] + m1[2] * m2[3];\n    const d = m1[1] * m2[2] + m1[3] * m2[3];\n    const e = m1[0] * m2[4] + m1[2] * m2[5] + m1[4];\n    const f = m1[1] * m2[4] + m1[3] * m2[5] + m1[5];\n    return [a, b, c, d, e, f];\n}\nconst transformGradient = (grad, transforms, bbox, units) => {\n    const matrices = transforms.map((transform) => {\n        switch (transform.operation) {\n            case 'scale': {\n                const value = transform.value;\n                return [value[0], 0, 0, value[1], 0, 0];\n            }\n            case 'translate': {\n                const value = transform.value;\n                let x = value[0] || 0;\n                let y = value[1] || 0;\n                if (units === 'objectBoundingBox') {\n                    x = (bbox[2] - bbox[0]) * x;\n                    y = (bbox[3] - bbox[1]) * y;\n                }\n                return [1, 0, 0, 1, x, y];\n            }\n            case 'rotate': {\n                const value = transform.value;\n                const cos = Math.cos(value[0]);\n                const sin = Math.sin(value[0]);\n                return [cos, sin, -sin, cos, 0, 0];\n            }\n            case 'skew': {\n                const value = transform.value;\n                return [1, Math.tan(value[0]), Math.tan(value[1]), 1, 0, 0];\n            }\n            case 'matrix': {\n                const value = transform.value;\n                let x = value[4] || 0;\n                let y = value[5] || 0;\n                if (units === 'objectBoundingBox') {\n                    x = (bbox[2] - bbox[0]) * x;\n                    y = (bbox[3] - bbox[1]) * y;\n                }\n                return [value[0], value[1], value[2], value[3], x, y];\n            }\n            default:\n                return [1, 0, 0, 1, 0, 0];\n        }\n    });\n    const matrix = matrices.reduce(multiplyMatrices, [1, 0, 0, 1, 0, 0]);\n    grad.setTransform(...matrix);\n};\n// Math simplified from https://github.com/devongovett/svgkit/blob/master/src/elements/SVGGradient.js#L104\nconst setLinearGradientFill = (ctx, node) => {\n    if (!node.props)\n        return;\n    if (!('fill' in node.props))\n        return;\n    const bbox = getBoundingBox(node);\n    const gradient = node.props?.fill;\n    if (!gradient)\n        return;\n    const units = gradient.props.gradientUnits || 'objectBoundingBox';\n    const transforms = gradient.props.gradientTransform || [];\n    let x1 = gradient.props.x1 || 0;\n    let y1 = gradient.props.y1 || 0;\n    let x2 = gradient.props.x2 || 1;\n    let y2 = gradient.props.y2 || 0;\n    if (units === 'objectBoundingBox') {\n        const m0 = bbox[2] - bbox[0];\n        const m3 = bbox[3] - bbox[1];\n        const m4 = bbox[0];\n        const m5 = bbox[1];\n        x1 = m0 * x1 + m4;\n        y1 = m3 * y1 + m5;\n        x2 = m0 * x2 + m4;\n        y2 = m3 * y2 + m5;\n    }\n    const grad = ctx.linearGradient(x1, y1, x2, y2);\n    transformGradient(grad, transforms, bbox, units);\n    gradient.children?.forEach((stop) => {\n        grad.stop(stop.props.offset, stop.props.stopColor, stop.props.stopOpacity);\n    });\n    ctx.fill(grad);\n};\n// Math simplified from https://github.com/devongovett/svgkit/blob/master/src/elements/SVGGradient.js#L155\nconst setRadialGradientFill = (ctx, node) => {\n    if (!node.props)\n        return;\n    if (!('fill' in node.props))\n        return;\n    const bbox = getBoundingBox(node);\n    const gradient = node.props?.fill;\n    if (!gradient)\n        return;\n    const units = gradient.props.gradientUnits || 'objectBoundingBox';\n    const transforms = gradient.props.gradientTransform || [];\n    let r = gradient.props.r || 0.5;\n    let cx = gradient.props.cx || 0.5;\n    let cy = gradient.props.cy || 0.5;\n    let fx = gradient.props.fx || cx;\n    let fy = gradient.props.fy || cy;\n    if (units === 'objectBoundingBox') {\n        const m0 = bbox[2] - bbox[0];\n        const m3 = bbox[3] - bbox[1];\n        const m4 = bbox[0];\n        const m5 = bbox[1];\n        r = r * m0;\n        cx = m0 * cx + m4;\n        cy = m3 * cy + m5;\n        fx = m0 * fx + m4;\n        fy = m3 * fy + m5;\n    }\n    const grad = ctx.radialGradient(cx, cy, 0, fx, fy, r);\n    transformGradient(grad, transforms, bbox, units);\n    gradient.children?.forEach((stop) => {\n        grad.stop(stop.props.offset, stop.props.stopColor, stop.props.stopOpacity);\n    });\n    ctx.fill(grad);\n};\nconst setFillColor = (ctx, node) => {\n    if (!node.props)\n        return;\n    if (!('fill' in node.props))\n        return;\n    const fillColor = node.props?.fill;\n    if (fillColor)\n        ctx.fillColor(fillColor);\n};\nconst setFill = (ctx, node) => {\n    if (hasLinearGradientFill(node))\n        return setLinearGradientFill(ctx, node);\n    if (hasRadialGradientFill(node))\n        return setRadialGradientFill(ctx, node);\n    return setFillColor(ctx, node);\n};\nconst draw = (ctx, node) => {\n    const props = node.props || {};\n    if ('fill' in props && 'stroke' in props && props.fill && props.stroke) {\n        ctx.fillAndStroke(props.fillRule);\n    }\n    else if ('fill' in props && props.fill) {\n        ctx.fill(props.fillRule);\n    }\n    else if ('stroke' in props && props.stroke) {\n        ctx.stroke();\n    }\n    else {\n        ctx.save();\n        ctx.opacity(0);\n        ctx.fill(null);\n        ctx.restore();\n    }\n};\nconst noop = () => { };\nconst renderFns$1 = {\n    [_react_pdf_primitives__WEBPACK_IMPORTED_MODULE_0__.Tspan]: noop,\n    [_react_pdf_primitives__WEBPACK_IMPORTED_MODULE_0__.TextInstance]: noop,\n    [_react_pdf_primitives__WEBPACK_IMPORTED_MODULE_0__.Path]: renderPath,\n    [_react_pdf_primitives__WEBPACK_IMPORTED_MODULE_0__.Rect]: renderRect,\n    [_react_pdf_primitives__WEBPACK_IMPORTED_MODULE_0__.Line]: renderLine$1,\n    [_react_pdf_primitives__WEBPACK_IMPORTED_MODULE_0__.G]: renderGroup,\n    [_react_pdf_primitives__WEBPACK_IMPORTED_MODULE_0__.Text]: renderSvgText,\n    [_react_pdf_primitives__WEBPACK_IMPORTED_MODULE_0__.Circle]: renderCircle,\n    [_react_pdf_primitives__WEBPACK_IMPORTED_MODULE_0__.Image]: renderImage$1,\n    [_react_pdf_primitives__WEBPACK_IMPORTED_MODULE_0__.Ellipse]: renderEllipse,\n    [_react_pdf_primitives__WEBPACK_IMPORTED_MODULE_0__.Polygon]: renderPolygon,\n    [_react_pdf_primitives__WEBPACK_IMPORTED_MODULE_0__.Polyline]: renderPolyline,\n};\nconst renderNode$1 = (ctx, node) => {\n    const renderFn = renderFns$1[node.type];\n    if (renderFn) {\n        renderFn(ctx, node);\n    }\n    else {\n        console.warn(`SVG node of type ${node.type} is not currently supported`);\n    }\n};\nconst drawNode = (ctx, node) => {\n    setLineCap(ctx, node);\n    setLineDash(ctx, node);\n    setLineJoin(ctx, node);\n    setStrokeWidth(ctx, node);\n    setStrokeColor(ctx, node);\n    setFill(ctx, node);\n    setStrokeOpacity(ctx, node);\n    setFillOpacity(ctx, node);\n    setOpacity(ctx, node);\n    applyTransformations(ctx, node);\n    renderNode$1(ctx, node);\n    draw(ctx, node);\n};\nconst clipPath = (ctx, node) => {\n    if (!node.props)\n        return;\n    if (!('clipPath' in node.props))\n        return;\n    const value = node.props.clipPath;\n    if (value) {\n        const children = value.children || [];\n        children.forEach((child) => renderNode$1(ctx, child));\n        ctx.clip();\n    }\n};\nconst drawChildren = (ctx, node) => {\n    const children = node.children || [];\n    children.forEach((child) => {\n        ctx.save();\n        clipPath(ctx, child);\n        drawNode(ctx, child);\n        drawChildren(ctx, child);\n        ctx.restore();\n    });\n};\nconst resolveAspectRatio = (ctx, node) => {\n    if (!node.box)\n        return;\n    const { width, height } = node.box;\n    const { viewBox, preserveAspectRatio } = node.props;\n    const { meetOrSlice = 'meet', align = 'xMidYMid' } = preserveAspectRatio || {};\n    if (viewBox == null || width == null || height == null)\n        return;\n    const x = viewBox?.minX || 0;\n    const y = viewBox?.minY || 0;\n    const logicalWidth = viewBox?.maxX || width;\n    const logicalHeight = viewBox?.maxY || height;\n    const logicalRatio = logicalWidth / logicalHeight;\n    const physicalRatio = width / height;\n    const scaleX = width / logicalWidth;\n    const scaleY = height / logicalHeight;\n    if (align === 'none') {\n        ctx.scale(scaleX, scaleY);\n        ctx.translate(-x, -y);\n        return;\n    }\n    if ((logicalRatio < physicalRatio && meetOrSlice === 'meet') ||\n        (logicalRatio >= physicalRatio && meetOrSlice === 'slice')) {\n        ctx.scale(scaleY, scaleY);\n        switch (align) {\n            case 'xMinYMin':\n            case 'xMinYMid':\n            case 'xMinYMax':\n                ctx.translate(-x, -y);\n                break;\n            case 'xMidYMin':\n            case 'xMidYMid':\n            case 'xMidYMax':\n                ctx.translate(-x - (logicalWidth - (width * logicalHeight) / height) / 2, -y);\n                break;\n            default:\n                ctx.translate(-x - (logicalWidth - (width * logicalHeight) / height), -y);\n        }\n    }\n    else {\n        ctx.scale(scaleX, scaleX);\n        switch (align) {\n            case 'xMinYMin':\n            case 'xMidYMin':\n            case 'xMaxYMin':\n                ctx.translate(-x, -y);\n                break;\n            case 'xMinYMid':\n            case 'xMidYMid':\n            case 'xMaxYMid':\n                ctx.translate(-x, -y - (logicalHeight - (height * logicalWidth) / width) / 2);\n                break;\n            default:\n                ctx.translate(-x, -y - (logicalHeight - (height * logicalWidth) / width));\n        }\n    }\n};\nconst moveToOrigin = (ctx, node) => {\n    if (!node.box)\n        return;\n    const { top, left } = node.box;\n    const paddingLeft = node.box.paddingLeft || 0;\n    const paddingTop = node.box.paddingTop || 0;\n    ctx.translate(left + paddingLeft, top + paddingTop);\n};\nconst renderSvg = (ctx, node) => {\n    ctx.save();\n    clipNode(ctx, node);\n    moveToOrigin(ctx, node);\n    resolveAspectRatio(ctx, node);\n    drawChildren(ctx, node);\n    ctx.restore();\n};\n\nconst black = { value: '#000', opacity: 1 };\n// TODO: parse to number[] in layout to avoid this step\nconst parseColor = (hex) => {\n    if (!hex)\n        return black;\n    const parsed = color_string__WEBPACK_IMPORTED_MODULE_5__.get(hex);\n    if (!parsed)\n        return black;\n    const value = color_string__WEBPACK_IMPORTED_MODULE_5__.to.hex(parsed.value.slice(0, 3));\n    const opacity = parsed.value[3];\n    return { value, opacity };\n};\n\nconst DEST_REGEXP = /^#.+/;\nconst isSrcId$1 = (src) => src.match(DEST_REGEXP);\nconst renderAttachment = (ctx, attachment) => {\n    const { xOffset = 0, yOffset = 0, width, height, image } = attachment;\n    ctx.translate(-width + xOffset, -height + yOffset);\n    ctx.image(image, 0, 0, {\n        fit: [width, height],\n        align: 'center',\n        valign: 'bottom',\n    });\n};\nconst renderAttachments = (ctx, run) => {\n    if (!run.glyphs)\n        return;\n    if (!run.positions)\n        return;\n    const font = run.attributes.font?.[0];\n    if (!font)\n        return;\n    ctx.save();\n    const space = font.glyphForCodePoint(0x20);\n    const objectReplacement = font.glyphForCodePoint(0xfffc);\n    let attachmentAdvance = 0;\n    for (let i = 0; i < run.glyphs.length; i += 1) {\n        const position = run.positions[i];\n        const glyph = run.glyphs[i];\n        attachmentAdvance += position.xAdvance || 0;\n        if (glyph.id === objectReplacement.id && run.attributes.attachment) {\n            ctx.translate(attachmentAdvance, position.yOffset || 0);\n            renderAttachment(ctx, run.attributes.attachment);\n            run.glyphs[i] = space;\n            attachmentAdvance = 0;\n        }\n    }\n    ctx.restore();\n};\nconst renderRun = (ctx, run) => {\n    if (!run.glyphs)\n        return;\n    if (!run.positions)\n        return;\n    const font = run.attributes.font?.[0];\n    if (!font)\n        return;\n    const { fontSize, link } = run.attributes;\n    const color = parseColor(run.attributes.color);\n    const opacity = (0,_react_pdf_fns__WEBPACK_IMPORTED_MODULE_1__.isNil)(run.attributes.opacity)\n        ? color.opacity\n        : run.attributes.opacity;\n    const { height = 0, descent = 0, xAdvance = 0 } = run;\n    ctx.fillColor(color.value);\n    ctx.fillOpacity(opacity);\n    if (link) {\n        if (isSrcId$1(link)) {\n            ctx.goTo(0, -height - descent, xAdvance, height, link.slice(1));\n        }\n        else {\n            ctx.link(0, -height - descent, xAdvance, height, link);\n        }\n    }\n    renderAttachments(ctx, run);\n    ctx.font(font.type === 'STANDARD' ? font.fullName : font, fontSize);\n    try {\n        renderGlyphs(ctx, run.glyphs, run.positions, 0, 0);\n    }\n    catch (error) {\n        console.log(error);\n    }\n    ctx.translate(xAdvance, 0);\n};\nconst renderBackground$1 = (ctx, rect, backgroundColor) => {\n    const color = parseColor(backgroundColor);\n    ctx.save();\n    ctx.fillOpacity(color.opacity);\n    ctx.rect(rect.x, rect.y, rect.width, rect.height);\n    ctx.fill(color.value);\n    ctx.restore();\n};\nconst renderDecorationLine = (ctx, decorationLine) => {\n    ctx.save();\n    ctx.lineWidth(decorationLine.rect.height);\n    ctx.strokeOpacity(decorationLine.opacity);\n    if (/dashed/.test(decorationLine.style)) {\n        ctx.dash(3 * decorationLine.rect.height, {});\n    }\n    else if (/dotted/.test(decorationLine.style)) {\n        ctx.dash(decorationLine.rect.height, {});\n    }\n    if (/wavy/.test(decorationLine.style)) {\n        const dist = Math.max(2, decorationLine.rect.height);\n        let step = 1.1 * dist;\n        const stepCount = Math.floor(decorationLine.rect.width / (2 * step));\n        // Adjust step to fill entire width\n        const remainingWidth = decorationLine.rect.width - stepCount * 2 * step;\n        const adjustment = remainingWidth / stepCount / 2;\n        step += adjustment;\n        const cp1y = decorationLine.rect.y + dist;\n        const cp2y = decorationLine.rect.y - dist;\n        let { x } = decorationLine.rect;\n        ctx.moveTo(decorationLine.rect.x, decorationLine.rect.y);\n        for (let i = 0; i < stepCount; i += 1) {\n            ctx.bezierCurveTo(x + step, cp1y, x + step, cp2y, x + 2 * step, decorationLine.rect.y);\n            x += 2 * step;\n        }\n    }\n    else {\n        ctx.moveTo(decorationLine.rect.x, decorationLine.rect.y);\n        ctx.lineTo(decorationLine.rect.x + decorationLine.rect.width, decorationLine.rect.y);\n        if (/double/.test(decorationLine.style)) {\n            ctx.moveTo(decorationLine.rect.x, decorationLine.rect.y + decorationLine.rect.height * 2);\n            ctx.lineTo(decorationLine.rect.x + decorationLine.rect.width, decorationLine.rect.y + decorationLine.rect.height * 2);\n        }\n    }\n    ctx.stroke(decorationLine.color);\n    ctx.restore();\n};\nconst renderLine = (ctx, line) => {\n    if (!line.box)\n        return;\n    const lineAscent = line.ascent || 0;\n    ctx.save();\n    ctx.translate(line.box.x, line.box.y + lineAscent);\n    for (let i = 0; i < line.runs.length; i += 1) {\n        const run = line.runs[i];\n        const isLastRun = i === line.runs.length - 1;\n        if (run.attributes.backgroundColor) {\n            const xAdvance = run.xAdvance ?? 0;\n            const overflowRight = isLastRun ? line.overflowRight ?? 0 : 0;\n            const backgroundRect = {\n                x: 0,\n                y: -lineAscent,\n                height: line.box.height,\n                width: xAdvance - overflowRight,\n            };\n            renderBackground$1(ctx, backgroundRect, run.attributes.backgroundColor);\n        }\n        renderRun(ctx, run);\n    }\n    ctx.restore();\n    ctx.save();\n    ctx.translate(line.box.x, line.box.y);\n    if (line.decorationLines) {\n        for (let i = 0; i < line.decorationLines.length; i += 1) {\n            const decorationLine = line.decorationLines[i];\n            renderDecorationLine(ctx, decorationLine);\n        }\n    }\n    ctx.restore();\n};\nconst renderBlock = (ctx, block) => {\n    block.forEach((line) => {\n        renderLine(ctx, line);\n    });\n};\nconst renderText = (ctx, node) => {\n    if (!node.box)\n        return;\n    if (!node.lines)\n        return;\n    const { top, left } = node.box;\n    const blocks = [node.lines];\n    const paddingTop = node.box?.paddingTop || 0;\n    const paddingLeft = node.box?.paddingLeft || 0;\n    const initialY = node.lines[0] ? node.lines[0].box.y : 0;\n    const offsetX = node.alignOffset || 0;\n    ctx.save();\n    ctx.translate(left + paddingLeft - offsetX, top + paddingTop - initialY);\n    blocks.forEach((block) => {\n        renderBlock(ctx, block);\n    });\n    ctx.restore();\n};\n\nconst renderPage = (ctx, node) => {\n    if (!node.box)\n        return;\n    const { width, height } = node.box;\n    const dpi = node.props?.dpi || 72;\n    const userUnit = dpi / 72;\n    ctx.addPage({ size: [width, height], margin: 0, userUnit });\n};\n\nconst renderNote = (ctx, node) => {\n    if (!node.box)\n        return;\n    const { top, left } = node.box;\n    const value = node?.children?.[0].value || '';\n    const color = node.style?.backgroundColor;\n    ctx.note(left, top, 0, 0, value, { color });\n};\n\nconst embedImage = (ctx, node) => {\n    const src = node.image.data;\n    let image;\n    if (typeof src === 'string') {\n        image = ctx._imageRegistry[src];\n    }\n    if (!image) {\n        image = ctx.openImage(src);\n    }\n    if (!image.obj) {\n        image.embed(ctx);\n    }\n    return image;\n};\n\nconst isNumeric = (n) => {\n    return !Number.isNaN(parseFloat(n)) && Number.isFinite(n);\n};\nconst applyContainObjectFit = (cw, ch, iw, ih, px, py) => {\n    const cr = cw / ch;\n    const ir = iw / ih;\n    const pxp = (0,_react_pdf_fns__WEBPACK_IMPORTED_MODULE_1__.matchPercent)(px ?? null);\n    const pyp = (0,_react_pdf_fns__WEBPACK_IMPORTED_MODULE_1__.matchPercent)(py ?? null);\n    const pxv = pxp ? pxp.percent : 0.5;\n    const pyv = pyp ? pyp.percent : 0.5;\n    if (cr > ir) {\n        const height = ch;\n        const width = height * ir;\n        const yOffset = isNumeric(py) ? py : 0;\n        const xOffset = isNumeric(px) ? px : (cw - width) * pxv;\n        return { width, height, xOffset, yOffset };\n    }\n    const width = cw;\n    const height = width / ir;\n    const xOffset = isNumeric(px) ? px : 0;\n    const yOffset = isNumeric(py) ? py : (ch - height) * pyv;\n    return { width, height, yOffset, xOffset };\n};\nconst applyNoneObjectFit = (cw, ch, iw, ih, px, py) => {\n    const width = iw;\n    const height = ih;\n    const pxp = (0,_react_pdf_fns__WEBPACK_IMPORTED_MODULE_1__.matchPercent)(px ?? null);\n    const pyp = (0,_react_pdf_fns__WEBPACK_IMPORTED_MODULE_1__.matchPercent)(py ?? null);\n    const pxv = pxp ? pxp.percent : 0.5;\n    const pyv = pyp ? pyp.percent : 0.5;\n    const xOffset = isNumeric(px) ? px : (cw - width) * pxv;\n    const yOffset = isNumeric(py) ? py : (ch - height) * pyv;\n    return { width, height, xOffset, yOffset };\n};\nconst applyCoverObjectFit = (cw, ch, iw, ih, px, py) => {\n    const ir = iw / ih;\n    const cr = cw / ch;\n    const pxp = (0,_react_pdf_fns__WEBPACK_IMPORTED_MODULE_1__.matchPercent)(px ?? null);\n    const pyp = (0,_react_pdf_fns__WEBPACK_IMPORTED_MODULE_1__.matchPercent)(py ?? null);\n    const pxv = pxp ? pxp.percent : 0.5;\n    const pyv = pyp ? pyp.percent : 0.5;\n    if (cr > ir) {\n        const width = cw;\n        const height = width / ir;\n        const xOffset = isNumeric(px) ? px : 0;\n        const yOffset = isNumeric(py) ? py : (ch - height) * pyv;\n        return { width, height, yOffset, xOffset };\n    }\n    const height = ch;\n    const width = height * ir;\n    const xOffset = isNumeric(px) ? px : (cw - width) * pxv;\n    const yOffset = isNumeric(py) ? py : 0;\n    return { width, height, xOffset, yOffset };\n};\nconst applyScaleDownObjectFit = (cw, ch, iw, ih, px, py) => {\n    const containDimension = applyContainObjectFit(cw, ch, iw, ih, px, py);\n    const noneDimension = applyNoneObjectFit(cw, ch, iw, ih, px, py);\n    return containDimension.width < noneDimension.width\n        ? containDimension\n        : noneDimension;\n};\nconst applyFillObjectFit = (cw, ch, px, py) => {\n    return {\n        width: cw,\n        height: ch,\n        xOffset: (0,_react_pdf_fns__WEBPACK_IMPORTED_MODULE_1__.matchPercent)(px ?? null) ? 0 : px || 0,\n        yOffset: (0,_react_pdf_fns__WEBPACK_IMPORTED_MODULE_1__.matchPercent)(py ?? null) ? 0 : py || 0,\n    };\n};\nconst resolveObjectFit = (type = 'fill', cw, ch, iw, ih, px, py) => {\n    switch (type) {\n        case 'contain':\n            return applyContainObjectFit(cw, ch, iw, ih, px, py);\n        case 'cover':\n            return applyCoverObjectFit(cw, ch, iw, ih, px, py);\n        case 'none':\n            return applyNoneObjectFit(cw, ch, iw, ih, px, py);\n        case 'scale-down':\n            return applyScaleDownObjectFit(cw, ch, iw, ih, px, py);\n        default:\n            return applyFillObjectFit(cw, ch, px, py);\n    }\n};\n\nconst drawImage = (ctx, node, options) => {\n    if (!node.box)\n        return;\n    if (!node.image)\n        return;\n    const { left, top } = node.box;\n    const opacity = node.style?.opacity;\n    const objectFit = node.style?.objectFit;\n    const objectPositionX = node.style?.objectPositionX;\n    const objectPositionY = node.style?.objectPositionY;\n    const paddingTop = node.box.paddingTop || 0;\n    const paddingRight = node.box.paddingRight || 0;\n    const paddingBottom = node.box.paddingBottom || 0;\n    const paddingLeft = node.box.paddingLeft || 0;\n    const imageCache = options.imageCache || new Map();\n    const { width, height, xOffset, yOffset } = resolveObjectFit(objectFit, node.box.width - paddingLeft - paddingRight, node.box.height - paddingTop - paddingBottom, node.image.width, node.image.height, objectPositionX, objectPositionY);\n    if (node.image.data) {\n        if (width !== 0 && height !== 0) {\n            const cacheKey = node.image.key;\n            const image = imageCache.get(cacheKey) || embedImage(ctx, node);\n            if (cacheKey)\n                imageCache.set(cacheKey, image);\n            const imageOpacity = (0,_react_pdf_fns__WEBPACK_IMPORTED_MODULE_1__.isNil)(opacity) ? 1 : opacity;\n            ctx\n                .fillOpacity(imageOpacity)\n                .image(image, left + paddingLeft + xOffset, top + paddingTop + yOffset, {\n                width,\n                height,\n            });\n        }\n        else {\n            console.warn(`Image with src '${JSON.stringify(node.props.src || node.props.source)}' skipped due to invalid dimensions`);\n        }\n    }\n};\nconst renderImage = (ctx, node, options) => {\n    ctx.save();\n    clipNode(ctx, node);\n    drawImage(ctx, node, options);\n    ctx.restore();\n};\n\nconst CONTENT_COLOR = '#a1c6e7';\nconst PADDING_COLOR = '#c4deb9';\nconst MARGIN_COLOR = '#f8cca1';\n// TODO: Draw debug boxes using clipping to enhance quality\nconst debugContent = (ctx, node) => {\n    if (!node.box)\n        return;\n    const { left, top, width, height, paddingLeft = 0, paddingTop = 0, paddingRight = 0, paddingBottom = 0, borderLeftWidth = 0, borderTopWidth = 0, borderRightWidth = 0, borderBottomWidth = 0, } = node.box;\n    ctx\n        .fillColor(CONTENT_COLOR)\n        .opacity(0.5)\n        .rect(left + paddingLeft + borderLeftWidth, top + paddingTop + borderTopWidth, width - paddingLeft - paddingRight - borderRightWidth - borderLeftWidth, height - paddingTop - paddingBottom - borderTopWidth - borderBottomWidth)\n        .fill();\n};\nconst debugPadding = (ctx, node) => {\n    if (!node.box)\n        return;\n    const { left, top, width, height, paddingLeft = 0, paddingTop = 0, paddingRight = 0, paddingBottom = 0, borderLeftWidth = 0, borderTopWidth = 0, borderRightWidth = 0, borderBottomWidth = 0, } = node.box;\n    ctx.fillColor(PADDING_COLOR).opacity(0.5);\n    // Padding top\n    ctx\n        .rect(left + paddingLeft + borderLeftWidth, top + borderTopWidth, width - paddingRight - paddingLeft - borderLeftWidth - borderRightWidth, paddingTop)\n        .fill();\n    // Padding left\n    ctx\n        .rect(left + borderLeftWidth, top + borderTopWidth, paddingLeft, height - borderTopWidth - borderBottomWidth)\n        .fill();\n    // Padding right\n    ctx\n        .rect(left + width - paddingRight - borderRightWidth, top + borderTopWidth, paddingRight, height - borderTopWidth - borderBottomWidth)\n        .fill();\n    // Padding bottom\n    ctx\n        .rect(left + paddingLeft + borderLeftWidth, top + height - paddingBottom - borderBottomWidth, width - paddingRight - paddingLeft - borderLeftWidth - borderRightWidth, paddingBottom)\n        .fill();\n};\nconst debugMargin = (ctx, node) => {\n    if (!node.box)\n        return;\n    const { left, top, width, height } = node.box;\n    const { marginLeft = 0, marginTop = 0, marginRight = 0, marginBottom = 0, } = node.box;\n    ctx.fillColor(MARGIN_COLOR).opacity(0.5);\n    // Margin top\n    ctx.rect(left, top - marginTop, width, marginTop).fill();\n    // Margin left\n    ctx\n        .rect(left - marginLeft, top - marginTop, marginLeft, height + marginTop + marginBottom)\n        .fill();\n    // Margin right\n    ctx\n        .rect(left + width, top - marginTop, marginRight, height + marginTop + marginBottom)\n        .fill();\n    // Margin bottom\n    ctx.rect(left, top + height, width, marginBottom).fill();\n};\nconst debugText = (ctx, node) => {\n    if (!node.box)\n        return;\n    const { left, top, width, height } = node.box;\n    const { marginLeft = 0, marginTop = 0, marginRight = 0, marginBottom = 0, } = node.box;\n    const roundedWidth = Math.round(width + marginLeft + marginRight);\n    const roundedHeight = Math.round(height + marginTop + marginBottom);\n    ctx\n        .fontSize(6)\n        .opacity(1)\n        .fillColor('black')\n        .text(`${roundedWidth} x ${roundedHeight}`, left - marginLeft, Math.max(top - marginTop - 4, 1), { width: Infinity });\n};\nconst debugOrigin = (ctx, node) => {\n    if (node.origin) {\n        ctx\n            .circle(node.origin.left, node.origin.top, 3)\n            .fill('red')\n            .circle(node.origin.left, node.origin.top, 5)\n            .stroke('red');\n    }\n};\nconst renderDebug = (ctx, node) => {\n    if (!node.props)\n        return;\n    if (!('debug' in node.props) || !node.props.debug)\n        return;\n    ctx.save();\n    debugContent(ctx, node);\n    debugPadding(ctx, node);\n    debugMargin(ctx, node);\n    debugText(ctx, node);\n    debugOrigin(ctx, node);\n    ctx.restore();\n};\n\nconst availableMethods = [\n    'dash',\n    'clip',\n    'save',\n    'path',\n    'fill',\n    'font',\n    'text',\n    'rect',\n    'scale',\n    'moveTo',\n    'lineTo',\n    'stroke',\n    'rotate',\n    'circle',\n    'lineCap',\n    'opacity',\n    'ellipse',\n    'polygon',\n    'restore',\n    'lineJoin',\n    'fontSize',\n    'fillColor',\n    'lineWidth',\n    'translate',\n    'miterLimit',\n    'strokeColor',\n    'fillOpacity',\n    'roundedRect',\n    'fillAndStroke',\n    'strokeOpacity',\n    'bezierCurveTo',\n    'quadraticCurveTo',\n    'linearGradient',\n    'radialGradient',\n];\nconst painter = (ctx) => {\n    const p = availableMethods.reduce((acc, prop) => ({\n        ...acc,\n        [prop]: (...args) => {\n            // @ts-expect-error ctx[prop] is a function\n            ctx[prop](...args);\n            return p;\n        },\n    }), {});\n    return p;\n};\nconst renderCanvas = (ctx, node) => {\n    if (!node.box)\n        return;\n    const { top, left, width, height } = node.box;\n    const paddingTop = node.box.paddingTop || 0;\n    const paddingLeft = node.box.paddingLeft || 0;\n    const paddingRight = node.box.paddingRight || 0;\n    const paddingBottom = node.box.paddingBottom || 0;\n    const availableWidth = width - paddingLeft - paddingRight;\n    const availableHeight = height - paddingTop - paddingBottom;\n    if (!availableWidth || !availableHeight) {\n        console.warn('Canvas element has null width or height. Please provide valid values via the `style` prop in order to correctly render it.');\n    }\n    ctx.save().translate(left + paddingLeft, top + paddingTop);\n    if (node.props.paint) {\n        node.props.paint(painter(ctx), availableWidth, availableHeight);\n    }\n    ctx.restore();\n};\n\n// Ref: https://www.w3.org/TR/css-backgrounds-3/#borders\n// This constant is used to approximate a symmetrical arc using a cubic Bezier curve.\nconst KAPPA = 4.0 * ((Math.sqrt(2) - 1.0) / 3.0);\nconst clipBorderTop = (ctx, layout, style, rtr, rtl) => {\n    const { top, left, width, height } = layout;\n    const { borderTopWidth, borderRightWidth, borderLeftWidth } = style;\n    // Clip outer top border edge\n    ctx.moveTo(left + rtl, top);\n    ctx.lineTo(left + width - rtr, top);\n    // Ellipse coefficients outer top right cap\n    const c0 = rtr * (1.0 - KAPPA);\n    // Clip outer top right cap\n    ctx.bezierCurveTo(left + width - c0, top, left + width, top + c0, left + width, top + rtr);\n    // Move down in case the margin exceedes the radius\n    const topRightYCoord = top + Math.max(borderTopWidth, rtr);\n    ctx.lineTo(left + width, topRightYCoord);\n    // Clip inner top right cap\n    ctx.lineTo(left + width - borderRightWidth, topRightYCoord);\n    // Ellipse coefficients inner top right cap\n    const innerTopRightRadiusX = Math.max(rtr - borderRightWidth, 0);\n    const innerTopRightRadiusY = Math.max(rtr - borderTopWidth, 0);\n    const c1 = innerTopRightRadiusX * (1.0 - KAPPA);\n    const c2 = innerTopRightRadiusY * (1.0 - KAPPA);\n    // Clip inner top right cap\n    ctx.bezierCurveTo(left + width - borderRightWidth, top + borderTopWidth + c2, left + width - borderRightWidth - c1, top + borderTopWidth, left + width - borderRightWidth - innerTopRightRadiusX, top + borderTopWidth);\n    // Clip inner top border edge\n    ctx.lineTo(left + Math.max(rtl, borderLeftWidth), top + borderTopWidth);\n    // Ellipse coefficients inner top left cap\n    const innerTopLeftRadiusX = Math.max(rtl - borderLeftWidth, 0);\n    const innerTopLeftRadiusY = Math.max(rtl - borderTopWidth, 0);\n    const c3 = innerTopLeftRadiusX * (1.0 - KAPPA);\n    const c4 = innerTopLeftRadiusY * (1.0 - KAPPA);\n    const topLeftYCoord = top + Math.max(borderTopWidth, rtl);\n    // Clip inner top left cap\n    ctx.bezierCurveTo(left + borderLeftWidth + c3, top + borderTopWidth, left + borderLeftWidth, top + borderTopWidth + c4, left + borderLeftWidth, topLeftYCoord);\n    ctx.lineTo(left, topLeftYCoord);\n    // Move down in case the margin exceedes the radius\n    ctx.lineTo(left, top + rtl);\n    // Ellipse coefficients outer top left cap\n    const c5 = rtl * (1.0 - KAPPA);\n    // Clip outer top left cap\n    ctx.bezierCurveTo(left, top + c5, left + c5, top, left + rtl, top);\n    ctx.closePath();\n    ctx.clip();\n    // Clip border top cap joins\n    if (borderRightWidth) {\n        const trSlope = -borderTopWidth / borderRightWidth;\n        ctx.moveTo(left + width / 2, trSlope * (-width / 2) + top);\n        ctx.lineTo(left + width, top);\n        ctx.lineTo(left, top);\n        ctx.lineTo(left, top + height);\n        ctx.closePath();\n        ctx.clip();\n    }\n    if (borderLeftWidth) {\n        const trSlope = -borderTopWidth / borderLeftWidth;\n        ctx.moveTo(left + width / 2, trSlope * (-width / 2) + top);\n        ctx.lineTo(left, top);\n        ctx.lineTo(left + width, top);\n        ctx.lineTo(left + width, top + height);\n        ctx.closePath();\n        ctx.clip();\n    }\n};\nconst fillBorderTop = (ctx, layout, style, rtr, rtl) => {\n    const { top, left, width } = layout;\n    const { borderTopColor, borderTopWidth, borderTopStyle, borderRightWidth, borderLeftWidth, } = style;\n    const c0 = rtl * (1.0 - KAPPA);\n    const c1 = rtr * (1.0 - KAPPA);\n    ctx.moveTo(left, top + Math.max(rtl, borderTopWidth));\n    ctx.bezierCurveTo(left, top + c0, left + c0, top, left + rtl, top);\n    ctx.lineTo(left + width - rtr, top);\n    ctx.bezierCurveTo(left + width - c1, top, left + width, top + c1, left + width, top + rtr);\n    ctx.strokeColor(borderTopColor);\n    ctx.lineWidth(Math.max(borderRightWidth, borderTopWidth, borderLeftWidth) * 2);\n    if (borderTopStyle === 'dashed') {\n        ctx.dash(borderTopWidth * 2, { space: borderTopWidth * 1.2 });\n    }\n    else if (borderTopStyle === 'dotted') {\n        ctx.dash(borderTopWidth, { space: borderTopWidth * 1.2 });\n    }\n    ctx.stroke();\n    ctx.undash();\n};\nconst clipBorderRight = (ctx, layout, style, rtr, rbr) => {\n    const { top, left, width, height } = layout;\n    const { borderTopWidth, borderRightWidth, borderBottomWidth } = style;\n    // Clip outer right border edge\n    ctx.moveTo(left + width, top + rtr);\n    ctx.lineTo(left + width, top + height - rbr);\n    // Ellipse coefficients outer bottom right cap\n    const c0 = rbr * (1.0 - KAPPA);\n    // Clip outer top right cap\n    ctx.bezierCurveTo(left + width, top + height - c0, left + width - c0, top + height, left + width - rbr, top + height);\n    // Move left in case the margin exceedes the radius\n    const topBottomXCoord = left + width - Math.max(borderRightWidth, rbr);\n    ctx.lineTo(topBottomXCoord, top + height);\n    // Clip inner bottom right cap\n    ctx.lineTo(topBottomXCoord, top + height - borderBottomWidth);\n    // Ellipse coefficients inner bottom right cap\n    const innerBottomRightRadiusX = Math.max(rbr - borderRightWidth, 0);\n    const innerBottomRightRadiusY = Math.max(rbr - borderBottomWidth, 0);\n    const c1 = innerBottomRightRadiusX * (1.0 - KAPPA);\n    const c2 = innerBottomRightRadiusY * (1.0 - KAPPA);\n    // Clip inner top right cap\n    ctx.bezierCurveTo(left + width - borderRightWidth - c1, top + height - borderBottomWidth, left + width - borderRightWidth, top + height - borderBottomWidth - c2, left + width - borderRightWidth, top + height - Math.max(rbr, borderBottomWidth));\n    // Clip inner right border edge\n    ctx.lineTo(left + width - borderRightWidth, top + Math.max(rtr, borderTopWidth));\n    // Ellipse coefficients inner top right cap\n    const innerTopRightRadiusX = Math.max(rtr - borderRightWidth, 0);\n    const innerTopRightRadiusY = Math.max(rtr - borderTopWidth, 0);\n    const c3 = innerTopRightRadiusX * (1.0 - KAPPA);\n    const c4 = innerTopRightRadiusY * (1.0 - KAPPA);\n    const topRightXCoord = left + width - Math.max(rtr, borderRightWidth);\n    // Clip inner top left cap\n    ctx.bezierCurveTo(left + width - borderRightWidth, top + borderTopWidth + c4, left + width - borderRightWidth - c3, top + borderTopWidth, topRightXCoord, top + borderTopWidth);\n    ctx.lineTo(topRightXCoord, top);\n    // Move right in case the margin exceedes the radius\n    ctx.lineTo(left + width - rtr, top);\n    // Ellipse coefficients outer top right cap\n    const c5 = rtr * (1.0 - KAPPA);\n    // Clip outer top right cap\n    ctx.bezierCurveTo(left + width - c5, top, left + width, top + c5, left + width, top + rtr);\n    ctx.closePath();\n    ctx.clip();\n    // Clip border right cap joins\n    if (borderTopWidth) {\n        const trSlope = -borderTopWidth / borderRightWidth;\n        ctx.moveTo(left + width / 2, trSlope * (-width / 2) + top);\n        ctx.lineTo(left + width, top);\n        ctx.lineTo(left + width, top + height);\n        ctx.lineTo(left, top + height);\n        ctx.closePath();\n        ctx.clip();\n    }\n    if (borderBottomWidth) {\n        const brSlope = borderBottomWidth / borderRightWidth;\n        ctx.moveTo(left + width / 2, brSlope * (-width / 2) + top + height);\n        ctx.lineTo(left + width, top + height);\n        ctx.lineTo(left + width, top);\n        ctx.lineTo(left, top);\n        ctx.closePath();\n        ctx.clip();\n    }\n};\nconst fillBorderRight = (ctx, layout, style, rtr, rbr) => {\n    const { top, left, width, height } = layout;\n    const { borderRightColor, borderRightStyle, borderRightWidth, borderTopWidth, borderBottomWidth, } = style;\n    const c0 = rbr * (1.0 - KAPPA);\n    const c1 = rtr * (1.0 - KAPPA);\n    ctx.moveTo(left + width - rtr, top);\n    ctx.bezierCurveTo(left + width - c1, top, left + width, top + c1, left + width, top + rtr);\n    ctx.lineTo(left + width, top + height - rbr);\n    ctx.bezierCurveTo(left + width, top + height - c0, left + width - c0, top + height, left + width - rbr, top + height);\n    ctx.strokeColor(borderRightColor);\n    ctx.lineWidth(Math.max(borderRightWidth, borderTopWidth, borderBottomWidth) * 2);\n    if (borderRightStyle === 'dashed') {\n        ctx.dash(borderRightWidth * 2, { space: borderRightWidth * 1.2 });\n    }\n    else if (borderRightStyle === 'dotted') {\n        ctx.dash(borderRightWidth, { space: borderRightWidth * 1.2 });\n    }\n    ctx.stroke();\n    ctx.undash();\n};\nconst clipBorderBottom = (ctx, layout, style, rbl, rbr) => {\n    const { top, left, width, height } = layout;\n    const { borderBottomWidth, borderRightWidth, borderLeftWidth } = style;\n    // Clip outer top border edge\n    ctx.moveTo(left + width - rbr, top + height);\n    ctx.lineTo(left + rbl, top + height);\n    // Ellipse coefficients outer top right cap\n    const c0 = rbl * (1.0 - KAPPA);\n    // Clip outer top right cap\n    ctx.bezierCurveTo(left + c0, top + height, left, top + height - c0, left, top + height - rbl);\n    // Move up in case the margin exceedes the radius\n    const bottomLeftYCoord = top + height - Math.max(borderBottomWidth, rbl);\n    ctx.lineTo(left, bottomLeftYCoord);\n    // Clip inner bottom left cap\n    ctx.lineTo(left + borderLeftWidth, bottomLeftYCoord);\n    // Ellipse coefficients inner top right cap\n    const innerBottomLeftRadiusX = Math.max(rbl - borderLeftWidth, 0);\n    const innerBottomLeftRadiusY = Math.max(rbl - borderBottomWidth, 0);\n    const c1 = innerBottomLeftRadiusX * (1.0 - KAPPA);\n    const c2 = innerBottomLeftRadiusY * (1.0 - KAPPA);\n    // Clip inner bottom left cap\n    ctx.bezierCurveTo(left + borderLeftWidth, top + height - borderBottomWidth - c2, left + borderLeftWidth + c1, top + height - borderBottomWidth, left + borderLeftWidth + innerBottomLeftRadiusX, top + height - borderBottomWidth);\n    // Clip inner bottom border edge\n    ctx.lineTo(left + width - Math.max(rbr, borderRightWidth), top + height - borderBottomWidth);\n    // Ellipse coefficients inner top left cap\n    const innerBottomRightRadiusX = Math.max(rbr - borderRightWidth, 0);\n    const innerBottomRightRadiusY = Math.max(rbr - borderBottomWidth, 0);\n    const c3 = innerBottomRightRadiusX * (1.0 - KAPPA);\n    const c4 = innerBottomRightRadiusY * (1.0 - KAPPA);\n    const bottomRightYCoord = top + height - Math.max(borderBottomWidth, rbr);\n    // Clip inner top left cap\n    ctx.bezierCurveTo(left + width - borderRightWidth - c3, top + height - borderBottomWidth, left + width - borderRightWidth, top + height - borderBottomWidth - c4, left + width - borderRightWidth, bottomRightYCoord);\n    ctx.lineTo(left + width, bottomRightYCoord);\n    // Move down in case the margin exceedes the radius\n    ctx.lineTo(left + width, top + height - rbr);\n    // Ellipse coefficients outer top left cap\n    const c5 = rbr * (1.0 - KAPPA);\n    // Clip outer top left cap\n    ctx.bezierCurveTo(left + width, top + height - c5, left + width - c5, top + height, left + width - rbr, top + height);\n    ctx.closePath();\n    ctx.clip();\n    // Clip border bottom cap joins\n    if (borderRightWidth) {\n        const brSlope = borderBottomWidth / borderRightWidth;\n        ctx.moveTo(left + width / 2, brSlope * (-width / 2) + top + height);\n        ctx.lineTo(left + width, top + height);\n        ctx.lineTo(left, top + height);\n        ctx.lineTo(left, top);\n        ctx.closePath();\n        ctx.clip();\n    }\n    if (borderLeftWidth) {\n        const trSlope = -borderBottomWidth / borderLeftWidth;\n        ctx.moveTo(left + width / 2, trSlope * (width / 2) + top + height);\n        ctx.lineTo(left, top + height);\n        ctx.lineTo(left + width, top + height);\n        ctx.lineTo(left + width, top);\n        ctx.closePath();\n        ctx.clip();\n    }\n};\nconst fillBorderBottom = (ctx, layout, style, rbl, rbr) => {\n    const { top, left, width, height } = layout;\n    const { borderBottomColor, borderBottomStyle, borderBottomWidth, borderRightWidth, borderLeftWidth, } = style;\n    const c0 = rbl * (1.0 - KAPPA);\n    const c1 = rbr * (1.0 - KAPPA);\n    ctx.moveTo(left + width, top + height - rbr);\n    ctx.bezierCurveTo(left + width, top + height - c1, left + width - c1, top + height, left + width - rbr, top + height);\n    ctx.lineTo(left + rbl, top + height);\n    ctx.bezierCurveTo(left + c0, top + height, left, top + height - c0, left, top + height - rbl);\n    ctx.strokeColor(borderBottomColor);\n    ctx.lineWidth(Math.max(borderBottomWidth, borderRightWidth, borderLeftWidth) * 2);\n    if (borderBottomStyle === 'dashed') {\n        ctx.dash(borderBottomWidth * 2, { space: borderBottomWidth * 1.2 });\n    }\n    else if (borderBottomStyle === 'dotted') {\n        ctx.dash(borderBottomWidth, { space: borderBottomWidth * 1.2 });\n    }\n    ctx.stroke();\n    ctx.undash();\n};\nconst clipBorderLeft = (ctx, layout, style, rbl, rtl) => {\n    const { top, left, width, height } = layout;\n    const { borderTopWidth, borderLeftWidth, borderBottomWidth } = style;\n    // Clip outer left border edge\n    ctx.moveTo(left, top + height - rbl);\n    ctx.lineTo(left, top + rtl);\n    // Ellipse coefficients outer top left cap\n    const c0 = rtl * (1.0 - KAPPA);\n    // Clip outer top left cap\n    ctx.bezierCurveTo(left, top + c0, left + c0, top, left + rtl, top);\n    // Move right in case the margin exceedes the radius\n    const topLeftCoordX = left + Math.max(borderLeftWidth, rtl);\n    ctx.lineTo(topLeftCoordX, top);\n    // Clip inner top left cap\n    ctx.lineTo(topLeftCoordX, top + borderTopWidth);\n    // Ellipse coefficients inner top left cap\n    const innerTopLeftRadiusX = Math.max(rtl - borderLeftWidth, 0);\n    const innerTopLeftRadiusY = Math.max(rtl - borderTopWidth, 0);\n    const c1 = innerTopLeftRadiusX * (1.0 - KAPPA);\n    const c2 = innerTopLeftRadiusY * (1.0 - KAPPA);\n    // Clip inner top right cap\n    ctx.bezierCurveTo(left + borderLeftWidth + c1, top + borderTopWidth, left + borderLeftWidth, top + borderTopWidth + c2, left + borderLeftWidth, top + Math.max(rtl, borderTopWidth));\n    // Clip inner left border edge\n    ctx.lineTo(left + borderLeftWidth, top + height - Math.max(rbl, borderBottomWidth));\n    // Ellipse coefficients inner bottom left cap\n    const innerBottomLeftRadiusX = Math.max(rbl - borderLeftWidth, 0);\n    const innerBottomLeftRadiusY = Math.max(rbl - borderBottomWidth, 0);\n    const c3 = innerBottomLeftRadiusX * (1.0 - KAPPA);\n    const c4 = innerBottomLeftRadiusY * (1.0 - KAPPA);\n    const bottomLeftXCoord = left + Math.max(rbl, borderLeftWidth);\n    // Clip inner top left cap\n    ctx.bezierCurveTo(left + borderLeftWidth, top + height - borderBottomWidth - c4, left + borderLeftWidth + c3, top + height - borderBottomWidth, bottomLeftXCoord, top + height - borderBottomWidth);\n    ctx.lineTo(bottomLeftXCoord, top + height);\n    // Move left in case the margin exceedes the radius\n    ctx.lineTo(left + rbl, top + height);\n    // Ellipse coefficients outer top right cap\n    const c5 = rbl * (1.0 - KAPPA);\n    // Clip outer top right cap\n    ctx.bezierCurveTo(left + c5, top + height, left, top + height - c5, left, top + height - rbl);\n    ctx.closePath();\n    ctx.clip();\n    // Clip border right cap joins\n    if (borderBottomWidth) {\n        const trSlope = -borderBottomWidth / borderLeftWidth;\n        ctx.moveTo(left + width / 2, trSlope * (width / 2) + top + height);\n        ctx.lineTo(left, top + height);\n        ctx.lineTo(left, top);\n        ctx.lineTo(left + width, top);\n        ctx.closePath();\n        ctx.clip();\n    }\n    if (borderBottomWidth) {\n        const trSlope = -borderTopWidth / borderLeftWidth;\n        ctx.moveTo(left + width / 2, trSlope * (-width / 2) + top);\n        ctx.lineTo(left, top);\n        ctx.lineTo(left, top + height);\n        ctx.lineTo(left + width, top + height);\n        ctx.closePath();\n        ctx.clip();\n    }\n};\nconst fillBorderLeft = (ctx, layout, style, rbl, rtl) => {\n    const { top, left, height } = layout;\n    const { borderLeftColor, borderLeftStyle, borderLeftWidth, borderTopWidth, borderBottomWidth, } = style;\n    const c0 = rbl * (1.0 - KAPPA);\n    const c1 = rtl * (1.0 - KAPPA);\n    ctx.moveTo(left + rbl, top + height);\n    ctx.bezierCurveTo(left + c0, top + height, left, top + height - c0, left, top + height - rbl);\n    ctx.lineTo(left, top + rtl);\n    ctx.bezierCurveTo(left, top + c1, left + c1, top, left + rtl, top);\n    ctx.strokeColor(borderLeftColor);\n    ctx.lineWidth(Math.max(borderLeftWidth, borderTopWidth, borderBottomWidth) * 2);\n    if (borderLeftStyle === 'dashed') {\n        ctx.dash(borderLeftWidth * 2, { space: borderLeftWidth * 1.2 });\n    }\n    else if (borderLeftStyle === 'dotted') {\n        ctx.dash(borderLeftWidth, { space: borderLeftWidth * 1.2 });\n    }\n    ctx.stroke();\n    ctx.undash();\n};\nconst shouldRenderBorders = (node) => node.box &&\n    (node.box.borderTopWidth ||\n        node.box.borderRightWidth ||\n        node.box.borderBottomWidth ||\n        node.box.borderLeftWidth);\nconst renderBorders = (ctx, node) => {\n    if (!node.box)\n        return;\n    if (!shouldRenderBorders(node))\n        return;\n    const { width, height, borderTopWidth = 0, borderLeftWidth = 0, borderRightWidth = 0, borderBottomWidth = 0, } = node.box;\n    const { opacity = 1, borderTopColor = 'black', borderTopStyle = 'solid', borderLeftColor = 'black', borderLeftStyle = 'solid', borderRightColor = 'black', borderRightStyle = 'solid', borderBottomColor = 'black', borderBottomStyle = 'solid', } = node.style;\n    // @ts-expect-error this is always a number due to resolve border radius step\n    const borderTopLeftRadius = node.style.borderTopLeftRadius || 0;\n    // @ts-expect-error this is always a number due to resolve border radius step\n    const borderTopRightRadius = node.style.borderTopRightRadius || 0;\n    // @ts-expect-error this is always a number due to resolve border radius step\n    const borderBottomLeftRadius = node.style.borderBottomLeftRadius || 0;\n    // @ts-expect-error this is always a number due to resolve border radius step\n    const borderBottomRightRadius = node.style.borderBottomRightRadius || 0;\n    const style = {\n        borderTopColor,\n        borderTopWidth,\n        borderTopStyle,\n        borderLeftColor,\n        borderLeftWidth,\n        borderLeftStyle,\n        borderRightColor,\n        borderRightWidth,\n        borderRightStyle,\n        borderBottomColor,\n        borderBottomWidth,\n        borderBottomStyle};\n    const rtr = Math.min(borderTopRightRadius, 0.5 * width, 0.5 * height);\n    const rtl = Math.min(borderTopLeftRadius, 0.5 * width, 0.5 * height);\n    const rbr = Math.min(borderBottomRightRadius, 0.5 * width, 0.5 * height);\n    const rbl = Math.min(borderBottomLeftRadius, 0.5 * width, 0.5 * height);\n    ctx.save();\n    ctx.strokeOpacity(opacity);\n    if (borderTopWidth) {\n        ctx.save();\n        clipBorderTop(ctx, node.box, style, rtr, rtl);\n        fillBorderTop(ctx, node.box, style, rtr, rtl);\n        ctx.restore();\n    }\n    if (borderRightWidth) {\n        ctx.save();\n        clipBorderRight(ctx, node.box, style, rtr, rbr);\n        fillBorderRight(ctx, node.box, style, rtr, rbr);\n        ctx.restore();\n    }\n    if (borderBottomWidth) {\n        ctx.save();\n        clipBorderBottom(ctx, node.box, style, rbl, rbr);\n        fillBorderBottom(ctx, node.box, style, rbl, rbr);\n        ctx.restore();\n    }\n    if (borderLeftWidth) {\n        ctx.save();\n        clipBorderLeft(ctx, node.box, style, rbl, rtl);\n        fillBorderLeft(ctx, node.box, style, rbl, rtl);\n        ctx.restore();\n    }\n    ctx.restore();\n};\n\nconst drawBackground = (ctx, node) => {\n    if (!node.box)\n        return;\n    const { top, left, width, height } = node.box;\n    const color = parseColor(node.style.backgroundColor);\n    const nodeOpacity = (0,_react_pdf_fns__WEBPACK_IMPORTED_MODULE_1__.isNil)(node.style?.opacity) ? 1 : node.style.opacity;\n    const opacity = Math.min(color.opacity, nodeOpacity);\n    ctx\n        .fillOpacity(opacity)\n        .fillColor(color.value)\n        .rect(left, top, width, height)\n        .fill();\n};\nconst renderBackground = (ctx, node) => {\n    const hasBackground = !!node.box && !!node.style?.backgroundColor;\n    if (hasBackground) {\n        ctx.save();\n        clipNode(ctx, node);\n        drawBackground(ctx, node);\n        ctx.restore();\n    }\n};\n\nconst isString = (value) => typeof value === 'string';\nconst isSrcId = (value) => /^#.+/.test(value);\nconst renderLink = (ctx, node, src) => {\n    if (!src || !node.box)\n        return;\n    const isId = isSrcId(src);\n    const method = isId ? 'goTo' : 'link';\n    const value = isId ? src.slice(1) : src;\n    const { top, left, width, height } = node.box;\n    ctx[method](left, top, width, height, value);\n};\nconst setLink = (ctx, node) => {\n    const props = node.props || {};\n    if ('src' in props && isString(props.src))\n        return renderLink(ctx, node, props.src);\n    if ('href' in props && isString(props.href))\n        return renderLink(ctx, node, props.href);\n};\n\nconst setDestination = (ctx, node) => {\n    if (!node.box)\n        return;\n    if (!node.props)\n        return;\n    if ('id' in node.props) {\n        ctx.addNamedDestination(node.props.id, 'XYZ', null, node.box.top, null);\n    }\n};\n\nconst clean = (options) => {\n    const opt = { ...options };\n    // We need to ensure the elements are no present if not true\n    Object.entries(opt).forEach((pair) => {\n        if (!pair[1]) {\n            delete opt[pair[0]];\n        }\n    });\n    return opt;\n};\nconst parseCommonFormOptions = (node) => {\n    // Common Options\n    return {\n        required: node.props?.required || false,\n        noExport: node.props?.noExport || false,\n        readOnly: node.props?.readOnly || false,\n        value: node.props?.value || undefined,\n        defaultValue: node.props?.defaultValue || undefined,\n    };\n};\nconst parseTextInputOptions = (node, fieldSet) => {\n    return clean({\n        ...parseCommonFormOptions(node),\n        parent: fieldSet || undefined,\n        align: node.props?.align || 'left',\n        multiline: node.props?.multiline || undefined,\n        password: node.props?.password || false,\n        noSpell: node.props?.noSpell || false,\n        format: node.props?.format || undefined,\n        fontSize: node.props?.fontSize || undefined,\n        MaxLen: node.props?.maxLength || undefined,\n    });\n};\nconst parseSelectAndListFieldOptions = (node) => {\n    return clean({\n        ...parseCommonFormOptions(node),\n        sort: node.props?.sort || false,\n        edit: node.props?.edit || false,\n        multiSelect: node.props?.multiSelect || false,\n        noSpell: node.props?.noSpell || false,\n        select: node.props?.select || [''],\n    });\n};\nconst getAppearance = (ctx, codepoint, width, height) => {\n    const appearance = ctx.ref({\n        Type: 'XObject',\n        Subtype: 'Form',\n        BBox: [0, 0, width, height],\n        Resources: {\n            ProcSet: ['PDF', 'Text', 'ImageB', 'ImageC', 'ImageI'],\n            Font: {\n                ZaDi: ctx._acroform.fonts.ZaDi,\n            },\n        },\n    });\n    appearance.initDeflate();\n    appearance.write(`/Tx BMC\\nq\\n/ZaDi ${height * 0.8} Tf\\nBT\\n${width * 0.45} ${height / 4} Td (${codepoint}) Tj\\nET\\nQ\\nEMC`);\n    appearance.end(null);\n    return appearance;\n};\nconst parseCheckboxOptions = (ctx, node, fieldSet) => {\n    const { width, height } = node.box || {};\n    const onOption = node.props?.onState || 'Yes';\n    const offOption = node.props?.offState || 'Off';\n    const xMark = node.props?.xMark || false;\n    if (!Object.prototype.hasOwnProperty.call(ctx._acroform.fonts, 'ZaDi')) {\n        const ref = ctx.ref({\n            Type: 'Font',\n            Subtype: 'Type1',\n            BaseFont: 'ZapfDingbats',\n        });\n        ctx._acroform.fonts.ZaDi = ref;\n        ref.end(null);\n    }\n    const normalAppearance = {\n        [onOption]: getAppearance(ctx, xMark ? '8' : '4', width, height),\n        [offOption]: getAppearance(ctx, xMark ? ' ' : '8', width, height),\n    };\n    return clean({\n        ...parseCommonFormOptions(node),\n        backgroundColor: node.props?.backgroundColor || undefined,\n        borderColor: node.props?.borderColor || undefined,\n        parent: fieldSet || undefined,\n        value: `/${node.props?.checked === true ? onOption : offOption}`,\n        defaultValue: `/${node.props?.checked === true ? onOption : offOption}`,\n        AS: node.props?.checked === true ? onOption : offOption,\n        AP: { N: normalAppearance, D: normalAppearance },\n    });\n};\n\nconst renderTextInput = (ctx, node, options) => {\n    if (!node.box)\n        return;\n    const { top, left, width, height } = node.box;\n    // Element's name\n    const name = node.props?.name || '';\n    const fieldSetOptions = options.fieldSets?.at(0);\n    if (!ctx._root.data.AcroForm) {\n        ctx.initForm();\n    }\n    ctx.formText(name, left, top, width, height, parseTextInputOptions(node, fieldSetOptions));\n};\n\nconst renderSelect = (ctx, node) => {\n    if (!node.box)\n        return;\n    const { top, left, width, height } = node.box;\n    // Element's name\n    const name = node.props?.name || '';\n    if (!ctx._root.data.AcroForm) {\n        ctx.initForm();\n    }\n    ctx.formCombo(name, left, top, width, height, parseSelectAndListFieldOptions(node));\n};\n\nconst renderFieldSet = (ctx, node, options) => {\n    const name = node.props?.name || '';\n    if (!ctx._root.data.AcroForm) {\n        ctx.initForm();\n    }\n    const formField = ctx.formField(name);\n    const option = options;\n    if (!option.fieldSets) {\n        option.fieldSets = [formField];\n    }\n    else {\n        option.fieldSets.push(formField);\n    }\n};\nconst cleanUpFieldSet = (_ctx, _node, options) => {\n    options.fieldSets.pop();\n};\n\nconst renderList = (ctx, node) => {\n    if (!node.box)\n        return;\n    const { top, left, width, height } = node.box || {};\n    // Element's name\n    const name = ('name' in node.props ? node.props.name || '' : '');\n    if (!ctx._root.data.AcroForm) {\n        ctx.initForm();\n    }\n    ctx.formList(name, left, top, width, height, parseSelectAndListFieldOptions(node));\n};\n\nconst renderCheckbox = (ctx, node, options) => {\n    if (!node.box)\n        return;\n    const { top, left, width, height } = node.box;\n    // Element's name\n    const name = node.props?.name || '';\n    const fieldSetOptions = options.fieldSets?.at(0);\n    if (!ctx._root.data.AcroForm) {\n        ctx.initForm();\n    }\n    ctx.formCheckbox(name, left, top, width, height, parseCheckboxOptions(ctx, node, fieldSetOptions));\n};\n\nconst isRecursiveNode = (node) => node.type !== _react_pdf_primitives__WEBPACK_IMPORTED_MODULE_0__.Text && node.type !== _react_pdf_primitives__WEBPACK_IMPORTED_MODULE_0__.Svg;\nconst renderChildren = (ctx, node, options) => {\n    ctx.save();\n    if (node.box) {\n        ctx.translate(node.box.left, node.box.top);\n    }\n    const children = node.children || [];\n    const renderChild = (child) => renderNode(ctx, child, options);\n    children.forEach(renderChild);\n    ctx.restore();\n};\nconst renderFns = {\n    [_react_pdf_primitives__WEBPACK_IMPORTED_MODULE_0__.Text]: renderText,\n    [_react_pdf_primitives__WEBPACK_IMPORTED_MODULE_0__.Note]: renderNote,\n    [_react_pdf_primitives__WEBPACK_IMPORTED_MODULE_0__.Image]: renderImage,\n    [_react_pdf_primitives__WEBPACK_IMPORTED_MODULE_0__.FieldSet]: renderFieldSet,\n    [_react_pdf_primitives__WEBPACK_IMPORTED_MODULE_0__.TextInput]: renderTextInput,\n    [_react_pdf_primitives__WEBPACK_IMPORTED_MODULE_0__.Select]: renderSelect,\n    [_react_pdf_primitives__WEBPACK_IMPORTED_MODULE_0__.Checkbox]: renderCheckbox,\n    [_react_pdf_primitives__WEBPACK_IMPORTED_MODULE_0__.List]: renderList,\n    [_react_pdf_primitives__WEBPACK_IMPORTED_MODULE_0__.Canvas]: renderCanvas,\n    [_react_pdf_primitives__WEBPACK_IMPORTED_MODULE_0__.Svg]: renderSvg,\n    [_react_pdf_primitives__WEBPACK_IMPORTED_MODULE_0__.Link]: setLink,\n};\nconst cleanUpFns = {\n    [_react_pdf_primitives__WEBPACK_IMPORTED_MODULE_0__.FieldSet]: cleanUpFieldSet,\n};\nconst renderNode = (ctx, node, options) => {\n    const overflowHidden = node.style?.overflow === 'hidden';\n    const shouldRenderChildren = isRecursiveNode(node);\n    if (node.type === _react_pdf_primitives__WEBPACK_IMPORTED_MODULE_0__.Page)\n        renderPage(ctx, node);\n    ctx.save();\n    if (overflowHidden)\n        clipNode(ctx, node);\n    applyTransformations(ctx, node);\n    renderBackground(ctx, node);\n    renderBorders(ctx, node);\n    const renderFn = renderFns[node.type];\n    if (renderFn)\n        renderFn(ctx, node, options);\n    if (shouldRenderChildren)\n        renderChildren(ctx, node, options);\n    const cleanUpFn = cleanUpFns[node.type];\n    if (cleanUpFn)\n        cleanUpFn(ctx, node, options);\n    setDestination(ctx, node);\n    renderDebug(ctx, node);\n    ctx.restore();\n};\n\nconst addNodeBookmark = (ctx, node, pageNumber, registry) => {\n    if (!node.box)\n        return;\n    if (!node.props)\n        return;\n    if ('bookmark' in node.props && node.props.bookmark) {\n        const bookmark = node.props.bookmark;\n        const { title, parent, expanded, zoom, fit } = bookmark;\n        const outline = registry[parent] || ctx.outline;\n        const top = bookmark.top || node.box.top;\n        const left = bookmark.left || node.box.left;\n        const instance = outline.addItem(title, {\n            pageNumber,\n            expanded,\n            top,\n            left,\n            zoom,\n            fit,\n        });\n        registry[bookmark.ref] = instance;\n    }\n    if (!node.children)\n        return;\n    node.children.forEach((child) => addNodeBookmark(ctx, child, pageNumber, registry));\n};\nconst addBookmarks = (ctx, root) => {\n    const registry = {};\n    const pages = root.children || [];\n    pages.forEach((page, i) => {\n        addNodeBookmark(ctx, page, i, registry);\n    });\n};\n\nconst render = (ctx, doc) => {\n    const pages = doc.children || [];\n    const options = { imageCache: new Map(), fieldSets: [] };\n    pages.forEach((page) => renderNode(ctx, page, options));\n    addBookmarks(ctx, doc);\n    ctx.end();\n    return ctx;\n};\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQHJlYWN0LXBkZityZW5kZXJANC4zLjAvbm9kZV9tb2R1bGVzL0ByZWFjdC1wZGYvcmVuZGVyL2xpYi9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQTJDO0FBQ1U7QUFDbEI7QUFDSTtBQUNRO0FBQ1I7O0FBRXZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLGlCQUFpQjtBQUM3QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksaUJBQWlCO0FBQzdCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsRUFBRTtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsV0FBVyxFQUFFLFdBQVc7QUFDdEQ7QUFDQSx1QkFBdUIsY0FBYyxFQUFFLHVCQUF1QjtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLElBQUksSUFBSSxpQkFBaUI7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsbUJBQW1CO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixzQkFBc0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsaUNBQWlDLEVBQUUsaUNBQWlDO0FBQzFHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxXQUFXLEVBQUUsV0FBVztBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSwyQkFBMkI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0IsbUJBQW1CO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksZUFBZTtBQUMzQixZQUFZLHlCQUF5QjtBQUNyQztBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsZ0JBQWdCO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxnQkFBZ0I7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDJCQUEyQjtBQUN2QyxZQUFZLDhHQUE4RztBQUMxSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVksbUJBQW1CO0FBQy9CO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxRQUFRO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLFFBQVE7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsUUFBUTtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxVQUFVO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksZUFBZTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUIsOERBQWEsQ0FBQyx5Q0FBTyxDQUFDLDJDQUFTO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxPQUFPO0FBQzVDO0FBQ0Esd0JBQXdCLG1CQUFtQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyx1REFBTTtBQUNYLEtBQUssdURBQU07QUFDWCxLQUFLLHVEQUFNO0FBQ1gsS0FBSyx5REFBUTtBQUNiLEtBQUssMERBQVM7QUFDZCxLQUFLLDBEQUFTO0FBQ2QsS0FBSywyREFBVTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxxREFBSztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLHFEQUFLO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMscURBQUs7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxpRUFBZ0I7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxpRUFBZ0I7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssd0RBQU87QUFDWixLQUFLLCtEQUFjO0FBQ25CLEtBQUssdURBQU07QUFDWCxLQUFLLHVEQUFNO0FBQ1gsS0FBSyx1REFBTTtBQUNYLEtBQUssb0RBQUc7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ZWFzZS1wcmVkaWN0aW9uLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzLy5wbnBtL0ByZWFjdC1wZGYrcmVuZGVyQDQuMy4wL25vZGVfbW9kdWxlcy9AcmVhY3QtcGRmL3JlbmRlci9saWIvaW5kZXguanM/MmJmNCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBQIGZyb20gJ0ByZWFjdC1wZGYvcHJpbWl0aXZlcyc7XG5pbXBvcnQgeyBpc05pbCwgbWF0Y2hQZXJjZW50IH0gZnJvbSAnQHJlYWN0LXBkZi9mbnMnO1xuaW1wb3J0IGFic1BhdGggZnJvbSAnYWJzLXN2Zy1wYXRoJztcbmltcG9ydCBwYXJzZVBhdGggZnJvbSAncGFyc2Utc3ZnLXBhdGgnO1xuaW1wb3J0IG5vcm1hbGl6ZVBhdGggZnJvbSAnbm9ybWFsaXplLXN2Zy1wYXRoJztcbmltcG9ydCBjb2xvclN0cmluZyBmcm9tICdjb2xvci1zdHJpbmcnO1xuXG5jb25zdCByZW5kZXJQYXRoID0gKGN0eCwgbm9kZSkgPT4ge1xuICAgIGNvbnN0IGQgPSBub2RlLnByb3BzPy5kO1xuICAgIGlmIChkKVxuICAgICAgICBjdHgucGF0aChub2RlLnByb3BzLmQpO1xufTtcblxuY29uc3QgS0FQUEEkMyA9IDQuMCAqICgoTWF0aC5zcXJ0KDIpIC0gMS4wKSAvIDMuMCk7XG5jb25zdCByZW5kZXJSZWN0ID0gKGN0eCwgbm9kZSkgPT4ge1xuICAgIGNvbnN0IHggPSBub2RlLnByb3BzPy54IHx8IDA7XG4gICAgY29uc3QgeSA9IG5vZGUucHJvcHM/LnkgfHwgMDtcbiAgICBjb25zdCByeCA9IG5vZGUucHJvcHM/LnJ4IHx8IDA7XG4gICAgY29uc3QgcnkgPSBub2RlLnByb3BzPy5yeSB8fCAwO1xuICAgIGNvbnN0IHdpZHRoID0gbm9kZS5wcm9wcz8ud2lkdGggfHwgMDtcbiAgICBjb25zdCBoZWlnaHQgPSBub2RlLnByb3BzPy5oZWlnaHQgfHwgMDtcbiAgICBpZiAoIXdpZHRoIHx8ICFoZWlnaHQpXG4gICAgICAgIHJldHVybjtcbiAgICBpZiAocnggJiYgcnkpIHtcbiAgICAgICAgY29uc3Qga3J4ID0gcnggKiBLQVBQQSQzO1xuICAgICAgICBjb25zdCBrcnkgPSByeSAqIEtBUFBBJDM7XG4gICAgICAgIGN0eC5tb3ZlVG8oeCArIHJ4LCB5KTtcbiAgICAgICAgY3R4LmxpbmVUbyh4IC0gcnggKyB3aWR0aCwgeSk7XG4gICAgICAgIGN0eC5iZXppZXJDdXJ2ZVRvKHggLSByeCArIHdpZHRoICsga3J4LCB5LCB4ICsgd2lkdGgsIHkgKyByeSAtIGtyeSwgeCArIHdpZHRoLCB5ICsgcnkpO1xuICAgICAgICBjdHgubGluZVRvKHggKyB3aWR0aCwgeSArIGhlaWdodCAtIHJ5KTtcbiAgICAgICAgY3R4LmJlemllckN1cnZlVG8oeCArIHdpZHRoLCB5ICsgaGVpZ2h0IC0gcnkgKyBrcnksIHggLSByeCArIHdpZHRoICsga3J4LCB5ICsgaGVpZ2h0LCB4IC0gcnggKyB3aWR0aCwgeSArIGhlaWdodCk7XG4gICAgICAgIGN0eC5saW5lVG8oeCArIHJ4LCB5ICsgaGVpZ2h0KTtcbiAgICAgICAgY3R4LmJlemllckN1cnZlVG8oeCArIHJ4IC0ga3J4LCB5ICsgaGVpZ2h0LCB4LCB5ICsgaGVpZ2h0IC0gcnkgKyBrcnksIHgsIHkgKyBoZWlnaHQgLSByeSk7XG4gICAgICAgIGN0eC5saW5lVG8oeCwgeSArIHJ5KTtcbiAgICAgICAgY3R4LmJlemllckN1cnZlVG8oeCwgeSArIHJ5IC0ga3J5LCB4ICsgcnggLSBrcngsIHksIHggKyByeCwgeSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjdHgubW92ZVRvKHgsIHkpO1xuICAgICAgICBjdHgubGluZVRvKHggKyB3aWR0aCwgeSk7XG4gICAgICAgIGN0eC5saW5lVG8oeCArIHdpZHRoLCB5ICsgaGVpZ2h0KTtcbiAgICAgICAgY3R4LmxpbmVUbyh4LCB5ICsgaGVpZ2h0KTtcbiAgICB9XG4gICAgY3R4LmNsb3NlUGF0aCgpO1xufTtcblxuY29uc3QgcmVuZGVyTGluZSQxID0gKGN0eCwgbm9kZSkgPT4ge1xuICAgIGNvbnN0IHsgeDEsIHgyLCB5MSwgeTIgfSA9IG5vZGUucHJvcHMgfHwge307XG4gICAgY3R4Lm1vdmVUbyh4MSwgeTEpO1xuICAgIGN0eC5saW5lVG8oeDIsIHkyKTtcbn07XG5cbmNvbnN0IHJlbmRlckdyb3VwID0gKCkgPT4ge1xuICAgIC8vIG5vb3Bcbn07XG5cbmNvbnN0IEtBUFBBJDIgPSA0LjAgKiAoKE1hdGguc3FydCgyKSAtIDEuMCkgLyAzLjApO1xuY29uc3QgZHJhd0VsbGlwc2UgPSAoY3R4LCByeCwgcnksIGN4ID0gMCwgY3kgPSAwKSA9PiB7XG4gICAgY29uc3QgeCA9IGN4IC0gcng7XG4gICAgY29uc3QgeSA9IGN5IC0gcnk7XG4gICAgY29uc3Qgb3ggPSByeCAqIEtBUFBBJDI7XG4gICAgY29uc3Qgb3kgPSByeSAqIEtBUFBBJDI7XG4gICAgY29uc3QgeGUgPSB4ICsgcnggKiAyO1xuICAgIGNvbnN0IHllID0geSArIHJ5ICogMjtcbiAgICBjb25zdCB4bSA9IHggKyByeDtcbiAgICBjb25zdCB5bSA9IHkgKyByeTtcbiAgICBjdHgubW92ZVRvKHgsIHltKTtcbiAgICBjdHguYmV6aWVyQ3VydmVUbyh4LCB5bSAtIG95LCB4bSAtIG94LCB5LCB4bSwgeSk7XG4gICAgY3R4LmJlemllckN1cnZlVG8oeG0gKyBveCwgeSwgeGUsIHltIC0gb3ksIHhlLCB5bSk7XG4gICAgY3R4LmJlemllckN1cnZlVG8oeGUsIHltICsgb3ksIHhtICsgb3gsIHllLCB4bSwgeWUpO1xuICAgIGN0eC5iZXppZXJDdXJ2ZVRvKHhtIC0gb3gsIHllLCB4LCB5bSArIG95LCB4LCB5bSk7XG4gICAgY3R4LmNsb3NlUGF0aCgpO1xufTtcbmNvbnN0IHJlbmRlckVsbGlwc2UgPSAoY3R4LCBub2RlKSA9PiB7XG4gICAgY29uc3QgeyBjeCwgY3ksIHJ4LCByeSB9ID0gbm9kZS5wcm9wcyB8fCB7fTtcbiAgICBkcmF3RWxsaXBzZShjdHgsIHJ4LCByeSwgY3gsIGN5KTtcbn07XG5cbmNvbnN0IHJlbmRlckNpcmNsZSA9IChjdHgsIG5vZGUpID0+IHtcbiAgICBjb25zdCBjeCA9IG5vZGUucHJvcHM/LmN4O1xuICAgIGNvbnN0IGN5ID0gbm9kZS5wcm9wcz8uY3k7XG4gICAgY29uc3QgciA9IG5vZGUucHJvcHM/LnI7XG4gICAgZHJhd0VsbGlwc2UoY3R4LCByLCByLCBjeCwgY3kpO1xufTtcblxuLyogZXNsaW50LWRpc2FibGUgbm8tcmV0dXJuLWFzc2lnbiAqL1xuY29uc3QgbnVtYmVyID0gKG4pID0+IHtcbiAgICBpZiAobiA+IC0xZTIxICYmIG4gPCAxZTIxKSB7XG4gICAgICAgIHJldHVybiBNYXRoLnJvdW5kKG4gKiAxZTYpIC8gMWU2O1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoYHVuc3VwcG9ydGVkIG51bWJlcjogJHtufWApO1xufTtcbmNvbnN0IF9yZW5kZXJHbHlwaHMgPSAoY3R4LCBlbmNvZGVkLCBwb3NpdGlvbnMsIHgsIHkpID0+IHtcbiAgICBjb25zdCBjb21tYW5kcyA9IFtdO1xuICAgIGNvbnN0IHNjYWxlID0gY3R4Ll9mb250U2l6ZSAvIDEwMDA7XG4gICAgbGV0IGk7XG4gICAgbGV0IGxhc3QgPSAwO1xuICAgIGxldCBoYWRPZmZzZXQgPSBmYWxzZTtcbiAgICBjdHguc2F2ZSgpO1xuICAgIC8vIGZsaXAgY29vcmRpbmF0ZSBzeXN0ZW1cbiAgICBjdHgudHJhbnNmb3JtKDEsIDAsIDAsIC0xLCAwLCBjdHgucGFnZS5oZWlnaHQpO1xuICAgIHkgPSBjdHgucGFnZS5oZWlnaHQgLSB5O1xuICAgIC8vIGFkZCBjdXJyZW50IGZvbnQgdG8gcGFnZSBpZiBuZWNlc3NhcnlcbiAgICBpZiAoY3R4LnBhZ2UuZm9udHNbY3R4Ll9mb250LmlkXSA9PSBudWxsKSB7XG4gICAgICAgIGN0eC5wYWdlLmZvbnRzW2N0eC5fZm9udC5pZF0gPSBjdHguX2ZvbnQucmVmKCk7XG4gICAgfVxuICAgIC8vIGJlZ2luIHRoZSB0ZXh0IG9iamVjdFxuICAgIGN0eC5hZGRDb250ZW50KCdCVCcpO1xuICAgIC8vIHRleHQgcG9zaXRpb25cbiAgICBjdHguYWRkQ29udGVudChgMSAwIDAgMSAke251bWJlcih4KX0gJHtudW1iZXIoeSl9IFRtYCk7XG4gICAgLy8gZm9udCBhbmQgZm9udCBzaXplXG4gICAgY3R4LmFkZENvbnRlbnQoYC8ke2N0eC5fZm9udC5pZH0gJHtudW1iZXIoY3R4Ll9mb250U2l6ZSl9IFRmYCk7XG4gICAgLy8gQWRkcyBhIHNlZ21lbnQgb2YgdGV4dCB0byB0aGUgVEogY29tbWFuZCBidWZmZXJcbiAgICBjb25zdCBhZGRTZWdtZW50ID0gKGN1cikgPT4ge1xuICAgICAgICBpZiAobGFzdCA8IGN1cikge1xuICAgICAgICAgICAgY29uc3QgaGV4ID0gZW5jb2RlZC5zbGljZShsYXN0LCBjdXIpLmpvaW4oJycpO1xuICAgICAgICAgICAgY29uc3QgYWR2YW5jZSA9IHBvc2l0aW9uc1tjdXIgLSAxXS54QWR2YW5jZSAtIHBvc2l0aW9uc1tjdXIgLSAxXS5hZHZhbmNlV2lkdGg7XG4gICAgICAgICAgICBjb21tYW5kcy5wdXNoKGA8JHtoZXh9PiAke251bWJlcigtYWR2YW5jZSl9YCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIChsYXN0ID0gY3VyKTtcbiAgICB9O1xuICAgIC8vIEZsdXNoZXMgdGhlIGN1cnJlbnQgVEogY29tbWFuZHMgdG8gdGhlIG91dHB1dCBzdHJlYW1cbiAgICBjb25zdCBmbHVzaCA9IChzKSA9PiB7XG4gICAgICAgIGFkZFNlZ21lbnQocyk7XG4gICAgICAgIGlmIChjb21tYW5kcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBjdHguYWRkQ29udGVudChgWyR7Y29tbWFuZHMuam9pbignICcpfV0gVEpgKTtcbiAgICAgICAgICAgIHJldHVybiAoY29tbWFuZHMubGVuZ3RoID0gMCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGZvciAoaSA9IDA7IGkgPCBwb3NpdGlvbnMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgLy8gSWYgd2UgaGF2ZSBhbiB4IG9yIHkgb2Zmc2V0LCB3ZSBoYXZlIHRvIGJyZWFrIG91dCBvZiB0aGUgY3VycmVudCBUSiBjb21tYW5kXG4gICAgICAgIC8vIHNvIHdlIGNhbiBtb3ZlIHRoZSB0ZXh0IHBvc2l0aW9uLlxuICAgICAgICBjb25zdCBwb3MgPSBwb3NpdGlvbnNbaV07XG4gICAgICAgIGlmIChwb3MueE9mZnNldCB8fCBwb3MueU9mZnNldCkge1xuICAgICAgICAgICAgLy8gRmx1c2ggdGhlIGN1cnJlbnQgYnVmZmVyXG4gICAgICAgICAgICBmbHVzaChpKTtcbiAgICAgICAgICAgIC8vIE1vdmUgdGhlIHRleHQgcG9zaXRpb24gYW5kIGZsdXNoIGp1c3QgdGhlIGN1cnJlbnQgY2hhcmFjdGVyXG4gICAgICAgICAgICBjdHguYWRkQ29udGVudChgMSAwIDAgMSAke251bWJlcih4ICsgcG9zLnhPZmZzZXQgKiBzY2FsZSl9ICR7bnVtYmVyKHkgKyBwb3MueU9mZnNldCAqIHNjYWxlKX0gVG1gKTtcbiAgICAgICAgICAgIGZsdXNoKGkgKyAxKTtcbiAgICAgICAgICAgIGhhZE9mZnNldCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBJZiB0aGUgbGFzdCBjaGFyYWN0ZXIgaGFkIGFuIG9mZnNldCwgcmVzZXQgdGhlIHRleHQgcG9zaXRpb25cbiAgICAgICAgICAgIGlmIChoYWRPZmZzZXQpIHtcbiAgICAgICAgICAgICAgICBjdHguYWRkQ29udGVudChgMSAwIDAgMSAke251bWJlcih4KX0gJHtudW1iZXIoeSl9IFRtYCk7XG4gICAgICAgICAgICAgICAgaGFkT2Zmc2V0ID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBHcm91cCBzZWdtZW50cyB0aGF0IGRvbid0IGhhdmUgYW55IGFkdmFuY2UgYWRqdXN0bWVudHNcbiAgICAgICAgICAgIGlmIChwb3MueEFkdmFuY2UgLSBwb3MuYWR2YW5jZVdpZHRoICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgYWRkU2VnbWVudChpICsgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgeCArPSBwb3MueEFkdmFuY2UgKiBzY2FsZTtcbiAgICB9XG4gICAgLy8gRmx1c2ggYW55IHJlbWFpbmluZyBjb21tYW5kc1xuICAgIGZsdXNoKGkpO1xuICAgIC8vIGVuZCB0aGUgdGV4dCBvYmplY3RcbiAgICBjdHguYWRkQ29udGVudCgnRVQnKTtcbiAgICAvLyByZXN0b3JlIGZsaXBwZWQgY29vcmRpbmF0ZSBzeXN0ZW1cbiAgICByZXR1cm4gY3R4LnJlc3RvcmUoKTtcbn07XG5jb25zdCByZW5kZXJHbHlwaHMgPSAoY3R4LCBnbHlwaHMsIHBvc2l0aW9ucywgeCwgeSkgPT4ge1xuICAgIGNvbnN0IHNjYWxlID0gMTAwMCAvIGN0eC5fZm9udFNpemU7XG4gICAgY29uc3QgdW5pdHNQZXJFbSA9IGN0eC5fZm9udC5mb250LnVuaXRzUGVyRW0gfHwgMTAwMDtcbiAgICBjb25zdCBhZHZhbmNlV2lkdGhTY2FsZSA9IDEwMDAgLyB1bml0c1BlckVtO1xuICAgIC8vIEdseXBoIGVuY29kaW5nIGFuZCBwb3NpdGlvbmluZ1xuICAgIGNvbnN0IGVuY29kZWRHbHlwaHMgPSBjdHguX2ZvbnQuZW5jb2RlR2x5cGhzKGdseXBocyk7XG4gICAgY29uc3QgZW5jb2RlZFBvc2l0aW9ucyA9IHBvc2l0aW9ucy5tYXAoKHBvcywgaSkgPT4gKHtcbiAgICAgICAgeEFkdmFuY2U6IHBvcy54QWR2YW5jZSAqIHNjYWxlLFxuICAgICAgICB5QWR2YW5jZTogcG9zLnlBZHZhbmNlICogc2NhbGUsXG4gICAgICAgIHhPZmZzZXQ6IHBvcy54T2Zmc2V0LFxuICAgICAgICB5T2Zmc2V0OiBwb3MueU9mZnNldCxcbiAgICAgICAgYWR2YW5jZVdpZHRoOiBnbHlwaHNbaV0uYWR2YW5jZVdpZHRoICogYWR2YW5jZVdpZHRoU2NhbGUsXG4gICAgfSkpO1xuICAgIHJldHVybiBfcmVuZGVyR2x5cGhzKGN0eCwgZW5jb2RlZEdseXBocywgZW5jb2RlZFBvc2l0aW9ucywgeCwgeSk7XG59O1xuXG5jb25zdCByZW5kZXJSdW4kMSA9IChjdHgsIHJ1bikgPT4ge1xuICAgIGlmICghcnVuLmdseXBocylcbiAgICAgICAgcmV0dXJuO1xuICAgIGlmICghcnVuLnBvc2l0aW9ucylcbiAgICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHJ1bkFkdmFuY2VXaWR0aCA9IHJ1bi54QWR2YW5jZTtcbiAgICBjb25zdCBmb250ID0gcnVuLmF0dHJpYnV0ZXMuZm9udD8uWzBdO1xuICAgIGNvbnN0IHsgZm9udFNpemUsIGNvbG9yLCBvcGFjaXR5IH0gPSBydW4uYXR0cmlidXRlcztcbiAgICBpZiAoY29sb3IpXG4gICAgICAgIGN0eC5maWxsQ29sb3IoY29sb3IpO1xuICAgIGN0eC5maWxsT3BhY2l0eShvcGFjaXR5KTtcbiAgICBpZiAoZm9udCkge1xuICAgICAgICBjdHguZm9udChmb250LnR5cGUgPT09ICdTVEFOREFSRCcgPyBmb250LmZ1bGxOYW1lIDogZm9udCwgZm9udFNpemUpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICByZW5kZXJHbHlwaHMoY3R4LCBydW4uZ2x5cGhzLCBydW4ucG9zaXRpb25zLCAwLCAwKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKGVycm9yKTtcbiAgICB9XG4gICAgY3R4LnRyYW5zbGF0ZShydW5BZHZhbmNlV2lkdGgsIDApO1xufTtcbmNvbnN0IHJlbmRlclNwYW4gPSAoY3R4LCBsaW5lLCB0ZXh0QW5jaG9yLCBkb21pbmFudEJhc2VsaW5lKSA9PiB7XG4gICAgY3R4LnNhdmUoKTtcbiAgICBjb25zdCB4ID0gbGluZS5ib3g/LnggfHwgMDtcbiAgICBjb25zdCB5ID0gbGluZS5ib3g/LnkgfHwgMDtcbiAgICBjb25zdCBmb250ID0gbGluZS5ydW5zWzBdPy5hdHRyaWJ1dGVzLmZvbnQ/LlswXTtcbiAgICBjb25zdCBzY2FsZSA9IGxpbmUucnVuc1swXT8uYXR0cmlidXRlcz8uc2NhbGUgfHwgMTtcbiAgICBjb25zdCB3aWR0aCA9IGxpbmUueEFkdmFuY2U7XG4gICAgaWYgKCFmb250KVxuICAgICAgICByZXR1cm47XG4gICAgY29uc3QgYXNjZW50ID0gZm9udC5hc2NlbnQgKiBzY2FsZTtcbiAgICBjb25zdCB4SGVpZ2h0ID0gZm9udC54SGVpZ2h0ICogc2NhbGU7XG4gICAgY29uc3QgZGVzY2VudCA9IGZvbnQuZGVzY2VudCAqIHNjYWxlO1xuICAgIGNvbnN0IGNhcEhlaWdodCA9IGZvbnQuY2FwSGVpZ2h0ICogc2NhbGU7XG4gICAgbGV0IHhUcmFuc2xhdGUgPSB4O1xuICAgIGxldCB5VHJhbnNsYXRlID0geTtcbiAgICBzd2l0Y2ggKHRleHRBbmNob3IpIHtcbiAgICAgICAgY2FzZSAnbWlkZGxlJzpcbiAgICAgICAgICAgIHhUcmFuc2xhdGUgPSB4IC0gd2lkdGggLyAyO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2VuZCc6XG4gICAgICAgICAgICB4VHJhbnNsYXRlID0geCAtIHdpZHRoO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB4VHJhbnNsYXRlID0geDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBzd2l0Y2ggKGRvbWluYW50QmFzZWxpbmUpIHtcbiAgICAgICAgY2FzZSAnbWlkZGxlJzpcbiAgICAgICAgY2FzZSAnY2VudHJhbCc6XG4gICAgICAgICAgICB5VHJhbnNsYXRlID0geSArIGNhcEhlaWdodCAvIDI7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnaGFuZ2luZyc6XG4gICAgICAgICAgICB5VHJhbnNsYXRlID0geSArIGNhcEhlaWdodDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdtYXRoZW1hdGljYWwnOlxuICAgICAgICAgICAgeVRyYW5zbGF0ZSA9IHkgKyB4SGVpZ2h0O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3RleHQtYWZ0ZXItZWRnZSc6XG4gICAgICAgICAgICB5VHJhbnNsYXRlID0geSArIGRlc2NlbnQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAndGV4dC1iZWZvcmUtZWRnZSc6XG4gICAgICAgICAgICB5VHJhbnNsYXRlID0geSArIGFzY2VudDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgeVRyYW5zbGF0ZSA9IHk7XG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG4gICAgY3R4LnRyYW5zbGF0ZSh4VHJhbnNsYXRlLCB5VHJhbnNsYXRlKTtcbiAgICBsaW5lLnJ1bnMuZm9yRWFjaCgocnVuKSA9PiByZW5kZXJSdW4kMShjdHgsIHJ1bikpO1xuICAgIGN0eC5yZXN0b3JlKCk7XG59O1xuY29uc3QgcmVuZGVyU3ZnVGV4dCA9IChjdHgsIG5vZGUpID0+IHtcbiAgICBjb25zdCBjaGlsZHJlbiA9IG5vZGUuY2hpbGRyZW47XG4gICAgY2hpbGRyZW4uZm9yRWFjaCgoc3BhbikgPT4gcmVuZGVyU3BhbihjdHgsIHNwYW4ubGluZXNbMF0sIHNwYW4ucHJvcHMudGV4dEFuY2hvciwgc3Bhbi5wcm9wcy5kb21pbmFudEJhc2VsaW5lKSk7XG59O1xuXG5jb25zdCBwYWlycyA9ICh2YWx1ZXMpID0+IHtcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlcy5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICByZXN1bHQucHVzaChbdmFsdWVzW2ldLCB2YWx1ZXNbaSArIDFdXSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59O1xuLyoqXG4gKiBQYXJzZSBzdmctbGlrZSBwb2ludHMgaW50byBudW1iZXIgYXJyYXlzXG4gKlxuICogQHBhcmFtIHBvaW50cyBzdHJpbmcgZXguIFwiMjAsMzAgNTAsNjBcIlxuICogQHJldHVybnMgcG9pbnRzIGFycmF5IGV4LiBbWzIwLCAzMF0sIFs1MCwgNjBdXVxuICovXG5jb25zdCBwYXJzZVBvaW50cyA9IChwb2ludHMpID0+IHtcbiAgICBsZXQgdmFsdWVzID0gKHBvaW50cyB8fCAnJylcbiAgICAgICAgLnRyaW0oKVxuICAgICAgICAucmVwbGFjZSgvLC9nLCAnICcpXG4gICAgICAgIC5yZXBsYWNlKC8oXFxkKS0oXFxkKS9nLCAnJDEgLSQyJylcbiAgICAgICAgLnNwbGl0KC9cXHMrLyk7XG4gICAgaWYgKHZhbHVlcy5sZW5ndGggJSAyICE9PSAwKSB7XG4gICAgICAgIHZhbHVlcyA9IHZhbHVlcy5zbGljZSgwLCAtMSk7XG4gICAgfVxuICAgIGNvbnN0IG1hcHBlZFZhbHVlcyA9IHZhbHVlcy5tYXAocGFyc2VGbG9hdCk7XG4gICAgcmV0dXJuIHBhaXJzKG1hcHBlZFZhbHVlcyk7XG59O1xuXG5jb25zdCBkcmF3UG9seWxpbmUgPSAoY3R4LCBwb2ludHMpID0+IHtcbiAgICBpZiAocG9pbnRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgY3R4Lm1vdmVUbyhwb2ludHNbMF1bMF0sIHBvaW50c1swXVsxXSk7XG4gICAgICAgIHBvaW50cy5zbGljZSgxKS5mb3JFYWNoKChwKSA9PiBjdHgubGluZVRvKHBbMF0sIHBbMV0pKTtcbiAgICB9XG59O1xuY29uc3QgcmVuZGVyUG9seWxpbmUgPSAoY3R4LCBub2RlKSA9PiB7XG4gICAgY29uc3QgcG9pbnRzID0gcGFyc2VQb2ludHMobm9kZS5wcm9wcy5wb2ludHMgfHwgJycpO1xuICAgIGRyYXdQb2x5bGluZShjdHgsIHBvaW50cyk7XG59O1xuXG5jb25zdCByZW5kZXJQb2x5Z29uID0gKGN0eCwgbm9kZSkgPT4ge1xuICAgIGNvbnN0IHBvaW50cyA9IHBhcnNlUG9pbnRzKG5vZGUucHJvcHMucG9pbnRzIHx8ICcnKTtcbiAgICBkcmF3UG9seWxpbmUoY3R4LCBwb2ludHMpO1xuICAgIGN0eC5jbG9zZVBhdGgoKTtcbn07XG5cbmNvbnN0IHJlbmRlckltYWdlJDEgPSAoY3R4LCBub2RlKSA9PiB7XG4gICAgaWYgKCFub2RlLmJveClcbiAgICAgICAgcmV0dXJuO1xuICAgIGlmICghbm9kZS5pbWFnZT8uZGF0YSlcbiAgICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHsgeCA9IDAsIHkgPSAwIH0gPSBub2RlLnByb3BzO1xuICAgIGNvbnN0IHsgd2lkdGgsIGhlaWdodCwgb3BhY2l0eSB9ID0gbm9kZS5zdHlsZTtcbiAgICBjb25zdCBwYWRkaW5nVG9wID0gbm9kZS5ib3gucGFkZGluZ0xlZnQgfHwgMDtcbiAgICBjb25zdCBwYWRkaW5nTGVmdCA9IG5vZGUuYm94LnBhZGRpbmdMZWZ0IHx8IDA7XG4gICAgaWYgKHdpZHRoID09PSAwIHx8IGhlaWdodCA9PT0gMCkge1xuICAgICAgICBjb25zb2xlLndhcm4oYEltYWdlIHdpdGggc3JjICcke25vZGUucHJvcHMuaHJlZn0nIHNraXBwZWQgZHVlIHRvIGludmFsaWQgZGltZW5zaW9uc2ApO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygd2lkdGggPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBoZWlnaHQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihgSW1hZ2Ugd2l0aCBzcmMgJyR7bm9kZS5wcm9wcy5ocmVmfScgc2tpcHBlZCBkdWUgdG8gcGVyY2VudGFnZSB3aWR0aCBvciBoZWlnaHRgKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjdHguc2F2ZSgpO1xuICAgIGN0eFxuICAgICAgICAuZmlsbE9wYWNpdHkob3BhY2l0eSB8fCAxKVxuICAgICAgICAuaW1hZ2Uobm9kZS5pbWFnZS5kYXRhLCB4ICsgcGFkZGluZ0xlZnQsIHkgKyBwYWRkaW5nVG9wLCB7XG4gICAgICAgIHdpZHRoLFxuICAgICAgICBoZWlnaHQsXG4gICAgfSk7XG4gICAgY3R4LnJlc3RvcmUoKTtcbn07XG5cbi8vIFRoaXMgY29uc3RhbnQgaXMgdXNlZCB0byBhcHByb3hpbWF0ZSBhIHN5bW1ldHJpY2FsIGFyYyB1c2luZyBhIGN1YmljXG4vLyBCZXppZXIgY3VydmUuXG5jb25zdCBLQVBQQSQxID0gNC4wICogKChNYXRoLnNxcnQoMikgLSAxLjApIC8gMy4wKTtcbmNvbnN0IGNsaXBOb2RlID0gKGN0eCwgbm9kZSkgPT4ge1xuICAgIGlmICghbm9kZS5ib3gpXG4gICAgICAgIHJldHVybjtcbiAgICBpZiAoIW5vZGUuc3R5bGUpXG4gICAgICAgIHJldHVybjtcbiAgICBjb25zdCB7IHRvcCwgbGVmdCwgd2lkdGgsIGhlaWdodCB9ID0gbm9kZS5ib3g7XG4gICAgY29uc3QgeyBib3JkZXJUb3BMZWZ0UmFkaXVzID0gMCwgYm9yZGVyVG9wUmlnaHRSYWRpdXMgPSAwLCBib3JkZXJCb3R0b21SaWdodFJhZGl1cyA9IDAsIGJvcmRlckJvdHRvbUxlZnRSYWRpdXMgPSAwLCB9ID0gbm9kZS5zdHlsZTtcbiAgICAvLyBCb3JkZXIgdG9wXG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvciB0aGlzIGlzIGFsd2F5cyBhIG51bWJlciBkdWUgdG8gcmVzb2x2ZSBib3JkZXIgcmFkaXVzIHN0ZXBcbiAgICBjb25zdCBydHIgPSBNYXRoLm1pbihib3JkZXJUb3BSaWdodFJhZGl1cywgMC41ICogd2lkdGgsIDAuNSAqIGhlaWdodCk7XG4gICAgY29uc3QgY3RyID0gcnRyICogKDEuMCAtIEtBUFBBJDEpO1xuICAgIGN0eC5tb3ZlVG8obGVmdCArIHJ0ciwgdG9wKTtcbiAgICBjdHgubGluZVRvKGxlZnQgKyB3aWR0aCAtIHJ0ciwgdG9wKTtcbiAgICBjdHguYmV6aWVyQ3VydmVUbyhsZWZ0ICsgd2lkdGggLSBjdHIsIHRvcCwgbGVmdCArIHdpZHRoLCB0b3AgKyBjdHIsIGxlZnQgKyB3aWR0aCwgdG9wICsgcnRyKTtcbiAgICAvLyBCb3JkZXIgcmlnaHRcbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yIHRoaXMgaXMgYWx3YXlzIGEgbnVtYmVyIGR1ZSB0byByZXNvbHZlIGJvcmRlciByYWRpdXMgc3RlcFxuICAgIGNvbnN0IHJiciA9IE1hdGgubWluKGJvcmRlckJvdHRvbVJpZ2h0UmFkaXVzLCAwLjUgKiB3aWR0aCwgMC41ICogaGVpZ2h0KTtcbiAgICBjb25zdCBjYnIgPSByYnIgKiAoMS4wIC0gS0FQUEEkMSk7XG4gICAgY3R4LmxpbmVUbyhsZWZ0ICsgd2lkdGgsIHRvcCArIGhlaWdodCAtIHJicik7XG4gICAgY3R4LmJlemllckN1cnZlVG8obGVmdCArIHdpZHRoLCB0b3AgKyBoZWlnaHQgLSBjYnIsIGxlZnQgKyB3aWR0aCAtIGNiciwgdG9wICsgaGVpZ2h0LCBsZWZ0ICsgd2lkdGggLSByYnIsIHRvcCArIGhlaWdodCk7XG4gICAgLy8gQm9yZGVyIGJvdHRvbVxuICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgdGhpcyBpcyBhbHdheXMgYSBudW1iZXIgZHVlIHRvIHJlc29sdmUgYm9yZGVyIHJhZGl1cyBzdGVwXG4gICAgY29uc3QgcmJsID0gTWF0aC5taW4oYm9yZGVyQm90dG9tTGVmdFJhZGl1cywgMC41ICogd2lkdGgsIDAuNSAqIGhlaWdodCk7XG4gICAgY29uc3QgY2JsID0gcmJsICogKDEuMCAtIEtBUFBBJDEpO1xuICAgIGN0eC5saW5lVG8obGVmdCArIHJibCwgdG9wICsgaGVpZ2h0KTtcbiAgICBjdHguYmV6aWVyQ3VydmVUbyhsZWZ0ICsgY2JsLCB0b3AgKyBoZWlnaHQsIGxlZnQsIHRvcCArIGhlaWdodCAtIGNibCwgbGVmdCwgdG9wICsgaGVpZ2h0IC0gcmJsKTtcbiAgICAvLyBCb3JkZXIgbGVmdFxuICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgdGhpcyBpcyBhbHdheXMgYSBudW1iZXIgZHVlIHRvIHJlc29sdmUgYm9yZGVyIHJhZGl1cyBzdGVwXG4gICAgY29uc3QgcnRsID0gTWF0aC5taW4oYm9yZGVyVG9wTGVmdFJhZGl1cywgMC41ICogd2lkdGgsIDAuNSAqIGhlaWdodCk7XG4gICAgY29uc3QgY3RsID0gcnRsICogKDEuMCAtIEtBUFBBJDEpO1xuICAgIGN0eC5saW5lVG8obGVmdCwgdG9wICsgcnRsKTtcbiAgICBjdHguYmV6aWVyQ3VydmVUbyhsZWZ0LCB0b3AgKyBjdGwsIGxlZnQgKyBjdGwsIHRvcCwgbGVmdCArIHJ0bCwgdG9wKTtcbiAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgY3R4LmNsaXAoKTtcbn07XG5cbmNvbnN0IGFwcGx5U2luZ2xlVHJhbnNmb3JtYXRpb24gPSAoY3R4LCB0cmFuc2Zvcm0sIG9yaWdpbikgPT4ge1xuICAgIGNvbnN0IHsgb3BlcmF0aW9uLCB2YWx1ZSB9ID0gdHJhbnNmb3JtO1xuICAgIHN3aXRjaCAob3BlcmF0aW9uKSB7XG4gICAgICAgIGNhc2UgJ3NjYWxlJzoge1xuICAgICAgICAgICAgY29uc3QgW3NjYWxlWCwgc2NhbGVZXSA9IHZhbHVlO1xuICAgICAgICAgICAgY3R4LnNjYWxlKHNjYWxlWCwgc2NhbGVZLCB7IG9yaWdpbiB9KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ3JvdGF0ZSc6IHtcbiAgICAgICAgICAgIGNvbnN0IFthbmdsZV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIGN0eC5yb3RhdGUoYW5nbGUsIHsgb3JpZ2luIH0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAndHJhbnNsYXRlJzoge1xuICAgICAgICAgICAgY29uc3QgW3gsIHkgPSAwXSA9IHZhbHVlO1xuICAgICAgICAgICAgY3R4LnRyYW5zbGF0ZSh4LCB5LCB7IG9yaWdpbiB9KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ3NrZXcnOiB7XG4gICAgICAgICAgICBjb25zdCBbeEFuZ2xlID0gMCwgeUFuZ2xlID0gMF0gPSB2YWx1ZTtcbiAgICAgICAgICAgIGNvbnN0IHJhZHggPSAoeEFuZ2xlICogTWF0aC5QSSkgLyAxODA7XG4gICAgICAgICAgICBjb25zdCByYWR5ID0gKHlBbmdsZSAqIE1hdGguUEkpIC8gMTgwO1xuICAgICAgICAgICAgY29uc3QgdGFueCA9IE1hdGgudGFuKHJhZHgpO1xuICAgICAgICAgICAgY29uc3QgdGFueSA9IE1hdGgudGFuKHJhZHkpO1xuICAgICAgICAgICAgbGV0IHggPSAwO1xuICAgICAgICAgICAgbGV0IHkgPSAwO1xuICAgICAgICAgICAgaWYgKG9yaWdpbiAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgW3gsIHldID0gQXJyYXkuZnJvbShvcmlnaW4pO1xuICAgICAgICAgICAgICAgIGNvbnN0IHgxID0geCArIHRhbnggKiB5O1xuICAgICAgICAgICAgICAgIGNvbnN0IHkxID0geSArIHRhbnkgKiB4O1xuICAgICAgICAgICAgICAgIHggLT0geDE7XG4gICAgICAgICAgICAgICAgeSAtPSB5MTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN0eC50cmFuc2Zvcm0oMSwgdGFueSwgdGFueCwgMSwgeCwgeSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdtYXRyaXgnOiB7XG4gICAgICAgICAgICBjdHgudHJhbnNmb3JtKC4uLnZhbHVlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYFRyYW5zZm9ybSBvcGVyYXRpb246ICcke29wZXJhdGlvbn0nIGRvZXNuJ3Qgc3VwcG9ydGVkYCk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuY29uc3QgYXBwbHlUcmFuc2Zvcm1hdGlvbnMgPSAoY3R4LCBub2RlKSA9PiB7XG4gICAgaWYgKCFub2RlLm9yaWdpbilcbiAgICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHsgcHJvcHMsIHN0eWxlIH0gPSBub2RlO1xuICAgIGNvbnN0IG9yaWdpbiA9IFtub2RlLm9yaWdpbi5sZWZ0LCBub2RlLm9yaWdpbi50b3BdO1xuICAgIGNvbnN0IHByb3BzVHJhbnNmb3JtID0gJ3RyYW5zZm9ybScgaW4gcHJvcHMgPyBwcm9wcy50cmFuc2Zvcm0gOiB1bmRlZmluZWQ7XG4gICAgY29uc3Qgb3BlcmF0aW9ucyA9IHN0eWxlPy50cmFuc2Zvcm0gfHwgcHJvcHNUcmFuc2Zvcm0gfHwgW107XG4gICAgb3BlcmF0aW9ucy5mb3JFYWNoKChvcGVyYXRpb24pID0+IHtcbiAgICAgICAgYXBwbHlTaW5nbGVUcmFuc2Zvcm1hdGlvbihjdHgsIG9wZXJhdGlvbiwgb3JpZ2luKTtcbiAgICB9KTtcbn07XG5cbi8vIEZyb20gaHR0cHM6Ly9naXRodWIuY29tL2R5L3N2Zy1wYXRoLWJvdW5kcy9ibG9iL21hc3Rlci9pbmRleC5qc1xuY29uc3QgZ2V0UGF0aEJvdW5kaW5nQm94ID0gKG5vZGUpID0+IHtcbiAgICBjb25zdCBwYXRoID0gbm9ybWFsaXplUGF0aChhYnNQYXRoKHBhcnNlUGF0aChub2RlLnByb3BzPy5kIHx8ICcnKSkpO1xuICAgIGlmICghcGF0aC5sZW5ndGgpXG4gICAgICAgIHJldHVybiBbMCwgMCwgMCwgMF07XG4gICAgY29uc3QgYm91bmRzID0gW0luZmluaXR5LCBJbmZpbml0eSwgLUluZmluaXR5LCAtSW5maW5pdHldO1xuICAgIGZvciAobGV0IGkgPSAwLCBsID0gcGF0aC5sZW5ndGg7IGkgPCBsOyBpICs9IDEpIHtcbiAgICAgICAgY29uc3QgcG9pbnRzID0gcGF0aFtpXS5zbGljZSgxKTtcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBwb2ludHMubGVuZ3RoOyBqICs9IDIpIHtcbiAgICAgICAgICAgIGlmIChwb2ludHNbaiArIDBdIDwgYm91bmRzWzBdKVxuICAgICAgICAgICAgICAgIGJvdW5kc1swXSA9IHBvaW50c1tqICsgMF07XG4gICAgICAgICAgICBpZiAocG9pbnRzW2ogKyAxXSA8IGJvdW5kc1sxXSlcbiAgICAgICAgICAgICAgICBib3VuZHNbMV0gPSBwb2ludHNbaiArIDFdO1xuICAgICAgICAgICAgaWYgKHBvaW50c1tqICsgMF0gPiBib3VuZHNbMl0pXG4gICAgICAgICAgICAgICAgYm91bmRzWzJdID0gcG9pbnRzW2ogKyAwXTtcbiAgICAgICAgICAgIGlmIChwb2ludHNbaiArIDFdID4gYm91bmRzWzNdKVxuICAgICAgICAgICAgICAgIGJvdW5kc1szXSA9IHBvaW50c1tqICsgMV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGJvdW5kcztcbn07XG5jb25zdCBnZXRDaXJjbGVCb3VuZGluZ0JveCA9IChub2RlKSA9PiB7XG4gICAgY29uc3QgciA9IG5vZGUucHJvcHM/LnIgfHwgMDtcbiAgICBjb25zdCBjeCA9IG5vZGUucHJvcHM/LmN4IHx8IDA7XG4gICAgY29uc3QgY3kgPSBub2RlLnByb3BzPy5jeSB8fCAwO1xuICAgIHJldHVybiBbY3ggLSByLCBjeSAtIHIsIGN4ICsgciwgY3kgKyByXTtcbn07XG5jb25zdCBnZXRFbGxpcHNlQm91bmRpbmdCb3ggPSAobm9kZSkgPT4ge1xuICAgIGNvbnN0IGN4ID0gbm9kZS5wcm9wcz8uY3ggfHwgMDtcbiAgICBjb25zdCBjeSA9IG5vZGUucHJvcHM/LmN5IHx8IDA7XG4gICAgY29uc3QgcnggPSBub2RlLnByb3BzPy5yeCB8fCAwO1xuICAgIGNvbnN0IHJ5ID0gbm9kZS5wcm9wcz8ucnkgfHwgMDtcbiAgICByZXR1cm4gW2N4IC0gcngsIGN5IC0gcnksIGN4ICsgcngsIGN5ICsgcnldO1xufTtcbmNvbnN0IGdldExpbmVCb3VuZGluZ0JveCA9IChub2RlKSA9PiB7XG4gICAgY29uc3QgeDEgPSBub2RlLnByb3BzPy54MSB8fCAwO1xuICAgIGNvbnN0IHkxID0gbm9kZS5wcm9wcz8ueTEgfHwgMDtcbiAgICBjb25zdCB4MiA9IG5vZGUucHJvcHM/LngyIHx8IDA7XG4gICAgY29uc3QgeTIgPSBub2RlLnByb3BzPy55MiB8fCAwO1xuICAgIHJldHVybiBbXG4gICAgICAgIE1hdGgubWluKHgxLCB4MiksXG4gICAgICAgIE1hdGgubWluKHkxLCB5MiksXG4gICAgICAgIE1hdGgubWF4KHgxLCB4MiksXG4gICAgICAgIE1hdGgubWF4KHkxLCB5MiksXG4gICAgXTtcbn07XG5jb25zdCBnZXRSZWN0Qm91bmRpbmdCb3ggPSAobm9kZSkgPT4ge1xuICAgIGNvbnN0IHggPSBub2RlLnByb3BzPy54IHx8IDA7XG4gICAgY29uc3QgeSA9IG5vZGUucHJvcHM/LnkgfHwgMDtcbiAgICBjb25zdCB3aWR0aCA9IG5vZGUucHJvcHM/LndpZHRoIHx8IDA7XG4gICAgY29uc3QgaGVpZ2h0ID0gbm9kZS5wcm9wcz8uaGVpZ2h0IHx8IDA7XG4gICAgcmV0dXJuIFt4LCB5LCB4ICsgd2lkdGgsIHkgKyBoZWlnaHRdO1xufTtcbmNvbnN0IG1heCA9ICh2YWx1ZXMpID0+IE1hdGgubWF4KC1JbmZpbml0eSwgLi4udmFsdWVzKTtcbmNvbnN0IG1pbiA9ICh2YWx1ZXMpID0+IE1hdGgubWluKEluZmluaXR5LCAuLi52YWx1ZXMpO1xuY29uc3QgZ2V0UG9seWxpbmVCb3VuZGluZ0JveCA9IChub2RlKSA9PiB7XG4gICAgY29uc3QgcG9pbnRzID0gcGFyc2VQb2ludHMobm9kZS5wcm9wcz8ucG9pbnRzKTtcbiAgICBjb25zdCB4VmFsdWVzID0gcG9pbnRzLm1hcCgocCkgPT4gcFswXSk7XG4gICAgY29uc3QgeVZhbHVlcyA9IHBvaW50cy5tYXAoKHApID0+IHBbMV0pO1xuICAgIHJldHVybiBbbWluKHhWYWx1ZXMpLCBtaW4oeVZhbHVlcyksIG1heCh4VmFsdWVzKSwgbWF4KHlWYWx1ZXMpXTtcbn07XG5jb25zdCBib3VuZGluZ0JveEZucyA9IHtcbiAgICBbUC5SZWN0XTogZ2V0UmVjdEJvdW5kaW5nQm94LFxuICAgIFtQLkxpbmVdOiBnZXRMaW5lQm91bmRpbmdCb3gsXG4gICAgW1AuUGF0aF06IGdldFBhdGhCb3VuZGluZ0JveCxcbiAgICBbUC5DaXJjbGVdOiBnZXRDaXJjbGVCb3VuZGluZ0JveCxcbiAgICBbUC5FbGxpcHNlXTogZ2V0RWxsaXBzZUJvdW5kaW5nQm94LFxuICAgIFtQLlBvbHlnb25dOiBnZXRQb2x5bGluZUJvdW5kaW5nQm94LFxuICAgIFtQLlBvbHlsaW5lXTogZ2V0UG9seWxpbmVCb3VuZGluZ0JveCxcbn07XG5jb25zdCBnZXRCb3VuZGluZ0JveCA9IChub2RlKSA9PiB7XG4gICAgY29uc3QgYm91bmRpbmdCb3hGbiA9IGJvdW5kaW5nQm94Rm5zW25vZGUudHlwZV07XG4gICAgcmV0dXJuIGJvdW5kaW5nQm94Rm4gPyBib3VuZGluZ0JveEZuKG5vZGUpIDogWzAsIDAsIDAsIDBdO1xufTtcblxuY29uc3Qgc2V0U3Ryb2tlV2lkdGggPSAoY3R4LCBub2RlKSA9PiB7XG4gICAgaWYgKCFub2RlLnByb3BzKVxuICAgICAgICByZXR1cm47XG4gICAgaWYgKCEoJ3N0cm9rZVdpZHRoJyBpbiBub2RlLnByb3BzKSlcbiAgICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IGxpbmVXaWR0aCA9IG5vZGUucHJvcHMuc3Ryb2tlV2lkdGg7XG4gICAgaWYgKGxpbmVXaWR0aClcbiAgICAgICAgY3R4LmxpbmVXaWR0aChsaW5lV2lkdGgpO1xufTtcbmNvbnN0IHNldFN0cm9rZUNvbG9yID0gKGN0eCwgbm9kZSkgPT4ge1xuICAgIGlmICghbm9kZS5wcm9wcylcbiAgICAgICAgcmV0dXJuO1xuICAgIGlmICghKCdzdHJva2UnIGluIG5vZGUucHJvcHMpKVxuICAgICAgICByZXR1cm47XG4gICAgY29uc3Qgc3Ryb2tlQ29sb3IgPSBub2RlLnByb3BzLnN0cm9rZTtcbiAgICBpZiAoc3Ryb2tlQ29sb3IpXG4gICAgICAgIGN0eC5zdHJva2VDb2xvcihzdHJva2VDb2xvcik7XG59O1xuY29uc3Qgc2V0T3BhY2l0eSA9IChjdHgsIG5vZGUpID0+IHtcbiAgICBpZiAoIW5vZGUucHJvcHMpXG4gICAgICAgIHJldHVybjtcbiAgICBpZiAoISgnb3BhY2l0eScgaW4gbm9kZS5wcm9wcykpXG4gICAgICAgIHJldHVybjtcbiAgICBjb25zdCBvcGFjaXR5ID0gbm9kZS5wcm9wcy5vcGFjaXR5O1xuICAgIGlmICghaXNOaWwob3BhY2l0eSkpXG4gICAgICAgIGN0eC5vcGFjaXR5KG9wYWNpdHkpO1xufTtcbmNvbnN0IHNldEZpbGxPcGFjaXR5ID0gKGN0eCwgbm9kZSkgPT4ge1xuICAgIGlmICghbm9kZS5wcm9wcylcbiAgICAgICAgcmV0dXJuO1xuICAgIGlmICghKCdmaWxsT3BhY2l0eScgaW4gbm9kZS5wcm9wcykpXG4gICAgICAgIHJldHVybjtcbiAgICBjb25zdCBmaWxsT3BhY2l0eSA9IG5vZGUucHJvcHMuZmlsbE9wYWNpdHkgfHwgbnVsbDtcbiAgICBpZiAoIWlzTmlsKGZpbGxPcGFjaXR5KSlcbiAgICAgICAgY3R4LmZpbGxPcGFjaXR5KGZpbGxPcGFjaXR5KTtcbn07XG5jb25zdCBzZXRTdHJva2VPcGFjaXR5ID0gKGN0eCwgbm9kZSkgPT4ge1xuICAgIGlmICghbm9kZS5wcm9wcylcbiAgICAgICAgcmV0dXJuO1xuICAgIGlmICghKCdzdHJva2VPcGFjaXR5JyBpbiBub2RlLnByb3BzKSlcbiAgICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHN0cm9rZU9wYWNpdHkgPSBub2RlLnByb3BzPy5zdHJva2VPcGFjaXR5O1xuICAgIGlmICghaXNOaWwoc3Ryb2tlT3BhY2l0eSkpXG4gICAgICAgIGN0eC5zdHJva2VPcGFjaXR5KHN0cm9rZU9wYWNpdHkpO1xufTtcbmNvbnN0IHNldExpbmVKb2luID0gKGN0eCwgbm9kZSkgPT4ge1xuICAgIGlmICghbm9kZS5wcm9wcylcbiAgICAgICAgcmV0dXJuO1xuICAgIGlmICghKCdzdHJva2VMaW5lam9pbicgaW4gbm9kZS5wcm9wcykpXG4gICAgICAgIHJldHVybjtcbiAgICBjb25zdCBsaW5lSm9pbiA9IG5vZGUucHJvcHMuc3Ryb2tlTGluZWpvaW47XG4gICAgaWYgKGxpbmVKb2luKVxuICAgICAgICBjdHgubGluZUpvaW4obGluZUpvaW4pO1xufTtcbmNvbnN0IHNldExpbmVDYXAgPSAoY3R4LCBub2RlKSA9PiB7XG4gICAgaWYgKCFub2RlLnByb3BzKVxuICAgICAgICByZXR1cm47XG4gICAgaWYgKCEoJ3N0cm9rZUxpbmVjYXAnIGluIG5vZGUucHJvcHMpKVxuICAgICAgICByZXR1cm47XG4gICAgY29uc3QgbGluZUNhcCA9IG5vZGUucHJvcHM/LnN0cm9rZUxpbmVjYXA7XG4gICAgaWYgKGxpbmVDYXApXG4gICAgICAgIGN0eC5saW5lQ2FwKGxpbmVDYXApO1xufTtcbmNvbnN0IHNldExpbmVEYXNoID0gKGN0eCwgbm9kZSkgPT4ge1xuICAgIGlmICghbm9kZS5wcm9wcylcbiAgICAgICAgcmV0dXJuO1xuICAgIGlmICghKCdzdHJva2VEYXNoYXJyYXknIGluIG5vZGUucHJvcHMpKVxuICAgICAgICByZXR1cm47XG4gICAgY29uc3QgdmFsdWUgPSBub2RlLnByb3BzPy5zdHJva2VEYXNoYXJyYXkgfHwgbnVsbDtcbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yIGNoZWNrIHRoaXMgd29ya3MgYXMgZXhwZWN0ZWRcbiAgICBpZiAodmFsdWUpXG4gICAgICAgIGN0eC5kYXNoKHZhbHVlLnNwbGl0KC9bXFxzLF0rLykubWFwKE51bWJlcikpO1xufTtcbmNvbnN0IGhhc0xpbmVhckdyYWRpZW50RmlsbCA9IChub2RlKSA9PiB7XG4gICAgaWYgKCFub2RlLnByb3BzKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgaWYgKCEoJ2ZpbGwnIGluIG5vZGUucHJvcHMpKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgaWYgKHR5cGVvZiBub2RlLnByb3BzLmZpbGwgPT09ICdzdHJpbmcnKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIG5vZGUucHJvcHMuZmlsbD8udHlwZSA9PT0gUC5MaW5lYXJHcmFkaWVudDtcbn07XG5jb25zdCBoYXNSYWRpYWxHcmFkaWVudEZpbGwgPSAobm9kZSkgPT4ge1xuICAgIGlmICghbm9kZS5wcm9wcylcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGlmICghKCdmaWxsJyBpbiBub2RlLnByb3BzKSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGlmICh0eXBlb2Ygbm9kZS5wcm9wcy5maWxsID09PSAnc3RyaW5nJylcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiBub2RlLnByb3BzLmZpbGw/LnR5cGUgPT09IFAuUmFkaWFsR3JhZGllbnQ7XG59O1xuZnVuY3Rpb24gbXVsdGlwbHlNYXRyaWNlcyhtMSwgbTIpIHtcbiAgICBjb25zdCBhID0gbTFbMF0gKiBtMlswXSArIG0xWzJdICogbTJbMV07XG4gICAgY29uc3QgYiA9IG0xWzFdICogbTJbMF0gKyBtMVszXSAqIG0yWzFdO1xuICAgIGNvbnN0IGMgPSBtMVswXSAqIG0yWzJdICsgbTFbMl0gKiBtMlszXTtcbiAgICBjb25zdCBkID0gbTFbMV0gKiBtMlsyXSArIG0xWzNdICogbTJbM107XG4gICAgY29uc3QgZSA9IG0xWzBdICogbTJbNF0gKyBtMVsyXSAqIG0yWzVdICsgbTFbNF07XG4gICAgY29uc3QgZiA9IG0xWzFdICogbTJbNF0gKyBtMVszXSAqIG0yWzVdICsgbTFbNV07XG4gICAgcmV0dXJuIFthLCBiLCBjLCBkLCBlLCBmXTtcbn1cbmNvbnN0IHRyYW5zZm9ybUdyYWRpZW50ID0gKGdyYWQsIHRyYW5zZm9ybXMsIGJib3gsIHVuaXRzKSA9PiB7XG4gICAgY29uc3QgbWF0cmljZXMgPSB0cmFuc2Zvcm1zLm1hcCgodHJhbnNmb3JtKSA9PiB7XG4gICAgICAgIHN3aXRjaCAodHJhbnNmb3JtLm9wZXJhdGlvbikge1xuICAgICAgICAgICAgY2FzZSAnc2NhbGUnOiB7XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSB0cmFuc2Zvcm0udmFsdWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFt2YWx1ZVswXSwgMCwgMCwgdmFsdWVbMV0sIDAsIDBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAndHJhbnNsYXRlJzoge1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gdHJhbnNmb3JtLnZhbHVlO1xuICAgICAgICAgICAgICAgIGxldCB4ID0gdmFsdWVbMF0gfHwgMDtcbiAgICAgICAgICAgICAgICBsZXQgeSA9IHZhbHVlWzFdIHx8IDA7XG4gICAgICAgICAgICAgICAgaWYgKHVuaXRzID09PSAnb2JqZWN0Qm91bmRpbmdCb3gnKSB7XG4gICAgICAgICAgICAgICAgICAgIHggPSAoYmJveFsyXSAtIGJib3hbMF0pICogeDtcbiAgICAgICAgICAgICAgICAgICAgeSA9IChiYm94WzNdIC0gYmJveFsxXSkgKiB5O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gWzEsIDAsIDAsIDEsIHgsIHldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAncm90YXRlJzoge1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gdHJhbnNmb3JtLnZhbHVlO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvcyA9IE1hdGguY29zKHZhbHVlWzBdKTtcbiAgICAgICAgICAgICAgICBjb25zdCBzaW4gPSBNYXRoLnNpbih2YWx1ZVswXSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtjb3MsIHNpbiwgLXNpbiwgY29zLCAwLCAwXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgJ3NrZXcnOiB7XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSB0cmFuc2Zvcm0udmFsdWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsxLCBNYXRoLnRhbih2YWx1ZVswXSksIE1hdGgudGFuKHZhbHVlWzFdKSwgMSwgMCwgMF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlICdtYXRyaXgnOiB7XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSB0cmFuc2Zvcm0udmFsdWU7XG4gICAgICAgICAgICAgICAgbGV0IHggPSB2YWx1ZVs0XSB8fCAwO1xuICAgICAgICAgICAgICAgIGxldCB5ID0gdmFsdWVbNV0gfHwgMDtcbiAgICAgICAgICAgICAgICBpZiAodW5pdHMgPT09ICdvYmplY3RCb3VuZGluZ0JveCcpIHtcbiAgICAgICAgICAgICAgICAgICAgeCA9IChiYm94WzJdIC0gYmJveFswXSkgKiB4O1xuICAgICAgICAgICAgICAgICAgICB5ID0gKGJib3hbM10gLSBiYm94WzFdKSAqIHk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBbdmFsdWVbMF0sIHZhbHVlWzFdLCB2YWx1ZVsyXSwgdmFsdWVbM10sIHgsIHldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gWzEsIDAsIDAsIDEsIDAsIDBdO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgY29uc3QgbWF0cml4ID0gbWF0cmljZXMucmVkdWNlKG11bHRpcGx5TWF0cmljZXMsIFsxLCAwLCAwLCAxLCAwLCAwXSk7XG4gICAgZ3JhZC5zZXRUcmFuc2Zvcm0oLi4ubWF0cml4KTtcbn07XG4vLyBNYXRoIHNpbXBsaWZpZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vZGV2b25nb3ZldHQvc3Zna2l0L2Jsb2IvbWFzdGVyL3NyYy9lbGVtZW50cy9TVkdHcmFkaWVudC5qcyNMMTA0XG5jb25zdCBzZXRMaW5lYXJHcmFkaWVudEZpbGwgPSAoY3R4LCBub2RlKSA9PiB7XG4gICAgaWYgKCFub2RlLnByb3BzKVxuICAgICAgICByZXR1cm47XG4gICAgaWYgKCEoJ2ZpbGwnIGluIG5vZGUucHJvcHMpKVxuICAgICAgICByZXR1cm47XG4gICAgY29uc3QgYmJveCA9IGdldEJvdW5kaW5nQm94KG5vZGUpO1xuICAgIGNvbnN0IGdyYWRpZW50ID0gbm9kZS5wcm9wcz8uZmlsbDtcbiAgICBpZiAoIWdyYWRpZW50KVxuICAgICAgICByZXR1cm47XG4gICAgY29uc3QgdW5pdHMgPSBncmFkaWVudC5wcm9wcy5ncmFkaWVudFVuaXRzIHx8ICdvYmplY3RCb3VuZGluZ0JveCc7XG4gICAgY29uc3QgdHJhbnNmb3JtcyA9IGdyYWRpZW50LnByb3BzLmdyYWRpZW50VHJhbnNmb3JtIHx8IFtdO1xuICAgIGxldCB4MSA9IGdyYWRpZW50LnByb3BzLngxIHx8IDA7XG4gICAgbGV0IHkxID0gZ3JhZGllbnQucHJvcHMueTEgfHwgMDtcbiAgICBsZXQgeDIgPSBncmFkaWVudC5wcm9wcy54MiB8fCAxO1xuICAgIGxldCB5MiA9IGdyYWRpZW50LnByb3BzLnkyIHx8IDA7XG4gICAgaWYgKHVuaXRzID09PSAnb2JqZWN0Qm91bmRpbmdCb3gnKSB7XG4gICAgICAgIGNvbnN0IG0wID0gYmJveFsyXSAtIGJib3hbMF07XG4gICAgICAgIGNvbnN0IG0zID0gYmJveFszXSAtIGJib3hbMV07XG4gICAgICAgIGNvbnN0IG00ID0gYmJveFswXTtcbiAgICAgICAgY29uc3QgbTUgPSBiYm94WzFdO1xuICAgICAgICB4MSA9IG0wICogeDEgKyBtNDtcbiAgICAgICAgeTEgPSBtMyAqIHkxICsgbTU7XG4gICAgICAgIHgyID0gbTAgKiB4MiArIG00O1xuICAgICAgICB5MiA9IG0zICogeTIgKyBtNTtcbiAgICB9XG4gICAgY29uc3QgZ3JhZCA9IGN0eC5saW5lYXJHcmFkaWVudCh4MSwgeTEsIHgyLCB5Mik7XG4gICAgdHJhbnNmb3JtR3JhZGllbnQoZ3JhZCwgdHJhbnNmb3JtcywgYmJveCwgdW5pdHMpO1xuICAgIGdyYWRpZW50LmNoaWxkcmVuPy5mb3JFYWNoKChzdG9wKSA9PiB7XG4gICAgICAgIGdyYWQuc3RvcChzdG9wLnByb3BzLm9mZnNldCwgc3RvcC5wcm9wcy5zdG9wQ29sb3IsIHN0b3AucHJvcHMuc3RvcE9wYWNpdHkpO1xuICAgIH0pO1xuICAgIGN0eC5maWxsKGdyYWQpO1xufTtcbi8vIE1hdGggc2ltcGxpZmllZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9kZXZvbmdvdmV0dC9zdmdraXQvYmxvYi9tYXN0ZXIvc3JjL2VsZW1lbnRzL1NWR0dyYWRpZW50LmpzI0wxNTVcbmNvbnN0IHNldFJhZGlhbEdyYWRpZW50RmlsbCA9IChjdHgsIG5vZGUpID0+IHtcbiAgICBpZiAoIW5vZGUucHJvcHMpXG4gICAgICAgIHJldHVybjtcbiAgICBpZiAoISgnZmlsbCcgaW4gbm9kZS5wcm9wcykpXG4gICAgICAgIHJldHVybjtcbiAgICBjb25zdCBiYm94ID0gZ2V0Qm91bmRpbmdCb3gobm9kZSk7XG4gICAgY29uc3QgZ3JhZGllbnQgPSBub2RlLnByb3BzPy5maWxsO1xuICAgIGlmICghZ3JhZGllbnQpXG4gICAgICAgIHJldHVybjtcbiAgICBjb25zdCB1bml0cyA9IGdyYWRpZW50LnByb3BzLmdyYWRpZW50VW5pdHMgfHwgJ29iamVjdEJvdW5kaW5nQm94JztcbiAgICBjb25zdCB0cmFuc2Zvcm1zID0gZ3JhZGllbnQucHJvcHMuZ3JhZGllbnRUcmFuc2Zvcm0gfHwgW107XG4gICAgbGV0IHIgPSBncmFkaWVudC5wcm9wcy5yIHx8IDAuNTtcbiAgICBsZXQgY3ggPSBncmFkaWVudC5wcm9wcy5jeCB8fCAwLjU7XG4gICAgbGV0IGN5ID0gZ3JhZGllbnQucHJvcHMuY3kgfHwgMC41O1xuICAgIGxldCBmeCA9IGdyYWRpZW50LnByb3BzLmZ4IHx8IGN4O1xuICAgIGxldCBmeSA9IGdyYWRpZW50LnByb3BzLmZ5IHx8IGN5O1xuICAgIGlmICh1bml0cyA9PT0gJ29iamVjdEJvdW5kaW5nQm94Jykge1xuICAgICAgICBjb25zdCBtMCA9IGJib3hbMl0gLSBiYm94WzBdO1xuICAgICAgICBjb25zdCBtMyA9IGJib3hbM10gLSBiYm94WzFdO1xuICAgICAgICBjb25zdCBtNCA9IGJib3hbMF07XG4gICAgICAgIGNvbnN0IG01ID0gYmJveFsxXTtcbiAgICAgICAgciA9IHIgKiBtMDtcbiAgICAgICAgY3ggPSBtMCAqIGN4ICsgbTQ7XG4gICAgICAgIGN5ID0gbTMgKiBjeSArIG01O1xuICAgICAgICBmeCA9IG0wICogZnggKyBtNDtcbiAgICAgICAgZnkgPSBtMyAqIGZ5ICsgbTU7XG4gICAgfVxuICAgIGNvbnN0IGdyYWQgPSBjdHgucmFkaWFsR3JhZGllbnQoY3gsIGN5LCAwLCBmeCwgZnksIHIpO1xuICAgIHRyYW5zZm9ybUdyYWRpZW50KGdyYWQsIHRyYW5zZm9ybXMsIGJib3gsIHVuaXRzKTtcbiAgICBncmFkaWVudC5jaGlsZHJlbj8uZm9yRWFjaCgoc3RvcCkgPT4ge1xuICAgICAgICBncmFkLnN0b3Aoc3RvcC5wcm9wcy5vZmZzZXQsIHN0b3AucHJvcHMuc3RvcENvbG9yLCBzdG9wLnByb3BzLnN0b3BPcGFjaXR5KTtcbiAgICB9KTtcbiAgICBjdHguZmlsbChncmFkKTtcbn07XG5jb25zdCBzZXRGaWxsQ29sb3IgPSAoY3R4LCBub2RlKSA9PiB7XG4gICAgaWYgKCFub2RlLnByb3BzKVxuICAgICAgICByZXR1cm47XG4gICAgaWYgKCEoJ2ZpbGwnIGluIG5vZGUucHJvcHMpKVxuICAgICAgICByZXR1cm47XG4gICAgY29uc3QgZmlsbENvbG9yID0gbm9kZS5wcm9wcz8uZmlsbDtcbiAgICBpZiAoZmlsbENvbG9yKVxuICAgICAgICBjdHguZmlsbENvbG9yKGZpbGxDb2xvcik7XG59O1xuY29uc3Qgc2V0RmlsbCA9IChjdHgsIG5vZGUpID0+IHtcbiAgICBpZiAoaGFzTGluZWFyR3JhZGllbnRGaWxsKG5vZGUpKVxuICAgICAgICByZXR1cm4gc2V0TGluZWFyR3JhZGllbnRGaWxsKGN0eCwgbm9kZSk7XG4gICAgaWYgKGhhc1JhZGlhbEdyYWRpZW50RmlsbChub2RlKSlcbiAgICAgICAgcmV0dXJuIHNldFJhZGlhbEdyYWRpZW50RmlsbChjdHgsIG5vZGUpO1xuICAgIHJldHVybiBzZXRGaWxsQ29sb3IoY3R4LCBub2RlKTtcbn07XG5jb25zdCBkcmF3ID0gKGN0eCwgbm9kZSkgPT4ge1xuICAgIGNvbnN0IHByb3BzID0gbm9kZS5wcm9wcyB8fCB7fTtcbiAgICBpZiAoJ2ZpbGwnIGluIHByb3BzICYmICdzdHJva2UnIGluIHByb3BzICYmIHByb3BzLmZpbGwgJiYgcHJvcHMuc3Ryb2tlKSB7XG4gICAgICAgIGN0eC5maWxsQW5kU3Ryb2tlKHByb3BzLmZpbGxSdWxlKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoJ2ZpbGwnIGluIHByb3BzICYmIHByb3BzLmZpbGwpIHtcbiAgICAgICAgY3R4LmZpbGwocHJvcHMuZmlsbFJ1bGUpO1xuICAgIH1cbiAgICBlbHNlIGlmICgnc3Ryb2tlJyBpbiBwcm9wcyAmJiBwcm9wcy5zdHJva2UpIHtcbiAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgY3R4Lm9wYWNpdHkoMCk7XG4gICAgICAgIGN0eC5maWxsKG51bGwpO1xuICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgIH1cbn07XG5jb25zdCBub29wID0gKCkgPT4geyB9O1xuY29uc3QgcmVuZGVyRm5zJDEgPSB7XG4gICAgW1AuVHNwYW5dOiBub29wLFxuICAgIFtQLlRleHRJbnN0YW5jZV06IG5vb3AsXG4gICAgW1AuUGF0aF06IHJlbmRlclBhdGgsXG4gICAgW1AuUmVjdF06IHJlbmRlclJlY3QsXG4gICAgW1AuTGluZV06IHJlbmRlckxpbmUkMSxcbiAgICBbUC5HXTogcmVuZGVyR3JvdXAsXG4gICAgW1AuVGV4dF06IHJlbmRlclN2Z1RleHQsXG4gICAgW1AuQ2lyY2xlXTogcmVuZGVyQ2lyY2xlLFxuICAgIFtQLkltYWdlXTogcmVuZGVySW1hZ2UkMSxcbiAgICBbUC5FbGxpcHNlXTogcmVuZGVyRWxsaXBzZSxcbiAgICBbUC5Qb2x5Z29uXTogcmVuZGVyUG9seWdvbixcbiAgICBbUC5Qb2x5bGluZV06IHJlbmRlclBvbHlsaW5lLFxufTtcbmNvbnN0IHJlbmRlck5vZGUkMSA9IChjdHgsIG5vZGUpID0+IHtcbiAgICBjb25zdCByZW5kZXJGbiA9IHJlbmRlckZucyQxW25vZGUudHlwZV07XG4gICAgaWYgKHJlbmRlckZuKSB7XG4gICAgICAgIHJlbmRlckZuKGN0eCwgbm9kZSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25zb2xlLndhcm4oYFNWRyBub2RlIG9mIHR5cGUgJHtub2RlLnR5cGV9IGlzIG5vdCBjdXJyZW50bHkgc3VwcG9ydGVkYCk7XG4gICAgfVxufTtcbmNvbnN0IGRyYXdOb2RlID0gKGN0eCwgbm9kZSkgPT4ge1xuICAgIHNldExpbmVDYXAoY3R4LCBub2RlKTtcbiAgICBzZXRMaW5lRGFzaChjdHgsIG5vZGUpO1xuICAgIHNldExpbmVKb2luKGN0eCwgbm9kZSk7XG4gICAgc2V0U3Ryb2tlV2lkdGgoY3R4LCBub2RlKTtcbiAgICBzZXRTdHJva2VDb2xvcihjdHgsIG5vZGUpO1xuICAgIHNldEZpbGwoY3R4LCBub2RlKTtcbiAgICBzZXRTdHJva2VPcGFjaXR5KGN0eCwgbm9kZSk7XG4gICAgc2V0RmlsbE9wYWNpdHkoY3R4LCBub2RlKTtcbiAgICBzZXRPcGFjaXR5KGN0eCwgbm9kZSk7XG4gICAgYXBwbHlUcmFuc2Zvcm1hdGlvbnMoY3R4LCBub2RlKTtcbiAgICByZW5kZXJOb2RlJDEoY3R4LCBub2RlKTtcbiAgICBkcmF3KGN0eCwgbm9kZSk7XG59O1xuY29uc3QgY2xpcFBhdGggPSAoY3R4LCBub2RlKSA9PiB7XG4gICAgaWYgKCFub2RlLnByb3BzKVxuICAgICAgICByZXR1cm47XG4gICAgaWYgKCEoJ2NsaXBQYXRoJyBpbiBub2RlLnByb3BzKSlcbiAgICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHZhbHVlID0gbm9kZS5wcm9wcy5jbGlwUGF0aDtcbiAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgY29uc3QgY2hpbGRyZW4gPSB2YWx1ZS5jaGlsZHJlbiB8fCBbXTtcbiAgICAgICAgY2hpbGRyZW4uZm9yRWFjaCgoY2hpbGQpID0+IHJlbmRlck5vZGUkMShjdHgsIGNoaWxkKSk7XG4gICAgICAgIGN0eC5jbGlwKCk7XG4gICAgfVxufTtcbmNvbnN0IGRyYXdDaGlsZHJlbiA9IChjdHgsIG5vZGUpID0+IHtcbiAgICBjb25zdCBjaGlsZHJlbiA9IG5vZGUuY2hpbGRyZW4gfHwgW107XG4gICAgY2hpbGRyZW4uZm9yRWFjaCgoY2hpbGQpID0+IHtcbiAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgY2xpcFBhdGgoY3R4LCBjaGlsZCk7XG4gICAgICAgIGRyYXdOb2RlKGN0eCwgY2hpbGQpO1xuICAgICAgICBkcmF3Q2hpbGRyZW4oY3R4LCBjaGlsZCk7XG4gICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgfSk7XG59O1xuY29uc3QgcmVzb2x2ZUFzcGVjdFJhdGlvID0gKGN0eCwgbm9kZSkgPT4ge1xuICAgIGlmICghbm9kZS5ib3gpXG4gICAgICAgIHJldHVybjtcbiAgICBjb25zdCB7IHdpZHRoLCBoZWlnaHQgfSA9IG5vZGUuYm94O1xuICAgIGNvbnN0IHsgdmlld0JveCwgcHJlc2VydmVBc3BlY3RSYXRpbyB9ID0gbm9kZS5wcm9wcztcbiAgICBjb25zdCB7IG1lZXRPclNsaWNlID0gJ21lZXQnLCBhbGlnbiA9ICd4TWlkWU1pZCcgfSA9IHByZXNlcnZlQXNwZWN0UmF0aW8gfHwge307XG4gICAgaWYgKHZpZXdCb3ggPT0gbnVsbCB8fCB3aWR0aCA9PSBudWxsIHx8IGhlaWdodCA9PSBudWxsKVxuICAgICAgICByZXR1cm47XG4gICAgY29uc3QgeCA9IHZpZXdCb3g/Lm1pblggfHwgMDtcbiAgICBjb25zdCB5ID0gdmlld0JveD8ubWluWSB8fCAwO1xuICAgIGNvbnN0IGxvZ2ljYWxXaWR0aCA9IHZpZXdCb3g/Lm1heFggfHwgd2lkdGg7XG4gICAgY29uc3QgbG9naWNhbEhlaWdodCA9IHZpZXdCb3g/Lm1heFkgfHwgaGVpZ2h0O1xuICAgIGNvbnN0IGxvZ2ljYWxSYXRpbyA9IGxvZ2ljYWxXaWR0aCAvIGxvZ2ljYWxIZWlnaHQ7XG4gICAgY29uc3QgcGh5c2ljYWxSYXRpbyA9IHdpZHRoIC8gaGVpZ2h0O1xuICAgIGNvbnN0IHNjYWxlWCA9IHdpZHRoIC8gbG9naWNhbFdpZHRoO1xuICAgIGNvbnN0IHNjYWxlWSA9IGhlaWdodCAvIGxvZ2ljYWxIZWlnaHQ7XG4gICAgaWYgKGFsaWduID09PSAnbm9uZScpIHtcbiAgICAgICAgY3R4LnNjYWxlKHNjYWxlWCwgc2NhbGVZKTtcbiAgICAgICAgY3R4LnRyYW5zbGF0ZSgteCwgLXkpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICgobG9naWNhbFJhdGlvIDwgcGh5c2ljYWxSYXRpbyAmJiBtZWV0T3JTbGljZSA9PT0gJ21lZXQnKSB8fFxuICAgICAgICAobG9naWNhbFJhdGlvID49IHBoeXNpY2FsUmF0aW8gJiYgbWVldE9yU2xpY2UgPT09ICdzbGljZScpKSB7XG4gICAgICAgIGN0eC5zY2FsZShzY2FsZVksIHNjYWxlWSk7XG4gICAgICAgIHN3aXRjaCAoYWxpZ24pIHtcbiAgICAgICAgICAgIGNhc2UgJ3hNaW5ZTWluJzpcbiAgICAgICAgICAgIGNhc2UgJ3hNaW5ZTWlkJzpcbiAgICAgICAgICAgIGNhc2UgJ3hNaW5ZTWF4JzpcbiAgICAgICAgICAgICAgICBjdHgudHJhbnNsYXRlKC14LCAteSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICd4TWlkWU1pbic6XG4gICAgICAgICAgICBjYXNlICd4TWlkWU1pZCc6XG4gICAgICAgICAgICBjYXNlICd4TWlkWU1heCc6XG4gICAgICAgICAgICAgICAgY3R4LnRyYW5zbGF0ZSgteCAtIChsb2dpY2FsV2lkdGggLSAod2lkdGggKiBsb2dpY2FsSGVpZ2h0KSAvIGhlaWdodCkgLyAyLCAteSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGN0eC50cmFuc2xhdGUoLXggLSAobG9naWNhbFdpZHRoIC0gKHdpZHRoICogbG9naWNhbEhlaWdodCkgLyBoZWlnaHQpLCAteSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGN0eC5zY2FsZShzY2FsZVgsIHNjYWxlWCk7XG4gICAgICAgIHN3aXRjaCAoYWxpZ24pIHtcbiAgICAgICAgICAgIGNhc2UgJ3hNaW5ZTWluJzpcbiAgICAgICAgICAgIGNhc2UgJ3hNaWRZTWluJzpcbiAgICAgICAgICAgIGNhc2UgJ3hNYXhZTWluJzpcbiAgICAgICAgICAgICAgICBjdHgudHJhbnNsYXRlKC14LCAteSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICd4TWluWU1pZCc6XG4gICAgICAgICAgICBjYXNlICd4TWlkWU1pZCc6XG4gICAgICAgICAgICBjYXNlICd4TWF4WU1pZCc6XG4gICAgICAgICAgICAgICAgY3R4LnRyYW5zbGF0ZSgteCwgLXkgLSAobG9naWNhbEhlaWdodCAtIChoZWlnaHQgKiBsb2dpY2FsV2lkdGgpIC8gd2lkdGgpIC8gMik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGN0eC50cmFuc2xhdGUoLXgsIC15IC0gKGxvZ2ljYWxIZWlnaHQgLSAoaGVpZ2h0ICogbG9naWNhbFdpZHRoKSAvIHdpZHRoKSk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuY29uc3QgbW92ZVRvT3JpZ2luID0gKGN0eCwgbm9kZSkgPT4ge1xuICAgIGlmICghbm9kZS5ib3gpXG4gICAgICAgIHJldHVybjtcbiAgICBjb25zdCB7IHRvcCwgbGVmdCB9ID0gbm9kZS5ib3g7XG4gICAgY29uc3QgcGFkZGluZ0xlZnQgPSBub2RlLmJveC5wYWRkaW5nTGVmdCB8fCAwO1xuICAgIGNvbnN0IHBhZGRpbmdUb3AgPSBub2RlLmJveC5wYWRkaW5nVG9wIHx8IDA7XG4gICAgY3R4LnRyYW5zbGF0ZShsZWZ0ICsgcGFkZGluZ0xlZnQsIHRvcCArIHBhZGRpbmdUb3ApO1xufTtcbmNvbnN0IHJlbmRlclN2ZyA9IChjdHgsIG5vZGUpID0+IHtcbiAgICBjdHguc2F2ZSgpO1xuICAgIGNsaXBOb2RlKGN0eCwgbm9kZSk7XG4gICAgbW92ZVRvT3JpZ2luKGN0eCwgbm9kZSk7XG4gICAgcmVzb2x2ZUFzcGVjdFJhdGlvKGN0eCwgbm9kZSk7XG4gICAgZHJhd0NoaWxkcmVuKGN0eCwgbm9kZSk7XG4gICAgY3R4LnJlc3RvcmUoKTtcbn07XG5cbmNvbnN0IGJsYWNrID0geyB2YWx1ZTogJyMwMDAnLCBvcGFjaXR5OiAxIH07XG4vLyBUT0RPOiBwYXJzZSB0byBudW1iZXJbXSBpbiBsYXlvdXQgdG8gYXZvaWQgdGhpcyBzdGVwXG5jb25zdCBwYXJzZUNvbG9yID0gKGhleCkgPT4ge1xuICAgIGlmICghaGV4KVxuICAgICAgICByZXR1cm4gYmxhY2s7XG4gICAgY29uc3QgcGFyc2VkID0gY29sb3JTdHJpbmcuZ2V0KGhleCk7XG4gICAgaWYgKCFwYXJzZWQpXG4gICAgICAgIHJldHVybiBibGFjaztcbiAgICBjb25zdCB2YWx1ZSA9IGNvbG9yU3RyaW5nLnRvLmhleChwYXJzZWQudmFsdWUuc2xpY2UoMCwgMykpO1xuICAgIGNvbnN0IG9wYWNpdHkgPSBwYXJzZWQudmFsdWVbM107XG4gICAgcmV0dXJuIHsgdmFsdWUsIG9wYWNpdHkgfTtcbn07XG5cbmNvbnN0IERFU1RfUkVHRVhQID0gL14jLisvO1xuY29uc3QgaXNTcmNJZCQxID0gKHNyYykgPT4gc3JjLm1hdGNoKERFU1RfUkVHRVhQKTtcbmNvbnN0IHJlbmRlckF0dGFjaG1lbnQgPSAoY3R4LCBhdHRhY2htZW50KSA9PiB7XG4gICAgY29uc3QgeyB4T2Zmc2V0ID0gMCwgeU9mZnNldCA9IDAsIHdpZHRoLCBoZWlnaHQsIGltYWdlIH0gPSBhdHRhY2htZW50O1xuICAgIGN0eC50cmFuc2xhdGUoLXdpZHRoICsgeE9mZnNldCwgLWhlaWdodCArIHlPZmZzZXQpO1xuICAgIGN0eC5pbWFnZShpbWFnZSwgMCwgMCwge1xuICAgICAgICBmaXQ6IFt3aWR0aCwgaGVpZ2h0XSxcbiAgICAgICAgYWxpZ246ICdjZW50ZXInLFxuICAgICAgICB2YWxpZ246ICdib3R0b20nLFxuICAgIH0pO1xufTtcbmNvbnN0IHJlbmRlckF0dGFjaG1lbnRzID0gKGN0eCwgcnVuKSA9PiB7XG4gICAgaWYgKCFydW4uZ2x5cGhzKVxuICAgICAgICByZXR1cm47XG4gICAgaWYgKCFydW4ucG9zaXRpb25zKVxuICAgICAgICByZXR1cm47XG4gICAgY29uc3QgZm9udCA9IHJ1bi5hdHRyaWJ1dGVzLmZvbnQ/LlswXTtcbiAgICBpZiAoIWZvbnQpXG4gICAgICAgIHJldHVybjtcbiAgICBjdHguc2F2ZSgpO1xuICAgIGNvbnN0IHNwYWNlID0gZm9udC5nbHlwaEZvckNvZGVQb2ludCgweDIwKTtcbiAgICBjb25zdCBvYmplY3RSZXBsYWNlbWVudCA9IGZvbnQuZ2x5cGhGb3JDb2RlUG9pbnQoMHhmZmZjKTtcbiAgICBsZXQgYXR0YWNobWVudEFkdmFuY2UgPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcnVuLmdseXBocy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBjb25zdCBwb3NpdGlvbiA9IHJ1bi5wb3NpdGlvbnNbaV07XG4gICAgICAgIGNvbnN0IGdseXBoID0gcnVuLmdseXBoc1tpXTtcbiAgICAgICAgYXR0YWNobWVudEFkdmFuY2UgKz0gcG9zaXRpb24ueEFkdmFuY2UgfHwgMDtcbiAgICAgICAgaWYgKGdseXBoLmlkID09PSBvYmplY3RSZXBsYWNlbWVudC5pZCAmJiBydW4uYXR0cmlidXRlcy5hdHRhY2htZW50KSB7XG4gICAgICAgICAgICBjdHgudHJhbnNsYXRlKGF0dGFjaG1lbnRBZHZhbmNlLCBwb3NpdGlvbi55T2Zmc2V0IHx8IDApO1xuICAgICAgICAgICAgcmVuZGVyQXR0YWNobWVudChjdHgsIHJ1bi5hdHRyaWJ1dGVzLmF0dGFjaG1lbnQpO1xuICAgICAgICAgICAgcnVuLmdseXBoc1tpXSA9IHNwYWNlO1xuICAgICAgICAgICAgYXR0YWNobWVudEFkdmFuY2UgPSAwO1xuICAgICAgICB9XG4gICAgfVxuICAgIGN0eC5yZXN0b3JlKCk7XG59O1xuY29uc3QgcmVuZGVyUnVuID0gKGN0eCwgcnVuKSA9PiB7XG4gICAgaWYgKCFydW4uZ2x5cGhzKVxuICAgICAgICByZXR1cm47XG4gICAgaWYgKCFydW4ucG9zaXRpb25zKVxuICAgICAgICByZXR1cm47XG4gICAgY29uc3QgZm9udCA9IHJ1bi5hdHRyaWJ1dGVzLmZvbnQ/LlswXTtcbiAgICBpZiAoIWZvbnQpXG4gICAgICAgIHJldHVybjtcbiAgICBjb25zdCB7IGZvbnRTaXplLCBsaW5rIH0gPSBydW4uYXR0cmlidXRlcztcbiAgICBjb25zdCBjb2xvciA9IHBhcnNlQ29sb3IocnVuLmF0dHJpYnV0ZXMuY29sb3IpO1xuICAgIGNvbnN0IG9wYWNpdHkgPSBpc05pbChydW4uYXR0cmlidXRlcy5vcGFjaXR5KVxuICAgICAgICA/IGNvbG9yLm9wYWNpdHlcbiAgICAgICAgOiBydW4uYXR0cmlidXRlcy5vcGFjaXR5O1xuICAgIGNvbnN0IHsgaGVpZ2h0ID0gMCwgZGVzY2VudCA9IDAsIHhBZHZhbmNlID0gMCB9ID0gcnVuO1xuICAgIGN0eC5maWxsQ29sb3IoY29sb3IudmFsdWUpO1xuICAgIGN0eC5maWxsT3BhY2l0eShvcGFjaXR5KTtcbiAgICBpZiAobGluaykge1xuICAgICAgICBpZiAoaXNTcmNJZCQxKGxpbmspKSB7XG4gICAgICAgICAgICBjdHguZ29UbygwLCAtaGVpZ2h0IC0gZGVzY2VudCwgeEFkdmFuY2UsIGhlaWdodCwgbGluay5zbGljZSgxKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjdHgubGluaygwLCAtaGVpZ2h0IC0gZGVzY2VudCwgeEFkdmFuY2UsIGhlaWdodCwgbGluayk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVuZGVyQXR0YWNobWVudHMoY3R4LCBydW4pO1xuICAgIGN0eC5mb250KGZvbnQudHlwZSA9PT0gJ1NUQU5EQVJEJyA/IGZvbnQuZnVsbE5hbWUgOiBmb250LCBmb250U2l6ZSk7XG4gICAgdHJ5IHtcbiAgICAgICAgcmVuZGVyR2x5cGhzKGN0eCwgcnVuLmdseXBocywgcnVuLnBvc2l0aW9ucywgMCwgMCk7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmxvZyhlcnJvcik7XG4gICAgfVxuICAgIGN0eC50cmFuc2xhdGUoeEFkdmFuY2UsIDApO1xufTtcbmNvbnN0IHJlbmRlckJhY2tncm91bmQkMSA9IChjdHgsIHJlY3QsIGJhY2tncm91bmRDb2xvcikgPT4ge1xuICAgIGNvbnN0IGNvbG9yID0gcGFyc2VDb2xvcihiYWNrZ3JvdW5kQ29sb3IpO1xuICAgIGN0eC5zYXZlKCk7XG4gICAgY3R4LmZpbGxPcGFjaXR5KGNvbG9yLm9wYWNpdHkpO1xuICAgIGN0eC5yZWN0KHJlY3QueCwgcmVjdC55LCByZWN0LndpZHRoLCByZWN0LmhlaWdodCk7XG4gICAgY3R4LmZpbGwoY29sb3IudmFsdWUpO1xuICAgIGN0eC5yZXN0b3JlKCk7XG59O1xuY29uc3QgcmVuZGVyRGVjb3JhdGlvbkxpbmUgPSAoY3R4LCBkZWNvcmF0aW9uTGluZSkgPT4ge1xuICAgIGN0eC5zYXZlKCk7XG4gICAgY3R4LmxpbmVXaWR0aChkZWNvcmF0aW9uTGluZS5yZWN0LmhlaWdodCk7XG4gICAgY3R4LnN0cm9rZU9wYWNpdHkoZGVjb3JhdGlvbkxpbmUub3BhY2l0eSk7XG4gICAgaWYgKC9kYXNoZWQvLnRlc3QoZGVjb3JhdGlvbkxpbmUuc3R5bGUpKSB7XG4gICAgICAgIGN0eC5kYXNoKDMgKiBkZWNvcmF0aW9uTGluZS5yZWN0LmhlaWdodCwge30pO1xuICAgIH1cbiAgICBlbHNlIGlmICgvZG90dGVkLy50ZXN0KGRlY29yYXRpb25MaW5lLnN0eWxlKSkge1xuICAgICAgICBjdHguZGFzaChkZWNvcmF0aW9uTGluZS5yZWN0LmhlaWdodCwge30pO1xuICAgIH1cbiAgICBpZiAoL3dhdnkvLnRlc3QoZGVjb3JhdGlvbkxpbmUuc3R5bGUpKSB7XG4gICAgICAgIGNvbnN0IGRpc3QgPSBNYXRoLm1heCgyLCBkZWNvcmF0aW9uTGluZS5yZWN0LmhlaWdodCk7XG4gICAgICAgIGxldCBzdGVwID0gMS4xICogZGlzdDtcbiAgICAgICAgY29uc3Qgc3RlcENvdW50ID0gTWF0aC5mbG9vcihkZWNvcmF0aW9uTGluZS5yZWN0LndpZHRoIC8gKDIgKiBzdGVwKSk7XG4gICAgICAgIC8vIEFkanVzdCBzdGVwIHRvIGZpbGwgZW50aXJlIHdpZHRoXG4gICAgICAgIGNvbnN0IHJlbWFpbmluZ1dpZHRoID0gZGVjb3JhdGlvbkxpbmUucmVjdC53aWR0aCAtIHN0ZXBDb3VudCAqIDIgKiBzdGVwO1xuICAgICAgICBjb25zdCBhZGp1c3RtZW50ID0gcmVtYWluaW5nV2lkdGggLyBzdGVwQ291bnQgLyAyO1xuICAgICAgICBzdGVwICs9IGFkanVzdG1lbnQ7XG4gICAgICAgIGNvbnN0IGNwMXkgPSBkZWNvcmF0aW9uTGluZS5yZWN0LnkgKyBkaXN0O1xuICAgICAgICBjb25zdCBjcDJ5ID0gZGVjb3JhdGlvbkxpbmUucmVjdC55IC0gZGlzdDtcbiAgICAgICAgbGV0IHsgeCB9ID0gZGVjb3JhdGlvbkxpbmUucmVjdDtcbiAgICAgICAgY3R4Lm1vdmVUbyhkZWNvcmF0aW9uTGluZS5yZWN0LngsIGRlY29yYXRpb25MaW5lLnJlY3QueSk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RlcENvdW50OyBpICs9IDEpIHtcbiAgICAgICAgICAgIGN0eC5iZXppZXJDdXJ2ZVRvKHggKyBzdGVwLCBjcDF5LCB4ICsgc3RlcCwgY3AyeSwgeCArIDIgKiBzdGVwLCBkZWNvcmF0aW9uTGluZS5yZWN0LnkpO1xuICAgICAgICAgICAgeCArPSAyICogc3RlcDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY3R4Lm1vdmVUbyhkZWNvcmF0aW9uTGluZS5yZWN0LngsIGRlY29yYXRpb25MaW5lLnJlY3QueSk7XG4gICAgICAgIGN0eC5saW5lVG8oZGVjb3JhdGlvbkxpbmUucmVjdC54ICsgZGVjb3JhdGlvbkxpbmUucmVjdC53aWR0aCwgZGVjb3JhdGlvbkxpbmUucmVjdC55KTtcbiAgICAgICAgaWYgKC9kb3VibGUvLnRlc3QoZGVjb3JhdGlvbkxpbmUuc3R5bGUpKSB7XG4gICAgICAgICAgICBjdHgubW92ZVRvKGRlY29yYXRpb25MaW5lLnJlY3QueCwgZGVjb3JhdGlvbkxpbmUucmVjdC55ICsgZGVjb3JhdGlvbkxpbmUucmVjdC5oZWlnaHQgKiAyKTtcbiAgICAgICAgICAgIGN0eC5saW5lVG8oZGVjb3JhdGlvbkxpbmUucmVjdC54ICsgZGVjb3JhdGlvbkxpbmUucmVjdC53aWR0aCwgZGVjb3JhdGlvbkxpbmUucmVjdC55ICsgZGVjb3JhdGlvbkxpbmUucmVjdC5oZWlnaHQgKiAyKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjdHguc3Ryb2tlKGRlY29yYXRpb25MaW5lLmNvbG9yKTtcbiAgICBjdHgucmVzdG9yZSgpO1xufTtcbmNvbnN0IHJlbmRlckxpbmUgPSAoY3R4LCBsaW5lKSA9PiB7XG4gICAgaWYgKCFsaW5lLmJveClcbiAgICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IGxpbmVBc2NlbnQgPSBsaW5lLmFzY2VudCB8fCAwO1xuICAgIGN0eC5zYXZlKCk7XG4gICAgY3R4LnRyYW5zbGF0ZShsaW5lLmJveC54LCBsaW5lLmJveC55ICsgbGluZUFzY2VudCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaW5lLnJ1bnMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgY29uc3QgcnVuID0gbGluZS5ydW5zW2ldO1xuICAgICAgICBjb25zdCBpc0xhc3RSdW4gPSBpID09PSBsaW5lLnJ1bnMubGVuZ3RoIC0gMTtcbiAgICAgICAgaWYgKHJ1bi5hdHRyaWJ1dGVzLmJhY2tncm91bmRDb2xvcikge1xuICAgICAgICAgICAgY29uc3QgeEFkdmFuY2UgPSBydW4ueEFkdmFuY2UgPz8gMDtcbiAgICAgICAgICAgIGNvbnN0IG92ZXJmbG93UmlnaHQgPSBpc0xhc3RSdW4gPyBsaW5lLm92ZXJmbG93UmlnaHQgPz8gMCA6IDA7XG4gICAgICAgICAgICBjb25zdCBiYWNrZ3JvdW5kUmVjdCA9IHtcbiAgICAgICAgICAgICAgICB4OiAwLFxuICAgICAgICAgICAgICAgIHk6IC1saW5lQXNjZW50LFxuICAgICAgICAgICAgICAgIGhlaWdodDogbGluZS5ib3guaGVpZ2h0LFxuICAgICAgICAgICAgICAgIHdpZHRoOiB4QWR2YW5jZSAtIG92ZXJmbG93UmlnaHQsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmVuZGVyQmFja2dyb3VuZCQxKGN0eCwgYmFja2dyb3VuZFJlY3QsIHJ1bi5hdHRyaWJ1dGVzLmJhY2tncm91bmRDb2xvcik7XG4gICAgICAgIH1cbiAgICAgICAgcmVuZGVyUnVuKGN0eCwgcnVuKTtcbiAgICB9XG4gICAgY3R4LnJlc3RvcmUoKTtcbiAgICBjdHguc2F2ZSgpO1xuICAgIGN0eC50cmFuc2xhdGUobGluZS5ib3gueCwgbGluZS5ib3gueSk7XG4gICAgaWYgKGxpbmUuZGVjb3JhdGlvbkxpbmVzKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGluZS5kZWNvcmF0aW9uTGluZXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgIGNvbnN0IGRlY29yYXRpb25MaW5lID0gbGluZS5kZWNvcmF0aW9uTGluZXNbaV07XG4gICAgICAgICAgICByZW5kZXJEZWNvcmF0aW9uTGluZShjdHgsIGRlY29yYXRpb25MaW5lKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjdHgucmVzdG9yZSgpO1xufTtcbmNvbnN0IHJlbmRlckJsb2NrID0gKGN0eCwgYmxvY2spID0+IHtcbiAgICBibG9jay5mb3JFYWNoKChsaW5lKSA9PiB7XG4gICAgICAgIHJlbmRlckxpbmUoY3R4LCBsaW5lKTtcbiAgICB9KTtcbn07XG5jb25zdCByZW5kZXJUZXh0ID0gKGN0eCwgbm9kZSkgPT4ge1xuICAgIGlmICghbm9kZS5ib3gpXG4gICAgICAgIHJldHVybjtcbiAgICBpZiAoIW5vZGUubGluZXMpXG4gICAgICAgIHJldHVybjtcbiAgICBjb25zdCB7IHRvcCwgbGVmdCB9ID0gbm9kZS5ib3g7XG4gICAgY29uc3QgYmxvY2tzID0gW25vZGUubGluZXNdO1xuICAgIGNvbnN0IHBhZGRpbmdUb3AgPSBub2RlLmJveD8ucGFkZGluZ1RvcCB8fCAwO1xuICAgIGNvbnN0IHBhZGRpbmdMZWZ0ID0gbm9kZS5ib3g/LnBhZGRpbmdMZWZ0IHx8IDA7XG4gICAgY29uc3QgaW5pdGlhbFkgPSBub2RlLmxpbmVzWzBdID8gbm9kZS5saW5lc1swXS5ib3gueSA6IDA7XG4gICAgY29uc3Qgb2Zmc2V0WCA9IG5vZGUuYWxpZ25PZmZzZXQgfHwgMDtcbiAgICBjdHguc2F2ZSgpO1xuICAgIGN0eC50cmFuc2xhdGUobGVmdCArIHBhZGRpbmdMZWZ0IC0gb2Zmc2V0WCwgdG9wICsgcGFkZGluZ1RvcCAtIGluaXRpYWxZKTtcbiAgICBibG9ja3MuZm9yRWFjaCgoYmxvY2spID0+IHtcbiAgICAgICAgcmVuZGVyQmxvY2soY3R4LCBibG9jayk7XG4gICAgfSk7XG4gICAgY3R4LnJlc3RvcmUoKTtcbn07XG5cbmNvbnN0IHJlbmRlclBhZ2UgPSAoY3R4LCBub2RlKSA9PiB7XG4gICAgaWYgKCFub2RlLmJveClcbiAgICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHsgd2lkdGgsIGhlaWdodCB9ID0gbm9kZS5ib3g7XG4gICAgY29uc3QgZHBpID0gbm9kZS5wcm9wcz8uZHBpIHx8IDcyO1xuICAgIGNvbnN0IHVzZXJVbml0ID0gZHBpIC8gNzI7XG4gICAgY3R4LmFkZFBhZ2UoeyBzaXplOiBbd2lkdGgsIGhlaWdodF0sIG1hcmdpbjogMCwgdXNlclVuaXQgfSk7XG59O1xuXG5jb25zdCByZW5kZXJOb3RlID0gKGN0eCwgbm9kZSkgPT4ge1xuICAgIGlmICghbm9kZS5ib3gpXG4gICAgICAgIHJldHVybjtcbiAgICBjb25zdCB7IHRvcCwgbGVmdCB9ID0gbm9kZS5ib3g7XG4gICAgY29uc3QgdmFsdWUgPSBub2RlPy5jaGlsZHJlbj8uWzBdLnZhbHVlIHx8ICcnO1xuICAgIGNvbnN0IGNvbG9yID0gbm9kZS5zdHlsZT8uYmFja2dyb3VuZENvbG9yO1xuICAgIGN0eC5ub3RlKGxlZnQsIHRvcCwgMCwgMCwgdmFsdWUsIHsgY29sb3IgfSk7XG59O1xuXG5jb25zdCBlbWJlZEltYWdlID0gKGN0eCwgbm9kZSkgPT4ge1xuICAgIGNvbnN0IHNyYyA9IG5vZGUuaW1hZ2UuZGF0YTtcbiAgICBsZXQgaW1hZ2U7XG4gICAgaWYgKHR5cGVvZiBzcmMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGltYWdlID0gY3R4Ll9pbWFnZVJlZ2lzdHJ5W3NyY107XG4gICAgfVxuICAgIGlmICghaW1hZ2UpIHtcbiAgICAgICAgaW1hZ2UgPSBjdHgub3BlbkltYWdlKHNyYyk7XG4gICAgfVxuICAgIGlmICghaW1hZ2Uub2JqKSB7XG4gICAgICAgIGltYWdlLmVtYmVkKGN0eCk7XG4gICAgfVxuICAgIHJldHVybiBpbWFnZTtcbn07XG5cbmNvbnN0IGlzTnVtZXJpYyA9IChuKSA9PiB7XG4gICAgcmV0dXJuICFOdW1iZXIuaXNOYU4ocGFyc2VGbG9hdChuKSkgJiYgTnVtYmVyLmlzRmluaXRlKG4pO1xufTtcbmNvbnN0IGFwcGx5Q29udGFpbk9iamVjdEZpdCA9IChjdywgY2gsIGl3LCBpaCwgcHgsIHB5KSA9PiB7XG4gICAgY29uc3QgY3IgPSBjdyAvIGNoO1xuICAgIGNvbnN0IGlyID0gaXcgLyBpaDtcbiAgICBjb25zdCBweHAgPSBtYXRjaFBlcmNlbnQocHggPz8gbnVsbCk7XG4gICAgY29uc3QgcHlwID0gbWF0Y2hQZXJjZW50KHB5ID8/IG51bGwpO1xuICAgIGNvbnN0IHB4diA9IHB4cCA/IHB4cC5wZXJjZW50IDogMC41O1xuICAgIGNvbnN0IHB5diA9IHB5cCA/IHB5cC5wZXJjZW50IDogMC41O1xuICAgIGlmIChjciA+IGlyKSB7XG4gICAgICAgIGNvbnN0IGhlaWdodCA9IGNoO1xuICAgICAgICBjb25zdCB3aWR0aCA9IGhlaWdodCAqIGlyO1xuICAgICAgICBjb25zdCB5T2Zmc2V0ID0gaXNOdW1lcmljKHB5KSA/IHB5IDogMDtcbiAgICAgICAgY29uc3QgeE9mZnNldCA9IGlzTnVtZXJpYyhweCkgPyBweCA6IChjdyAtIHdpZHRoKSAqIHB4djtcbiAgICAgICAgcmV0dXJuIHsgd2lkdGgsIGhlaWdodCwgeE9mZnNldCwgeU9mZnNldCB9O1xuICAgIH1cbiAgICBjb25zdCB3aWR0aCA9IGN3O1xuICAgIGNvbnN0IGhlaWdodCA9IHdpZHRoIC8gaXI7XG4gICAgY29uc3QgeE9mZnNldCA9IGlzTnVtZXJpYyhweCkgPyBweCA6IDA7XG4gICAgY29uc3QgeU9mZnNldCA9IGlzTnVtZXJpYyhweSkgPyBweSA6IChjaCAtIGhlaWdodCkgKiBweXY7XG4gICAgcmV0dXJuIHsgd2lkdGgsIGhlaWdodCwgeU9mZnNldCwgeE9mZnNldCB9O1xufTtcbmNvbnN0IGFwcGx5Tm9uZU9iamVjdEZpdCA9IChjdywgY2gsIGl3LCBpaCwgcHgsIHB5KSA9PiB7XG4gICAgY29uc3Qgd2lkdGggPSBpdztcbiAgICBjb25zdCBoZWlnaHQgPSBpaDtcbiAgICBjb25zdCBweHAgPSBtYXRjaFBlcmNlbnQocHggPz8gbnVsbCk7XG4gICAgY29uc3QgcHlwID0gbWF0Y2hQZXJjZW50KHB5ID8/IG51bGwpO1xuICAgIGNvbnN0IHB4diA9IHB4cCA/IHB4cC5wZXJjZW50IDogMC41O1xuICAgIGNvbnN0IHB5diA9IHB5cCA/IHB5cC5wZXJjZW50IDogMC41O1xuICAgIGNvbnN0IHhPZmZzZXQgPSBpc051bWVyaWMocHgpID8gcHggOiAoY3cgLSB3aWR0aCkgKiBweHY7XG4gICAgY29uc3QgeU9mZnNldCA9IGlzTnVtZXJpYyhweSkgPyBweSA6IChjaCAtIGhlaWdodCkgKiBweXY7XG4gICAgcmV0dXJuIHsgd2lkdGgsIGhlaWdodCwgeE9mZnNldCwgeU9mZnNldCB9O1xufTtcbmNvbnN0IGFwcGx5Q292ZXJPYmplY3RGaXQgPSAoY3csIGNoLCBpdywgaWgsIHB4LCBweSkgPT4ge1xuICAgIGNvbnN0IGlyID0gaXcgLyBpaDtcbiAgICBjb25zdCBjciA9IGN3IC8gY2g7XG4gICAgY29uc3QgcHhwID0gbWF0Y2hQZXJjZW50KHB4ID8/IG51bGwpO1xuICAgIGNvbnN0IHB5cCA9IG1hdGNoUGVyY2VudChweSA/PyBudWxsKTtcbiAgICBjb25zdCBweHYgPSBweHAgPyBweHAucGVyY2VudCA6IDAuNTtcbiAgICBjb25zdCBweXYgPSBweXAgPyBweXAucGVyY2VudCA6IDAuNTtcbiAgICBpZiAoY3IgPiBpcikge1xuICAgICAgICBjb25zdCB3aWR0aCA9IGN3O1xuICAgICAgICBjb25zdCBoZWlnaHQgPSB3aWR0aCAvIGlyO1xuICAgICAgICBjb25zdCB4T2Zmc2V0ID0gaXNOdW1lcmljKHB4KSA/IHB4IDogMDtcbiAgICAgICAgY29uc3QgeU9mZnNldCA9IGlzTnVtZXJpYyhweSkgPyBweSA6IChjaCAtIGhlaWdodCkgKiBweXY7XG4gICAgICAgIHJldHVybiB7IHdpZHRoLCBoZWlnaHQsIHlPZmZzZXQsIHhPZmZzZXQgfTtcbiAgICB9XG4gICAgY29uc3QgaGVpZ2h0ID0gY2g7XG4gICAgY29uc3Qgd2lkdGggPSBoZWlnaHQgKiBpcjtcbiAgICBjb25zdCB4T2Zmc2V0ID0gaXNOdW1lcmljKHB4KSA/IHB4IDogKGN3IC0gd2lkdGgpICogcHh2O1xuICAgIGNvbnN0IHlPZmZzZXQgPSBpc051bWVyaWMocHkpID8gcHkgOiAwO1xuICAgIHJldHVybiB7IHdpZHRoLCBoZWlnaHQsIHhPZmZzZXQsIHlPZmZzZXQgfTtcbn07XG5jb25zdCBhcHBseVNjYWxlRG93bk9iamVjdEZpdCA9IChjdywgY2gsIGl3LCBpaCwgcHgsIHB5KSA9PiB7XG4gICAgY29uc3QgY29udGFpbkRpbWVuc2lvbiA9IGFwcGx5Q29udGFpbk9iamVjdEZpdChjdywgY2gsIGl3LCBpaCwgcHgsIHB5KTtcbiAgICBjb25zdCBub25lRGltZW5zaW9uID0gYXBwbHlOb25lT2JqZWN0Rml0KGN3LCBjaCwgaXcsIGloLCBweCwgcHkpO1xuICAgIHJldHVybiBjb250YWluRGltZW5zaW9uLndpZHRoIDwgbm9uZURpbWVuc2lvbi53aWR0aFxuICAgICAgICA/IGNvbnRhaW5EaW1lbnNpb25cbiAgICAgICAgOiBub25lRGltZW5zaW9uO1xufTtcbmNvbnN0IGFwcGx5RmlsbE9iamVjdEZpdCA9IChjdywgY2gsIHB4LCBweSkgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICAgIHdpZHRoOiBjdyxcbiAgICAgICAgaGVpZ2h0OiBjaCxcbiAgICAgICAgeE9mZnNldDogbWF0Y2hQZXJjZW50KHB4ID8/IG51bGwpID8gMCA6IHB4IHx8IDAsXG4gICAgICAgIHlPZmZzZXQ6IG1hdGNoUGVyY2VudChweSA/PyBudWxsKSA/IDAgOiBweSB8fCAwLFxuICAgIH07XG59O1xuY29uc3QgcmVzb2x2ZU9iamVjdEZpdCA9ICh0eXBlID0gJ2ZpbGwnLCBjdywgY2gsIGl3LCBpaCwgcHgsIHB5KSA9PiB7XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgJ2NvbnRhaW4nOlxuICAgICAgICAgICAgcmV0dXJuIGFwcGx5Q29udGFpbk9iamVjdEZpdChjdywgY2gsIGl3LCBpaCwgcHgsIHB5KTtcbiAgICAgICAgY2FzZSAnY292ZXInOlxuICAgICAgICAgICAgcmV0dXJuIGFwcGx5Q292ZXJPYmplY3RGaXQoY3csIGNoLCBpdywgaWgsIHB4LCBweSk7XG4gICAgICAgIGNhc2UgJ25vbmUnOlxuICAgICAgICAgICAgcmV0dXJuIGFwcGx5Tm9uZU9iamVjdEZpdChjdywgY2gsIGl3LCBpaCwgcHgsIHB5KTtcbiAgICAgICAgY2FzZSAnc2NhbGUtZG93bic6XG4gICAgICAgICAgICByZXR1cm4gYXBwbHlTY2FsZURvd25PYmplY3RGaXQoY3csIGNoLCBpdywgaWgsIHB4LCBweSk7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gYXBwbHlGaWxsT2JqZWN0Rml0KGN3LCBjaCwgcHgsIHB5KTtcbiAgICB9XG59O1xuXG5jb25zdCBkcmF3SW1hZ2UgPSAoY3R4LCBub2RlLCBvcHRpb25zKSA9PiB7XG4gICAgaWYgKCFub2RlLmJveClcbiAgICAgICAgcmV0dXJuO1xuICAgIGlmICghbm9kZS5pbWFnZSlcbiAgICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHsgbGVmdCwgdG9wIH0gPSBub2RlLmJveDtcbiAgICBjb25zdCBvcGFjaXR5ID0gbm9kZS5zdHlsZT8ub3BhY2l0eTtcbiAgICBjb25zdCBvYmplY3RGaXQgPSBub2RlLnN0eWxlPy5vYmplY3RGaXQ7XG4gICAgY29uc3Qgb2JqZWN0UG9zaXRpb25YID0gbm9kZS5zdHlsZT8ub2JqZWN0UG9zaXRpb25YO1xuICAgIGNvbnN0IG9iamVjdFBvc2l0aW9uWSA9IG5vZGUuc3R5bGU/Lm9iamVjdFBvc2l0aW9uWTtcbiAgICBjb25zdCBwYWRkaW5nVG9wID0gbm9kZS5ib3gucGFkZGluZ1RvcCB8fCAwO1xuICAgIGNvbnN0IHBhZGRpbmdSaWdodCA9IG5vZGUuYm94LnBhZGRpbmdSaWdodCB8fCAwO1xuICAgIGNvbnN0IHBhZGRpbmdCb3R0b20gPSBub2RlLmJveC5wYWRkaW5nQm90dG9tIHx8IDA7XG4gICAgY29uc3QgcGFkZGluZ0xlZnQgPSBub2RlLmJveC5wYWRkaW5nTGVmdCB8fCAwO1xuICAgIGNvbnN0IGltYWdlQ2FjaGUgPSBvcHRpb25zLmltYWdlQ2FjaGUgfHwgbmV3IE1hcCgpO1xuICAgIGNvbnN0IHsgd2lkdGgsIGhlaWdodCwgeE9mZnNldCwgeU9mZnNldCB9ID0gcmVzb2x2ZU9iamVjdEZpdChvYmplY3RGaXQsIG5vZGUuYm94LndpZHRoIC0gcGFkZGluZ0xlZnQgLSBwYWRkaW5nUmlnaHQsIG5vZGUuYm94LmhlaWdodCAtIHBhZGRpbmdUb3AgLSBwYWRkaW5nQm90dG9tLCBub2RlLmltYWdlLndpZHRoLCBub2RlLmltYWdlLmhlaWdodCwgb2JqZWN0UG9zaXRpb25YLCBvYmplY3RQb3NpdGlvblkpO1xuICAgIGlmIChub2RlLmltYWdlLmRhdGEpIHtcbiAgICAgICAgaWYgKHdpZHRoICE9PSAwICYmIGhlaWdodCAhPT0gMCkge1xuICAgICAgICAgICAgY29uc3QgY2FjaGVLZXkgPSBub2RlLmltYWdlLmtleTtcbiAgICAgICAgICAgIGNvbnN0IGltYWdlID0gaW1hZ2VDYWNoZS5nZXQoY2FjaGVLZXkpIHx8IGVtYmVkSW1hZ2UoY3R4LCBub2RlKTtcbiAgICAgICAgICAgIGlmIChjYWNoZUtleSlcbiAgICAgICAgICAgICAgICBpbWFnZUNhY2hlLnNldChjYWNoZUtleSwgaW1hZ2UpO1xuICAgICAgICAgICAgY29uc3QgaW1hZ2VPcGFjaXR5ID0gaXNOaWwob3BhY2l0eSkgPyAxIDogb3BhY2l0eTtcbiAgICAgICAgICAgIGN0eFxuICAgICAgICAgICAgICAgIC5maWxsT3BhY2l0eShpbWFnZU9wYWNpdHkpXG4gICAgICAgICAgICAgICAgLmltYWdlKGltYWdlLCBsZWZ0ICsgcGFkZGluZ0xlZnQgKyB4T2Zmc2V0LCB0b3AgKyBwYWRkaW5nVG9wICsgeU9mZnNldCwge1xuICAgICAgICAgICAgICAgIHdpZHRoLFxuICAgICAgICAgICAgICAgIGhlaWdodCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKGBJbWFnZSB3aXRoIHNyYyAnJHtKU09OLnN0cmluZ2lmeShub2RlLnByb3BzLnNyYyB8fCBub2RlLnByb3BzLnNvdXJjZSl9JyBza2lwcGVkIGR1ZSB0byBpbnZhbGlkIGRpbWVuc2lvbnNgKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5jb25zdCByZW5kZXJJbWFnZSA9IChjdHgsIG5vZGUsIG9wdGlvbnMpID0+IHtcbiAgICBjdHguc2F2ZSgpO1xuICAgIGNsaXBOb2RlKGN0eCwgbm9kZSk7XG4gICAgZHJhd0ltYWdlKGN0eCwgbm9kZSwgb3B0aW9ucyk7XG4gICAgY3R4LnJlc3RvcmUoKTtcbn07XG5cbmNvbnN0IENPTlRFTlRfQ09MT1IgPSAnI2ExYzZlNyc7XG5jb25zdCBQQURESU5HX0NPTE9SID0gJyNjNGRlYjknO1xuY29uc3QgTUFSR0lOX0NPTE9SID0gJyNmOGNjYTEnO1xuLy8gVE9ETzogRHJhdyBkZWJ1ZyBib3hlcyB1c2luZyBjbGlwcGluZyB0byBlbmhhbmNlIHF1YWxpdHlcbmNvbnN0IGRlYnVnQ29udGVudCA9IChjdHgsIG5vZGUpID0+IHtcbiAgICBpZiAoIW5vZGUuYm94KVxuICAgICAgICByZXR1cm47XG4gICAgY29uc3QgeyBsZWZ0LCB0b3AsIHdpZHRoLCBoZWlnaHQsIHBhZGRpbmdMZWZ0ID0gMCwgcGFkZGluZ1RvcCA9IDAsIHBhZGRpbmdSaWdodCA9IDAsIHBhZGRpbmdCb3R0b20gPSAwLCBib3JkZXJMZWZ0V2lkdGggPSAwLCBib3JkZXJUb3BXaWR0aCA9IDAsIGJvcmRlclJpZ2h0V2lkdGggPSAwLCBib3JkZXJCb3R0b21XaWR0aCA9IDAsIH0gPSBub2RlLmJveDtcbiAgICBjdHhcbiAgICAgICAgLmZpbGxDb2xvcihDT05URU5UX0NPTE9SKVxuICAgICAgICAub3BhY2l0eSgwLjUpXG4gICAgICAgIC5yZWN0KGxlZnQgKyBwYWRkaW5nTGVmdCArIGJvcmRlckxlZnRXaWR0aCwgdG9wICsgcGFkZGluZ1RvcCArIGJvcmRlclRvcFdpZHRoLCB3aWR0aCAtIHBhZGRpbmdMZWZ0IC0gcGFkZGluZ1JpZ2h0IC0gYm9yZGVyUmlnaHRXaWR0aCAtIGJvcmRlckxlZnRXaWR0aCwgaGVpZ2h0IC0gcGFkZGluZ1RvcCAtIHBhZGRpbmdCb3R0b20gLSBib3JkZXJUb3BXaWR0aCAtIGJvcmRlckJvdHRvbVdpZHRoKVxuICAgICAgICAuZmlsbCgpO1xufTtcbmNvbnN0IGRlYnVnUGFkZGluZyA9IChjdHgsIG5vZGUpID0+IHtcbiAgICBpZiAoIW5vZGUuYm94KVxuICAgICAgICByZXR1cm47XG4gICAgY29uc3QgeyBsZWZ0LCB0b3AsIHdpZHRoLCBoZWlnaHQsIHBhZGRpbmdMZWZ0ID0gMCwgcGFkZGluZ1RvcCA9IDAsIHBhZGRpbmdSaWdodCA9IDAsIHBhZGRpbmdCb3R0b20gPSAwLCBib3JkZXJMZWZ0V2lkdGggPSAwLCBib3JkZXJUb3BXaWR0aCA9IDAsIGJvcmRlclJpZ2h0V2lkdGggPSAwLCBib3JkZXJCb3R0b21XaWR0aCA9IDAsIH0gPSBub2RlLmJveDtcbiAgICBjdHguZmlsbENvbG9yKFBBRERJTkdfQ09MT1IpLm9wYWNpdHkoMC41KTtcbiAgICAvLyBQYWRkaW5nIHRvcFxuICAgIGN0eFxuICAgICAgICAucmVjdChsZWZ0ICsgcGFkZGluZ0xlZnQgKyBib3JkZXJMZWZ0V2lkdGgsIHRvcCArIGJvcmRlclRvcFdpZHRoLCB3aWR0aCAtIHBhZGRpbmdSaWdodCAtIHBhZGRpbmdMZWZ0IC0gYm9yZGVyTGVmdFdpZHRoIC0gYm9yZGVyUmlnaHRXaWR0aCwgcGFkZGluZ1RvcClcbiAgICAgICAgLmZpbGwoKTtcbiAgICAvLyBQYWRkaW5nIGxlZnRcbiAgICBjdHhcbiAgICAgICAgLnJlY3QobGVmdCArIGJvcmRlckxlZnRXaWR0aCwgdG9wICsgYm9yZGVyVG9wV2lkdGgsIHBhZGRpbmdMZWZ0LCBoZWlnaHQgLSBib3JkZXJUb3BXaWR0aCAtIGJvcmRlckJvdHRvbVdpZHRoKVxuICAgICAgICAuZmlsbCgpO1xuICAgIC8vIFBhZGRpbmcgcmlnaHRcbiAgICBjdHhcbiAgICAgICAgLnJlY3QobGVmdCArIHdpZHRoIC0gcGFkZGluZ1JpZ2h0IC0gYm9yZGVyUmlnaHRXaWR0aCwgdG9wICsgYm9yZGVyVG9wV2lkdGgsIHBhZGRpbmdSaWdodCwgaGVpZ2h0IC0gYm9yZGVyVG9wV2lkdGggLSBib3JkZXJCb3R0b21XaWR0aClcbiAgICAgICAgLmZpbGwoKTtcbiAgICAvLyBQYWRkaW5nIGJvdHRvbVxuICAgIGN0eFxuICAgICAgICAucmVjdChsZWZ0ICsgcGFkZGluZ0xlZnQgKyBib3JkZXJMZWZ0V2lkdGgsIHRvcCArIGhlaWdodCAtIHBhZGRpbmdCb3R0b20gLSBib3JkZXJCb3R0b21XaWR0aCwgd2lkdGggLSBwYWRkaW5nUmlnaHQgLSBwYWRkaW5nTGVmdCAtIGJvcmRlckxlZnRXaWR0aCAtIGJvcmRlclJpZ2h0V2lkdGgsIHBhZGRpbmdCb3R0b20pXG4gICAgICAgIC5maWxsKCk7XG59O1xuY29uc3QgZGVidWdNYXJnaW4gPSAoY3R4LCBub2RlKSA9PiB7XG4gICAgaWYgKCFub2RlLmJveClcbiAgICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHsgbGVmdCwgdG9wLCB3aWR0aCwgaGVpZ2h0IH0gPSBub2RlLmJveDtcbiAgICBjb25zdCB7IG1hcmdpbkxlZnQgPSAwLCBtYXJnaW5Ub3AgPSAwLCBtYXJnaW5SaWdodCA9IDAsIG1hcmdpbkJvdHRvbSA9IDAsIH0gPSBub2RlLmJveDtcbiAgICBjdHguZmlsbENvbG9yKE1BUkdJTl9DT0xPUikub3BhY2l0eSgwLjUpO1xuICAgIC8vIE1hcmdpbiB0b3BcbiAgICBjdHgucmVjdChsZWZ0LCB0b3AgLSBtYXJnaW5Ub3AsIHdpZHRoLCBtYXJnaW5Ub3ApLmZpbGwoKTtcbiAgICAvLyBNYXJnaW4gbGVmdFxuICAgIGN0eFxuICAgICAgICAucmVjdChsZWZ0IC0gbWFyZ2luTGVmdCwgdG9wIC0gbWFyZ2luVG9wLCBtYXJnaW5MZWZ0LCBoZWlnaHQgKyBtYXJnaW5Ub3AgKyBtYXJnaW5Cb3R0b20pXG4gICAgICAgIC5maWxsKCk7XG4gICAgLy8gTWFyZ2luIHJpZ2h0XG4gICAgY3R4XG4gICAgICAgIC5yZWN0KGxlZnQgKyB3aWR0aCwgdG9wIC0gbWFyZ2luVG9wLCBtYXJnaW5SaWdodCwgaGVpZ2h0ICsgbWFyZ2luVG9wICsgbWFyZ2luQm90dG9tKVxuICAgICAgICAuZmlsbCgpO1xuICAgIC8vIE1hcmdpbiBib3R0b21cbiAgICBjdHgucmVjdChsZWZ0LCB0b3AgKyBoZWlnaHQsIHdpZHRoLCBtYXJnaW5Cb3R0b20pLmZpbGwoKTtcbn07XG5jb25zdCBkZWJ1Z1RleHQgPSAoY3R4LCBub2RlKSA9PiB7XG4gICAgaWYgKCFub2RlLmJveClcbiAgICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHsgbGVmdCwgdG9wLCB3aWR0aCwgaGVpZ2h0IH0gPSBub2RlLmJveDtcbiAgICBjb25zdCB7IG1hcmdpbkxlZnQgPSAwLCBtYXJnaW5Ub3AgPSAwLCBtYXJnaW5SaWdodCA9IDAsIG1hcmdpbkJvdHRvbSA9IDAsIH0gPSBub2RlLmJveDtcbiAgICBjb25zdCByb3VuZGVkV2lkdGggPSBNYXRoLnJvdW5kKHdpZHRoICsgbWFyZ2luTGVmdCArIG1hcmdpblJpZ2h0KTtcbiAgICBjb25zdCByb3VuZGVkSGVpZ2h0ID0gTWF0aC5yb3VuZChoZWlnaHQgKyBtYXJnaW5Ub3AgKyBtYXJnaW5Cb3R0b20pO1xuICAgIGN0eFxuICAgICAgICAuZm9udFNpemUoNilcbiAgICAgICAgLm9wYWNpdHkoMSlcbiAgICAgICAgLmZpbGxDb2xvcignYmxhY2snKVxuICAgICAgICAudGV4dChgJHtyb3VuZGVkV2lkdGh9IHggJHtyb3VuZGVkSGVpZ2h0fWAsIGxlZnQgLSBtYXJnaW5MZWZ0LCBNYXRoLm1heCh0b3AgLSBtYXJnaW5Ub3AgLSA0LCAxKSwgeyB3aWR0aDogSW5maW5pdHkgfSk7XG59O1xuY29uc3QgZGVidWdPcmlnaW4gPSAoY3R4LCBub2RlKSA9PiB7XG4gICAgaWYgKG5vZGUub3JpZ2luKSB7XG4gICAgICAgIGN0eFxuICAgICAgICAgICAgLmNpcmNsZShub2RlLm9yaWdpbi5sZWZ0LCBub2RlLm9yaWdpbi50b3AsIDMpXG4gICAgICAgICAgICAuZmlsbCgncmVkJylcbiAgICAgICAgICAgIC5jaXJjbGUobm9kZS5vcmlnaW4ubGVmdCwgbm9kZS5vcmlnaW4udG9wLCA1KVxuICAgICAgICAgICAgLnN0cm9rZSgncmVkJyk7XG4gICAgfVxufTtcbmNvbnN0IHJlbmRlckRlYnVnID0gKGN0eCwgbm9kZSkgPT4ge1xuICAgIGlmICghbm9kZS5wcm9wcylcbiAgICAgICAgcmV0dXJuO1xuICAgIGlmICghKCdkZWJ1ZycgaW4gbm9kZS5wcm9wcykgfHwgIW5vZGUucHJvcHMuZGVidWcpXG4gICAgICAgIHJldHVybjtcbiAgICBjdHguc2F2ZSgpO1xuICAgIGRlYnVnQ29udGVudChjdHgsIG5vZGUpO1xuICAgIGRlYnVnUGFkZGluZyhjdHgsIG5vZGUpO1xuICAgIGRlYnVnTWFyZ2luKGN0eCwgbm9kZSk7XG4gICAgZGVidWdUZXh0KGN0eCwgbm9kZSk7XG4gICAgZGVidWdPcmlnaW4oY3R4LCBub2RlKTtcbiAgICBjdHgucmVzdG9yZSgpO1xufTtcblxuY29uc3QgYXZhaWxhYmxlTWV0aG9kcyA9IFtcbiAgICAnZGFzaCcsXG4gICAgJ2NsaXAnLFxuICAgICdzYXZlJyxcbiAgICAncGF0aCcsXG4gICAgJ2ZpbGwnLFxuICAgICdmb250JyxcbiAgICAndGV4dCcsXG4gICAgJ3JlY3QnLFxuICAgICdzY2FsZScsXG4gICAgJ21vdmVUbycsXG4gICAgJ2xpbmVUbycsXG4gICAgJ3N0cm9rZScsXG4gICAgJ3JvdGF0ZScsXG4gICAgJ2NpcmNsZScsXG4gICAgJ2xpbmVDYXAnLFxuICAgICdvcGFjaXR5JyxcbiAgICAnZWxsaXBzZScsXG4gICAgJ3BvbHlnb24nLFxuICAgICdyZXN0b3JlJyxcbiAgICAnbGluZUpvaW4nLFxuICAgICdmb250U2l6ZScsXG4gICAgJ2ZpbGxDb2xvcicsXG4gICAgJ2xpbmVXaWR0aCcsXG4gICAgJ3RyYW5zbGF0ZScsXG4gICAgJ21pdGVyTGltaXQnLFxuICAgICdzdHJva2VDb2xvcicsXG4gICAgJ2ZpbGxPcGFjaXR5JyxcbiAgICAncm91bmRlZFJlY3QnLFxuICAgICdmaWxsQW5kU3Ryb2tlJyxcbiAgICAnc3Ryb2tlT3BhY2l0eScsXG4gICAgJ2JlemllckN1cnZlVG8nLFxuICAgICdxdWFkcmF0aWNDdXJ2ZVRvJyxcbiAgICAnbGluZWFyR3JhZGllbnQnLFxuICAgICdyYWRpYWxHcmFkaWVudCcsXG5dO1xuY29uc3QgcGFpbnRlciA9IChjdHgpID0+IHtcbiAgICBjb25zdCBwID0gYXZhaWxhYmxlTWV0aG9kcy5yZWR1Y2UoKGFjYywgcHJvcCkgPT4gKHtcbiAgICAgICAgLi4uYWNjLFxuICAgICAgICBbcHJvcF06ICguLi5hcmdzKSA9PiB7XG4gICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIGN0eFtwcm9wXSBpcyBhIGZ1bmN0aW9uXG4gICAgICAgICAgICBjdHhbcHJvcF0oLi4uYXJncyk7XG4gICAgICAgICAgICByZXR1cm4gcDtcbiAgICAgICAgfSxcbiAgICB9KSwge30pO1xuICAgIHJldHVybiBwO1xufTtcbmNvbnN0IHJlbmRlckNhbnZhcyA9IChjdHgsIG5vZGUpID0+IHtcbiAgICBpZiAoIW5vZGUuYm94KVxuICAgICAgICByZXR1cm47XG4gICAgY29uc3QgeyB0b3AsIGxlZnQsIHdpZHRoLCBoZWlnaHQgfSA9IG5vZGUuYm94O1xuICAgIGNvbnN0IHBhZGRpbmdUb3AgPSBub2RlLmJveC5wYWRkaW5nVG9wIHx8IDA7XG4gICAgY29uc3QgcGFkZGluZ0xlZnQgPSBub2RlLmJveC5wYWRkaW5nTGVmdCB8fCAwO1xuICAgIGNvbnN0IHBhZGRpbmdSaWdodCA9IG5vZGUuYm94LnBhZGRpbmdSaWdodCB8fCAwO1xuICAgIGNvbnN0IHBhZGRpbmdCb3R0b20gPSBub2RlLmJveC5wYWRkaW5nQm90dG9tIHx8IDA7XG4gICAgY29uc3QgYXZhaWxhYmxlV2lkdGggPSB3aWR0aCAtIHBhZGRpbmdMZWZ0IC0gcGFkZGluZ1JpZ2h0O1xuICAgIGNvbnN0IGF2YWlsYWJsZUhlaWdodCA9IGhlaWdodCAtIHBhZGRpbmdUb3AgLSBwYWRkaW5nQm90dG9tO1xuICAgIGlmICghYXZhaWxhYmxlV2lkdGggfHwgIWF2YWlsYWJsZUhlaWdodCkge1xuICAgICAgICBjb25zb2xlLndhcm4oJ0NhbnZhcyBlbGVtZW50IGhhcyBudWxsIHdpZHRoIG9yIGhlaWdodC4gUGxlYXNlIHByb3ZpZGUgdmFsaWQgdmFsdWVzIHZpYSB0aGUgYHN0eWxlYCBwcm9wIGluIG9yZGVyIHRvIGNvcnJlY3RseSByZW5kZXIgaXQuJyk7XG4gICAgfVxuICAgIGN0eC5zYXZlKCkudHJhbnNsYXRlKGxlZnQgKyBwYWRkaW5nTGVmdCwgdG9wICsgcGFkZGluZ1RvcCk7XG4gICAgaWYgKG5vZGUucHJvcHMucGFpbnQpIHtcbiAgICAgICAgbm9kZS5wcm9wcy5wYWludChwYWludGVyKGN0eCksIGF2YWlsYWJsZVdpZHRoLCBhdmFpbGFibGVIZWlnaHQpO1xuICAgIH1cbiAgICBjdHgucmVzdG9yZSgpO1xufTtcblxuLy8gUmVmOiBodHRwczovL3d3dy53My5vcmcvVFIvY3NzLWJhY2tncm91bmRzLTMvI2JvcmRlcnNcbi8vIFRoaXMgY29uc3RhbnQgaXMgdXNlZCB0byBhcHByb3hpbWF0ZSBhIHN5bW1ldHJpY2FsIGFyYyB1c2luZyBhIGN1YmljIEJlemllciBjdXJ2ZS5cbmNvbnN0IEtBUFBBID0gNC4wICogKChNYXRoLnNxcnQoMikgLSAxLjApIC8gMy4wKTtcbmNvbnN0IGNsaXBCb3JkZXJUb3AgPSAoY3R4LCBsYXlvdXQsIHN0eWxlLCBydHIsIHJ0bCkgPT4ge1xuICAgIGNvbnN0IHsgdG9wLCBsZWZ0LCB3aWR0aCwgaGVpZ2h0IH0gPSBsYXlvdXQ7XG4gICAgY29uc3QgeyBib3JkZXJUb3BXaWR0aCwgYm9yZGVyUmlnaHRXaWR0aCwgYm9yZGVyTGVmdFdpZHRoIH0gPSBzdHlsZTtcbiAgICAvLyBDbGlwIG91dGVyIHRvcCBib3JkZXIgZWRnZVxuICAgIGN0eC5tb3ZlVG8obGVmdCArIHJ0bCwgdG9wKTtcbiAgICBjdHgubGluZVRvKGxlZnQgKyB3aWR0aCAtIHJ0ciwgdG9wKTtcbiAgICAvLyBFbGxpcHNlIGNvZWZmaWNpZW50cyBvdXRlciB0b3AgcmlnaHQgY2FwXG4gICAgY29uc3QgYzAgPSBydHIgKiAoMS4wIC0gS0FQUEEpO1xuICAgIC8vIENsaXAgb3V0ZXIgdG9wIHJpZ2h0IGNhcFxuICAgIGN0eC5iZXppZXJDdXJ2ZVRvKGxlZnQgKyB3aWR0aCAtIGMwLCB0b3AsIGxlZnQgKyB3aWR0aCwgdG9wICsgYzAsIGxlZnQgKyB3aWR0aCwgdG9wICsgcnRyKTtcbiAgICAvLyBNb3ZlIGRvd24gaW4gY2FzZSB0aGUgbWFyZ2luIGV4Y2VlZGVzIHRoZSByYWRpdXNcbiAgICBjb25zdCB0b3BSaWdodFlDb29yZCA9IHRvcCArIE1hdGgubWF4KGJvcmRlclRvcFdpZHRoLCBydHIpO1xuICAgIGN0eC5saW5lVG8obGVmdCArIHdpZHRoLCB0b3BSaWdodFlDb29yZCk7XG4gICAgLy8gQ2xpcCBpbm5lciB0b3AgcmlnaHQgY2FwXG4gICAgY3R4LmxpbmVUbyhsZWZ0ICsgd2lkdGggLSBib3JkZXJSaWdodFdpZHRoLCB0b3BSaWdodFlDb29yZCk7XG4gICAgLy8gRWxsaXBzZSBjb2VmZmljaWVudHMgaW5uZXIgdG9wIHJpZ2h0IGNhcFxuICAgIGNvbnN0IGlubmVyVG9wUmlnaHRSYWRpdXNYID0gTWF0aC5tYXgocnRyIC0gYm9yZGVyUmlnaHRXaWR0aCwgMCk7XG4gICAgY29uc3QgaW5uZXJUb3BSaWdodFJhZGl1c1kgPSBNYXRoLm1heChydHIgLSBib3JkZXJUb3BXaWR0aCwgMCk7XG4gICAgY29uc3QgYzEgPSBpbm5lclRvcFJpZ2h0UmFkaXVzWCAqICgxLjAgLSBLQVBQQSk7XG4gICAgY29uc3QgYzIgPSBpbm5lclRvcFJpZ2h0UmFkaXVzWSAqICgxLjAgLSBLQVBQQSk7XG4gICAgLy8gQ2xpcCBpbm5lciB0b3AgcmlnaHQgY2FwXG4gICAgY3R4LmJlemllckN1cnZlVG8obGVmdCArIHdpZHRoIC0gYm9yZGVyUmlnaHRXaWR0aCwgdG9wICsgYm9yZGVyVG9wV2lkdGggKyBjMiwgbGVmdCArIHdpZHRoIC0gYm9yZGVyUmlnaHRXaWR0aCAtIGMxLCB0b3AgKyBib3JkZXJUb3BXaWR0aCwgbGVmdCArIHdpZHRoIC0gYm9yZGVyUmlnaHRXaWR0aCAtIGlubmVyVG9wUmlnaHRSYWRpdXNYLCB0b3AgKyBib3JkZXJUb3BXaWR0aCk7XG4gICAgLy8gQ2xpcCBpbm5lciB0b3AgYm9yZGVyIGVkZ2VcbiAgICBjdHgubGluZVRvKGxlZnQgKyBNYXRoLm1heChydGwsIGJvcmRlckxlZnRXaWR0aCksIHRvcCArIGJvcmRlclRvcFdpZHRoKTtcbiAgICAvLyBFbGxpcHNlIGNvZWZmaWNpZW50cyBpbm5lciB0b3AgbGVmdCBjYXBcbiAgICBjb25zdCBpbm5lclRvcExlZnRSYWRpdXNYID0gTWF0aC5tYXgocnRsIC0gYm9yZGVyTGVmdFdpZHRoLCAwKTtcbiAgICBjb25zdCBpbm5lclRvcExlZnRSYWRpdXNZID0gTWF0aC5tYXgocnRsIC0gYm9yZGVyVG9wV2lkdGgsIDApO1xuICAgIGNvbnN0IGMzID0gaW5uZXJUb3BMZWZ0UmFkaXVzWCAqICgxLjAgLSBLQVBQQSk7XG4gICAgY29uc3QgYzQgPSBpbm5lclRvcExlZnRSYWRpdXNZICogKDEuMCAtIEtBUFBBKTtcbiAgICBjb25zdCB0b3BMZWZ0WUNvb3JkID0gdG9wICsgTWF0aC5tYXgoYm9yZGVyVG9wV2lkdGgsIHJ0bCk7XG4gICAgLy8gQ2xpcCBpbm5lciB0b3AgbGVmdCBjYXBcbiAgICBjdHguYmV6aWVyQ3VydmVUbyhsZWZ0ICsgYm9yZGVyTGVmdFdpZHRoICsgYzMsIHRvcCArIGJvcmRlclRvcFdpZHRoLCBsZWZ0ICsgYm9yZGVyTGVmdFdpZHRoLCB0b3AgKyBib3JkZXJUb3BXaWR0aCArIGM0LCBsZWZ0ICsgYm9yZGVyTGVmdFdpZHRoLCB0b3BMZWZ0WUNvb3JkKTtcbiAgICBjdHgubGluZVRvKGxlZnQsIHRvcExlZnRZQ29vcmQpO1xuICAgIC8vIE1vdmUgZG93biBpbiBjYXNlIHRoZSBtYXJnaW4gZXhjZWVkZXMgdGhlIHJhZGl1c1xuICAgIGN0eC5saW5lVG8obGVmdCwgdG9wICsgcnRsKTtcbiAgICAvLyBFbGxpcHNlIGNvZWZmaWNpZW50cyBvdXRlciB0b3AgbGVmdCBjYXBcbiAgICBjb25zdCBjNSA9IHJ0bCAqICgxLjAgLSBLQVBQQSk7XG4gICAgLy8gQ2xpcCBvdXRlciB0b3AgbGVmdCBjYXBcbiAgICBjdHguYmV6aWVyQ3VydmVUbyhsZWZ0LCB0b3AgKyBjNSwgbGVmdCArIGM1LCB0b3AsIGxlZnQgKyBydGwsIHRvcCk7XG4gICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgIGN0eC5jbGlwKCk7XG4gICAgLy8gQ2xpcCBib3JkZXIgdG9wIGNhcCBqb2luc1xuICAgIGlmIChib3JkZXJSaWdodFdpZHRoKSB7XG4gICAgICAgIGNvbnN0IHRyU2xvcGUgPSAtYm9yZGVyVG9wV2lkdGggLyBib3JkZXJSaWdodFdpZHRoO1xuICAgICAgICBjdHgubW92ZVRvKGxlZnQgKyB3aWR0aCAvIDIsIHRyU2xvcGUgKiAoLXdpZHRoIC8gMikgKyB0b3ApO1xuICAgICAgICBjdHgubGluZVRvKGxlZnQgKyB3aWR0aCwgdG9wKTtcbiAgICAgICAgY3R4LmxpbmVUbyhsZWZ0LCB0b3ApO1xuICAgICAgICBjdHgubGluZVRvKGxlZnQsIHRvcCArIGhlaWdodCk7XG4gICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgICAgY3R4LmNsaXAoKTtcbiAgICB9XG4gICAgaWYgKGJvcmRlckxlZnRXaWR0aCkge1xuICAgICAgICBjb25zdCB0clNsb3BlID0gLWJvcmRlclRvcFdpZHRoIC8gYm9yZGVyTGVmdFdpZHRoO1xuICAgICAgICBjdHgubW92ZVRvKGxlZnQgKyB3aWR0aCAvIDIsIHRyU2xvcGUgKiAoLXdpZHRoIC8gMikgKyB0b3ApO1xuICAgICAgICBjdHgubGluZVRvKGxlZnQsIHRvcCk7XG4gICAgICAgIGN0eC5saW5lVG8obGVmdCArIHdpZHRoLCB0b3ApO1xuICAgICAgICBjdHgubGluZVRvKGxlZnQgKyB3aWR0aCwgdG9wICsgaGVpZ2h0KTtcbiAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgICBjdHguY2xpcCgpO1xuICAgIH1cbn07XG5jb25zdCBmaWxsQm9yZGVyVG9wID0gKGN0eCwgbGF5b3V0LCBzdHlsZSwgcnRyLCBydGwpID0+IHtcbiAgICBjb25zdCB7IHRvcCwgbGVmdCwgd2lkdGggfSA9IGxheW91dDtcbiAgICBjb25zdCB7IGJvcmRlclRvcENvbG9yLCBib3JkZXJUb3BXaWR0aCwgYm9yZGVyVG9wU3R5bGUsIGJvcmRlclJpZ2h0V2lkdGgsIGJvcmRlckxlZnRXaWR0aCwgfSA9IHN0eWxlO1xuICAgIGNvbnN0IGMwID0gcnRsICogKDEuMCAtIEtBUFBBKTtcbiAgICBjb25zdCBjMSA9IHJ0ciAqICgxLjAgLSBLQVBQQSk7XG4gICAgY3R4Lm1vdmVUbyhsZWZ0LCB0b3AgKyBNYXRoLm1heChydGwsIGJvcmRlclRvcFdpZHRoKSk7XG4gICAgY3R4LmJlemllckN1cnZlVG8obGVmdCwgdG9wICsgYzAsIGxlZnQgKyBjMCwgdG9wLCBsZWZ0ICsgcnRsLCB0b3ApO1xuICAgIGN0eC5saW5lVG8obGVmdCArIHdpZHRoIC0gcnRyLCB0b3ApO1xuICAgIGN0eC5iZXppZXJDdXJ2ZVRvKGxlZnQgKyB3aWR0aCAtIGMxLCB0b3AsIGxlZnQgKyB3aWR0aCwgdG9wICsgYzEsIGxlZnQgKyB3aWR0aCwgdG9wICsgcnRyKTtcbiAgICBjdHguc3Ryb2tlQ29sb3IoYm9yZGVyVG9wQ29sb3IpO1xuICAgIGN0eC5saW5lV2lkdGgoTWF0aC5tYXgoYm9yZGVyUmlnaHRXaWR0aCwgYm9yZGVyVG9wV2lkdGgsIGJvcmRlckxlZnRXaWR0aCkgKiAyKTtcbiAgICBpZiAoYm9yZGVyVG9wU3R5bGUgPT09ICdkYXNoZWQnKSB7XG4gICAgICAgIGN0eC5kYXNoKGJvcmRlclRvcFdpZHRoICogMiwgeyBzcGFjZTogYm9yZGVyVG9wV2lkdGggKiAxLjIgfSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGJvcmRlclRvcFN0eWxlID09PSAnZG90dGVkJykge1xuICAgICAgICBjdHguZGFzaChib3JkZXJUb3BXaWR0aCwgeyBzcGFjZTogYm9yZGVyVG9wV2lkdGggKiAxLjIgfSk7XG4gICAgfVxuICAgIGN0eC5zdHJva2UoKTtcbiAgICBjdHgudW5kYXNoKCk7XG59O1xuY29uc3QgY2xpcEJvcmRlclJpZ2h0ID0gKGN0eCwgbGF5b3V0LCBzdHlsZSwgcnRyLCByYnIpID0+IHtcbiAgICBjb25zdCB7IHRvcCwgbGVmdCwgd2lkdGgsIGhlaWdodCB9ID0gbGF5b3V0O1xuICAgIGNvbnN0IHsgYm9yZGVyVG9wV2lkdGgsIGJvcmRlclJpZ2h0V2lkdGgsIGJvcmRlckJvdHRvbVdpZHRoIH0gPSBzdHlsZTtcbiAgICAvLyBDbGlwIG91dGVyIHJpZ2h0IGJvcmRlciBlZGdlXG4gICAgY3R4Lm1vdmVUbyhsZWZ0ICsgd2lkdGgsIHRvcCArIHJ0cik7XG4gICAgY3R4LmxpbmVUbyhsZWZ0ICsgd2lkdGgsIHRvcCArIGhlaWdodCAtIHJicik7XG4gICAgLy8gRWxsaXBzZSBjb2VmZmljaWVudHMgb3V0ZXIgYm90dG9tIHJpZ2h0IGNhcFxuICAgIGNvbnN0IGMwID0gcmJyICogKDEuMCAtIEtBUFBBKTtcbiAgICAvLyBDbGlwIG91dGVyIHRvcCByaWdodCBjYXBcbiAgICBjdHguYmV6aWVyQ3VydmVUbyhsZWZ0ICsgd2lkdGgsIHRvcCArIGhlaWdodCAtIGMwLCBsZWZ0ICsgd2lkdGggLSBjMCwgdG9wICsgaGVpZ2h0LCBsZWZ0ICsgd2lkdGggLSByYnIsIHRvcCArIGhlaWdodCk7XG4gICAgLy8gTW92ZSBsZWZ0IGluIGNhc2UgdGhlIG1hcmdpbiBleGNlZWRlcyB0aGUgcmFkaXVzXG4gICAgY29uc3QgdG9wQm90dG9tWENvb3JkID0gbGVmdCArIHdpZHRoIC0gTWF0aC5tYXgoYm9yZGVyUmlnaHRXaWR0aCwgcmJyKTtcbiAgICBjdHgubGluZVRvKHRvcEJvdHRvbVhDb29yZCwgdG9wICsgaGVpZ2h0KTtcbiAgICAvLyBDbGlwIGlubmVyIGJvdHRvbSByaWdodCBjYXBcbiAgICBjdHgubGluZVRvKHRvcEJvdHRvbVhDb29yZCwgdG9wICsgaGVpZ2h0IC0gYm9yZGVyQm90dG9tV2lkdGgpO1xuICAgIC8vIEVsbGlwc2UgY29lZmZpY2llbnRzIGlubmVyIGJvdHRvbSByaWdodCBjYXBcbiAgICBjb25zdCBpbm5lckJvdHRvbVJpZ2h0UmFkaXVzWCA9IE1hdGgubWF4KHJiciAtIGJvcmRlclJpZ2h0V2lkdGgsIDApO1xuICAgIGNvbnN0IGlubmVyQm90dG9tUmlnaHRSYWRpdXNZID0gTWF0aC5tYXgocmJyIC0gYm9yZGVyQm90dG9tV2lkdGgsIDApO1xuICAgIGNvbnN0IGMxID0gaW5uZXJCb3R0b21SaWdodFJhZGl1c1ggKiAoMS4wIC0gS0FQUEEpO1xuICAgIGNvbnN0IGMyID0gaW5uZXJCb3R0b21SaWdodFJhZGl1c1kgKiAoMS4wIC0gS0FQUEEpO1xuICAgIC8vIENsaXAgaW5uZXIgdG9wIHJpZ2h0IGNhcFxuICAgIGN0eC5iZXppZXJDdXJ2ZVRvKGxlZnQgKyB3aWR0aCAtIGJvcmRlclJpZ2h0V2lkdGggLSBjMSwgdG9wICsgaGVpZ2h0IC0gYm9yZGVyQm90dG9tV2lkdGgsIGxlZnQgKyB3aWR0aCAtIGJvcmRlclJpZ2h0V2lkdGgsIHRvcCArIGhlaWdodCAtIGJvcmRlckJvdHRvbVdpZHRoIC0gYzIsIGxlZnQgKyB3aWR0aCAtIGJvcmRlclJpZ2h0V2lkdGgsIHRvcCArIGhlaWdodCAtIE1hdGgubWF4KHJiciwgYm9yZGVyQm90dG9tV2lkdGgpKTtcbiAgICAvLyBDbGlwIGlubmVyIHJpZ2h0IGJvcmRlciBlZGdlXG4gICAgY3R4LmxpbmVUbyhsZWZ0ICsgd2lkdGggLSBib3JkZXJSaWdodFdpZHRoLCB0b3AgKyBNYXRoLm1heChydHIsIGJvcmRlclRvcFdpZHRoKSk7XG4gICAgLy8gRWxsaXBzZSBjb2VmZmljaWVudHMgaW5uZXIgdG9wIHJpZ2h0IGNhcFxuICAgIGNvbnN0IGlubmVyVG9wUmlnaHRSYWRpdXNYID0gTWF0aC5tYXgocnRyIC0gYm9yZGVyUmlnaHRXaWR0aCwgMCk7XG4gICAgY29uc3QgaW5uZXJUb3BSaWdodFJhZGl1c1kgPSBNYXRoLm1heChydHIgLSBib3JkZXJUb3BXaWR0aCwgMCk7XG4gICAgY29uc3QgYzMgPSBpbm5lclRvcFJpZ2h0UmFkaXVzWCAqICgxLjAgLSBLQVBQQSk7XG4gICAgY29uc3QgYzQgPSBpbm5lclRvcFJpZ2h0UmFkaXVzWSAqICgxLjAgLSBLQVBQQSk7XG4gICAgY29uc3QgdG9wUmlnaHRYQ29vcmQgPSBsZWZ0ICsgd2lkdGggLSBNYXRoLm1heChydHIsIGJvcmRlclJpZ2h0V2lkdGgpO1xuICAgIC8vIENsaXAgaW5uZXIgdG9wIGxlZnQgY2FwXG4gICAgY3R4LmJlemllckN1cnZlVG8obGVmdCArIHdpZHRoIC0gYm9yZGVyUmlnaHRXaWR0aCwgdG9wICsgYm9yZGVyVG9wV2lkdGggKyBjNCwgbGVmdCArIHdpZHRoIC0gYm9yZGVyUmlnaHRXaWR0aCAtIGMzLCB0b3AgKyBib3JkZXJUb3BXaWR0aCwgdG9wUmlnaHRYQ29vcmQsIHRvcCArIGJvcmRlclRvcFdpZHRoKTtcbiAgICBjdHgubGluZVRvKHRvcFJpZ2h0WENvb3JkLCB0b3ApO1xuICAgIC8vIE1vdmUgcmlnaHQgaW4gY2FzZSB0aGUgbWFyZ2luIGV4Y2VlZGVzIHRoZSByYWRpdXNcbiAgICBjdHgubGluZVRvKGxlZnQgKyB3aWR0aCAtIHJ0ciwgdG9wKTtcbiAgICAvLyBFbGxpcHNlIGNvZWZmaWNpZW50cyBvdXRlciB0b3AgcmlnaHQgY2FwXG4gICAgY29uc3QgYzUgPSBydHIgKiAoMS4wIC0gS0FQUEEpO1xuICAgIC8vIENsaXAgb3V0ZXIgdG9wIHJpZ2h0IGNhcFxuICAgIGN0eC5iZXppZXJDdXJ2ZVRvKGxlZnQgKyB3aWR0aCAtIGM1LCB0b3AsIGxlZnQgKyB3aWR0aCwgdG9wICsgYzUsIGxlZnQgKyB3aWR0aCwgdG9wICsgcnRyKTtcbiAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgY3R4LmNsaXAoKTtcbiAgICAvLyBDbGlwIGJvcmRlciByaWdodCBjYXAgam9pbnNcbiAgICBpZiAoYm9yZGVyVG9wV2lkdGgpIHtcbiAgICAgICAgY29uc3QgdHJTbG9wZSA9IC1ib3JkZXJUb3BXaWR0aCAvIGJvcmRlclJpZ2h0V2lkdGg7XG4gICAgICAgIGN0eC5tb3ZlVG8obGVmdCArIHdpZHRoIC8gMiwgdHJTbG9wZSAqICgtd2lkdGggLyAyKSArIHRvcCk7XG4gICAgICAgIGN0eC5saW5lVG8obGVmdCArIHdpZHRoLCB0b3ApO1xuICAgICAgICBjdHgubGluZVRvKGxlZnQgKyB3aWR0aCwgdG9wICsgaGVpZ2h0KTtcbiAgICAgICAgY3R4LmxpbmVUbyhsZWZ0LCB0b3AgKyBoZWlnaHQpO1xuICAgICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICAgIGN0eC5jbGlwKCk7XG4gICAgfVxuICAgIGlmIChib3JkZXJCb3R0b21XaWR0aCkge1xuICAgICAgICBjb25zdCBiclNsb3BlID0gYm9yZGVyQm90dG9tV2lkdGggLyBib3JkZXJSaWdodFdpZHRoO1xuICAgICAgICBjdHgubW92ZVRvKGxlZnQgKyB3aWR0aCAvIDIsIGJyU2xvcGUgKiAoLXdpZHRoIC8gMikgKyB0b3AgKyBoZWlnaHQpO1xuICAgICAgICBjdHgubGluZVRvKGxlZnQgKyB3aWR0aCwgdG9wICsgaGVpZ2h0KTtcbiAgICAgICAgY3R4LmxpbmVUbyhsZWZ0ICsgd2lkdGgsIHRvcCk7XG4gICAgICAgIGN0eC5saW5lVG8obGVmdCwgdG9wKTtcbiAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgICBjdHguY2xpcCgpO1xuICAgIH1cbn07XG5jb25zdCBmaWxsQm9yZGVyUmlnaHQgPSAoY3R4LCBsYXlvdXQsIHN0eWxlLCBydHIsIHJicikgPT4ge1xuICAgIGNvbnN0IHsgdG9wLCBsZWZ0LCB3aWR0aCwgaGVpZ2h0IH0gPSBsYXlvdXQ7XG4gICAgY29uc3QgeyBib3JkZXJSaWdodENvbG9yLCBib3JkZXJSaWdodFN0eWxlLCBib3JkZXJSaWdodFdpZHRoLCBib3JkZXJUb3BXaWR0aCwgYm9yZGVyQm90dG9tV2lkdGgsIH0gPSBzdHlsZTtcbiAgICBjb25zdCBjMCA9IHJiciAqICgxLjAgLSBLQVBQQSk7XG4gICAgY29uc3QgYzEgPSBydHIgKiAoMS4wIC0gS0FQUEEpO1xuICAgIGN0eC5tb3ZlVG8obGVmdCArIHdpZHRoIC0gcnRyLCB0b3ApO1xuICAgIGN0eC5iZXppZXJDdXJ2ZVRvKGxlZnQgKyB3aWR0aCAtIGMxLCB0b3AsIGxlZnQgKyB3aWR0aCwgdG9wICsgYzEsIGxlZnQgKyB3aWR0aCwgdG9wICsgcnRyKTtcbiAgICBjdHgubGluZVRvKGxlZnQgKyB3aWR0aCwgdG9wICsgaGVpZ2h0IC0gcmJyKTtcbiAgICBjdHguYmV6aWVyQ3VydmVUbyhsZWZ0ICsgd2lkdGgsIHRvcCArIGhlaWdodCAtIGMwLCBsZWZ0ICsgd2lkdGggLSBjMCwgdG9wICsgaGVpZ2h0LCBsZWZ0ICsgd2lkdGggLSByYnIsIHRvcCArIGhlaWdodCk7XG4gICAgY3R4LnN0cm9rZUNvbG9yKGJvcmRlclJpZ2h0Q29sb3IpO1xuICAgIGN0eC5saW5lV2lkdGgoTWF0aC5tYXgoYm9yZGVyUmlnaHRXaWR0aCwgYm9yZGVyVG9wV2lkdGgsIGJvcmRlckJvdHRvbVdpZHRoKSAqIDIpO1xuICAgIGlmIChib3JkZXJSaWdodFN0eWxlID09PSAnZGFzaGVkJykge1xuICAgICAgICBjdHguZGFzaChib3JkZXJSaWdodFdpZHRoICogMiwgeyBzcGFjZTogYm9yZGVyUmlnaHRXaWR0aCAqIDEuMiB9KTtcbiAgICB9XG4gICAgZWxzZSBpZiAoYm9yZGVyUmlnaHRTdHlsZSA9PT0gJ2RvdHRlZCcpIHtcbiAgICAgICAgY3R4LmRhc2goYm9yZGVyUmlnaHRXaWR0aCwgeyBzcGFjZTogYm9yZGVyUmlnaHRXaWR0aCAqIDEuMiB9KTtcbiAgICB9XG4gICAgY3R4LnN0cm9rZSgpO1xuICAgIGN0eC51bmRhc2goKTtcbn07XG5jb25zdCBjbGlwQm9yZGVyQm90dG9tID0gKGN0eCwgbGF5b3V0LCBzdHlsZSwgcmJsLCByYnIpID0+IHtcbiAgICBjb25zdCB7IHRvcCwgbGVmdCwgd2lkdGgsIGhlaWdodCB9ID0gbGF5b3V0O1xuICAgIGNvbnN0IHsgYm9yZGVyQm90dG9tV2lkdGgsIGJvcmRlclJpZ2h0V2lkdGgsIGJvcmRlckxlZnRXaWR0aCB9ID0gc3R5bGU7XG4gICAgLy8gQ2xpcCBvdXRlciB0b3AgYm9yZGVyIGVkZ2VcbiAgICBjdHgubW92ZVRvKGxlZnQgKyB3aWR0aCAtIHJiciwgdG9wICsgaGVpZ2h0KTtcbiAgICBjdHgubGluZVRvKGxlZnQgKyByYmwsIHRvcCArIGhlaWdodCk7XG4gICAgLy8gRWxsaXBzZSBjb2VmZmljaWVudHMgb3V0ZXIgdG9wIHJpZ2h0IGNhcFxuICAgIGNvbnN0IGMwID0gcmJsICogKDEuMCAtIEtBUFBBKTtcbiAgICAvLyBDbGlwIG91dGVyIHRvcCByaWdodCBjYXBcbiAgICBjdHguYmV6aWVyQ3VydmVUbyhsZWZ0ICsgYzAsIHRvcCArIGhlaWdodCwgbGVmdCwgdG9wICsgaGVpZ2h0IC0gYzAsIGxlZnQsIHRvcCArIGhlaWdodCAtIHJibCk7XG4gICAgLy8gTW92ZSB1cCBpbiBjYXNlIHRoZSBtYXJnaW4gZXhjZWVkZXMgdGhlIHJhZGl1c1xuICAgIGNvbnN0IGJvdHRvbUxlZnRZQ29vcmQgPSB0b3AgKyBoZWlnaHQgLSBNYXRoLm1heChib3JkZXJCb3R0b21XaWR0aCwgcmJsKTtcbiAgICBjdHgubGluZVRvKGxlZnQsIGJvdHRvbUxlZnRZQ29vcmQpO1xuICAgIC8vIENsaXAgaW5uZXIgYm90dG9tIGxlZnQgY2FwXG4gICAgY3R4LmxpbmVUbyhsZWZ0ICsgYm9yZGVyTGVmdFdpZHRoLCBib3R0b21MZWZ0WUNvb3JkKTtcbiAgICAvLyBFbGxpcHNlIGNvZWZmaWNpZW50cyBpbm5lciB0b3AgcmlnaHQgY2FwXG4gICAgY29uc3QgaW5uZXJCb3R0b21MZWZ0UmFkaXVzWCA9IE1hdGgubWF4KHJibCAtIGJvcmRlckxlZnRXaWR0aCwgMCk7XG4gICAgY29uc3QgaW5uZXJCb3R0b21MZWZ0UmFkaXVzWSA9IE1hdGgubWF4KHJibCAtIGJvcmRlckJvdHRvbVdpZHRoLCAwKTtcbiAgICBjb25zdCBjMSA9IGlubmVyQm90dG9tTGVmdFJhZGl1c1ggKiAoMS4wIC0gS0FQUEEpO1xuICAgIGNvbnN0IGMyID0gaW5uZXJCb3R0b21MZWZ0UmFkaXVzWSAqICgxLjAgLSBLQVBQQSk7XG4gICAgLy8gQ2xpcCBpbm5lciBib3R0b20gbGVmdCBjYXBcbiAgICBjdHguYmV6aWVyQ3VydmVUbyhsZWZ0ICsgYm9yZGVyTGVmdFdpZHRoLCB0b3AgKyBoZWlnaHQgLSBib3JkZXJCb3R0b21XaWR0aCAtIGMyLCBsZWZ0ICsgYm9yZGVyTGVmdFdpZHRoICsgYzEsIHRvcCArIGhlaWdodCAtIGJvcmRlckJvdHRvbVdpZHRoLCBsZWZ0ICsgYm9yZGVyTGVmdFdpZHRoICsgaW5uZXJCb3R0b21MZWZ0UmFkaXVzWCwgdG9wICsgaGVpZ2h0IC0gYm9yZGVyQm90dG9tV2lkdGgpO1xuICAgIC8vIENsaXAgaW5uZXIgYm90dG9tIGJvcmRlciBlZGdlXG4gICAgY3R4LmxpbmVUbyhsZWZ0ICsgd2lkdGggLSBNYXRoLm1heChyYnIsIGJvcmRlclJpZ2h0V2lkdGgpLCB0b3AgKyBoZWlnaHQgLSBib3JkZXJCb3R0b21XaWR0aCk7XG4gICAgLy8gRWxsaXBzZSBjb2VmZmljaWVudHMgaW5uZXIgdG9wIGxlZnQgY2FwXG4gICAgY29uc3QgaW5uZXJCb3R0b21SaWdodFJhZGl1c1ggPSBNYXRoLm1heChyYnIgLSBib3JkZXJSaWdodFdpZHRoLCAwKTtcbiAgICBjb25zdCBpbm5lckJvdHRvbVJpZ2h0UmFkaXVzWSA9IE1hdGgubWF4KHJiciAtIGJvcmRlckJvdHRvbVdpZHRoLCAwKTtcbiAgICBjb25zdCBjMyA9IGlubmVyQm90dG9tUmlnaHRSYWRpdXNYICogKDEuMCAtIEtBUFBBKTtcbiAgICBjb25zdCBjNCA9IGlubmVyQm90dG9tUmlnaHRSYWRpdXNZICogKDEuMCAtIEtBUFBBKTtcbiAgICBjb25zdCBib3R0b21SaWdodFlDb29yZCA9IHRvcCArIGhlaWdodCAtIE1hdGgubWF4KGJvcmRlckJvdHRvbVdpZHRoLCByYnIpO1xuICAgIC8vIENsaXAgaW5uZXIgdG9wIGxlZnQgY2FwXG4gICAgY3R4LmJlemllckN1cnZlVG8obGVmdCArIHdpZHRoIC0gYm9yZGVyUmlnaHRXaWR0aCAtIGMzLCB0b3AgKyBoZWlnaHQgLSBib3JkZXJCb3R0b21XaWR0aCwgbGVmdCArIHdpZHRoIC0gYm9yZGVyUmlnaHRXaWR0aCwgdG9wICsgaGVpZ2h0IC0gYm9yZGVyQm90dG9tV2lkdGggLSBjNCwgbGVmdCArIHdpZHRoIC0gYm9yZGVyUmlnaHRXaWR0aCwgYm90dG9tUmlnaHRZQ29vcmQpO1xuICAgIGN0eC5saW5lVG8obGVmdCArIHdpZHRoLCBib3R0b21SaWdodFlDb29yZCk7XG4gICAgLy8gTW92ZSBkb3duIGluIGNhc2UgdGhlIG1hcmdpbiBleGNlZWRlcyB0aGUgcmFkaXVzXG4gICAgY3R4LmxpbmVUbyhsZWZ0ICsgd2lkdGgsIHRvcCArIGhlaWdodCAtIHJicik7XG4gICAgLy8gRWxsaXBzZSBjb2VmZmljaWVudHMgb3V0ZXIgdG9wIGxlZnQgY2FwXG4gICAgY29uc3QgYzUgPSByYnIgKiAoMS4wIC0gS0FQUEEpO1xuICAgIC8vIENsaXAgb3V0ZXIgdG9wIGxlZnQgY2FwXG4gICAgY3R4LmJlemllckN1cnZlVG8obGVmdCArIHdpZHRoLCB0b3AgKyBoZWlnaHQgLSBjNSwgbGVmdCArIHdpZHRoIC0gYzUsIHRvcCArIGhlaWdodCwgbGVmdCArIHdpZHRoIC0gcmJyLCB0b3AgKyBoZWlnaHQpO1xuICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICBjdHguY2xpcCgpO1xuICAgIC8vIENsaXAgYm9yZGVyIGJvdHRvbSBjYXAgam9pbnNcbiAgICBpZiAoYm9yZGVyUmlnaHRXaWR0aCkge1xuICAgICAgICBjb25zdCBiclNsb3BlID0gYm9yZGVyQm90dG9tV2lkdGggLyBib3JkZXJSaWdodFdpZHRoO1xuICAgICAgICBjdHgubW92ZVRvKGxlZnQgKyB3aWR0aCAvIDIsIGJyU2xvcGUgKiAoLXdpZHRoIC8gMikgKyB0b3AgKyBoZWlnaHQpO1xuICAgICAgICBjdHgubGluZVRvKGxlZnQgKyB3aWR0aCwgdG9wICsgaGVpZ2h0KTtcbiAgICAgICAgY3R4LmxpbmVUbyhsZWZ0LCB0b3AgKyBoZWlnaHQpO1xuICAgICAgICBjdHgubGluZVRvKGxlZnQsIHRvcCk7XG4gICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgICAgY3R4LmNsaXAoKTtcbiAgICB9XG4gICAgaWYgKGJvcmRlckxlZnRXaWR0aCkge1xuICAgICAgICBjb25zdCB0clNsb3BlID0gLWJvcmRlckJvdHRvbVdpZHRoIC8gYm9yZGVyTGVmdFdpZHRoO1xuICAgICAgICBjdHgubW92ZVRvKGxlZnQgKyB3aWR0aCAvIDIsIHRyU2xvcGUgKiAod2lkdGggLyAyKSArIHRvcCArIGhlaWdodCk7XG4gICAgICAgIGN0eC5saW5lVG8obGVmdCwgdG9wICsgaGVpZ2h0KTtcbiAgICAgICAgY3R4LmxpbmVUbyhsZWZ0ICsgd2lkdGgsIHRvcCArIGhlaWdodCk7XG4gICAgICAgIGN0eC5saW5lVG8obGVmdCArIHdpZHRoLCB0b3ApO1xuICAgICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICAgIGN0eC5jbGlwKCk7XG4gICAgfVxufTtcbmNvbnN0IGZpbGxCb3JkZXJCb3R0b20gPSAoY3R4LCBsYXlvdXQsIHN0eWxlLCByYmwsIHJicikgPT4ge1xuICAgIGNvbnN0IHsgdG9wLCBsZWZ0LCB3aWR0aCwgaGVpZ2h0IH0gPSBsYXlvdXQ7XG4gICAgY29uc3QgeyBib3JkZXJCb3R0b21Db2xvciwgYm9yZGVyQm90dG9tU3R5bGUsIGJvcmRlckJvdHRvbVdpZHRoLCBib3JkZXJSaWdodFdpZHRoLCBib3JkZXJMZWZ0V2lkdGgsIH0gPSBzdHlsZTtcbiAgICBjb25zdCBjMCA9IHJibCAqICgxLjAgLSBLQVBQQSk7XG4gICAgY29uc3QgYzEgPSByYnIgKiAoMS4wIC0gS0FQUEEpO1xuICAgIGN0eC5tb3ZlVG8obGVmdCArIHdpZHRoLCB0b3AgKyBoZWlnaHQgLSByYnIpO1xuICAgIGN0eC5iZXppZXJDdXJ2ZVRvKGxlZnQgKyB3aWR0aCwgdG9wICsgaGVpZ2h0IC0gYzEsIGxlZnQgKyB3aWR0aCAtIGMxLCB0b3AgKyBoZWlnaHQsIGxlZnQgKyB3aWR0aCAtIHJiciwgdG9wICsgaGVpZ2h0KTtcbiAgICBjdHgubGluZVRvKGxlZnQgKyByYmwsIHRvcCArIGhlaWdodCk7XG4gICAgY3R4LmJlemllckN1cnZlVG8obGVmdCArIGMwLCB0b3AgKyBoZWlnaHQsIGxlZnQsIHRvcCArIGhlaWdodCAtIGMwLCBsZWZ0LCB0b3AgKyBoZWlnaHQgLSByYmwpO1xuICAgIGN0eC5zdHJva2VDb2xvcihib3JkZXJCb3R0b21Db2xvcik7XG4gICAgY3R4LmxpbmVXaWR0aChNYXRoLm1heChib3JkZXJCb3R0b21XaWR0aCwgYm9yZGVyUmlnaHRXaWR0aCwgYm9yZGVyTGVmdFdpZHRoKSAqIDIpO1xuICAgIGlmIChib3JkZXJCb3R0b21TdHlsZSA9PT0gJ2Rhc2hlZCcpIHtcbiAgICAgICAgY3R4LmRhc2goYm9yZGVyQm90dG9tV2lkdGggKiAyLCB7IHNwYWNlOiBib3JkZXJCb3R0b21XaWR0aCAqIDEuMiB9KTtcbiAgICB9XG4gICAgZWxzZSBpZiAoYm9yZGVyQm90dG9tU3R5bGUgPT09ICdkb3R0ZWQnKSB7XG4gICAgICAgIGN0eC5kYXNoKGJvcmRlckJvdHRvbVdpZHRoLCB7IHNwYWNlOiBib3JkZXJCb3R0b21XaWR0aCAqIDEuMiB9KTtcbiAgICB9XG4gICAgY3R4LnN0cm9rZSgpO1xuICAgIGN0eC51bmRhc2goKTtcbn07XG5jb25zdCBjbGlwQm9yZGVyTGVmdCA9IChjdHgsIGxheW91dCwgc3R5bGUsIHJibCwgcnRsKSA9PiB7XG4gICAgY29uc3QgeyB0b3AsIGxlZnQsIHdpZHRoLCBoZWlnaHQgfSA9IGxheW91dDtcbiAgICBjb25zdCB7IGJvcmRlclRvcFdpZHRoLCBib3JkZXJMZWZ0V2lkdGgsIGJvcmRlckJvdHRvbVdpZHRoIH0gPSBzdHlsZTtcbiAgICAvLyBDbGlwIG91dGVyIGxlZnQgYm9yZGVyIGVkZ2VcbiAgICBjdHgubW92ZVRvKGxlZnQsIHRvcCArIGhlaWdodCAtIHJibCk7XG4gICAgY3R4LmxpbmVUbyhsZWZ0LCB0b3AgKyBydGwpO1xuICAgIC8vIEVsbGlwc2UgY29lZmZpY2llbnRzIG91dGVyIHRvcCBsZWZ0IGNhcFxuICAgIGNvbnN0IGMwID0gcnRsICogKDEuMCAtIEtBUFBBKTtcbiAgICAvLyBDbGlwIG91dGVyIHRvcCBsZWZ0IGNhcFxuICAgIGN0eC5iZXppZXJDdXJ2ZVRvKGxlZnQsIHRvcCArIGMwLCBsZWZ0ICsgYzAsIHRvcCwgbGVmdCArIHJ0bCwgdG9wKTtcbiAgICAvLyBNb3ZlIHJpZ2h0IGluIGNhc2UgdGhlIG1hcmdpbiBleGNlZWRlcyB0aGUgcmFkaXVzXG4gICAgY29uc3QgdG9wTGVmdENvb3JkWCA9IGxlZnQgKyBNYXRoLm1heChib3JkZXJMZWZ0V2lkdGgsIHJ0bCk7XG4gICAgY3R4LmxpbmVUbyh0b3BMZWZ0Q29vcmRYLCB0b3ApO1xuICAgIC8vIENsaXAgaW5uZXIgdG9wIGxlZnQgY2FwXG4gICAgY3R4LmxpbmVUbyh0b3BMZWZ0Q29vcmRYLCB0b3AgKyBib3JkZXJUb3BXaWR0aCk7XG4gICAgLy8gRWxsaXBzZSBjb2VmZmljaWVudHMgaW5uZXIgdG9wIGxlZnQgY2FwXG4gICAgY29uc3QgaW5uZXJUb3BMZWZ0UmFkaXVzWCA9IE1hdGgubWF4KHJ0bCAtIGJvcmRlckxlZnRXaWR0aCwgMCk7XG4gICAgY29uc3QgaW5uZXJUb3BMZWZ0UmFkaXVzWSA9IE1hdGgubWF4KHJ0bCAtIGJvcmRlclRvcFdpZHRoLCAwKTtcbiAgICBjb25zdCBjMSA9IGlubmVyVG9wTGVmdFJhZGl1c1ggKiAoMS4wIC0gS0FQUEEpO1xuICAgIGNvbnN0IGMyID0gaW5uZXJUb3BMZWZ0UmFkaXVzWSAqICgxLjAgLSBLQVBQQSk7XG4gICAgLy8gQ2xpcCBpbm5lciB0b3AgcmlnaHQgY2FwXG4gICAgY3R4LmJlemllckN1cnZlVG8obGVmdCArIGJvcmRlckxlZnRXaWR0aCArIGMxLCB0b3AgKyBib3JkZXJUb3BXaWR0aCwgbGVmdCArIGJvcmRlckxlZnRXaWR0aCwgdG9wICsgYm9yZGVyVG9wV2lkdGggKyBjMiwgbGVmdCArIGJvcmRlckxlZnRXaWR0aCwgdG9wICsgTWF0aC5tYXgocnRsLCBib3JkZXJUb3BXaWR0aCkpO1xuICAgIC8vIENsaXAgaW5uZXIgbGVmdCBib3JkZXIgZWRnZVxuICAgIGN0eC5saW5lVG8obGVmdCArIGJvcmRlckxlZnRXaWR0aCwgdG9wICsgaGVpZ2h0IC0gTWF0aC5tYXgocmJsLCBib3JkZXJCb3R0b21XaWR0aCkpO1xuICAgIC8vIEVsbGlwc2UgY29lZmZpY2llbnRzIGlubmVyIGJvdHRvbSBsZWZ0IGNhcFxuICAgIGNvbnN0IGlubmVyQm90dG9tTGVmdFJhZGl1c1ggPSBNYXRoLm1heChyYmwgLSBib3JkZXJMZWZ0V2lkdGgsIDApO1xuICAgIGNvbnN0IGlubmVyQm90dG9tTGVmdFJhZGl1c1kgPSBNYXRoLm1heChyYmwgLSBib3JkZXJCb3R0b21XaWR0aCwgMCk7XG4gICAgY29uc3QgYzMgPSBpbm5lckJvdHRvbUxlZnRSYWRpdXNYICogKDEuMCAtIEtBUFBBKTtcbiAgICBjb25zdCBjNCA9IGlubmVyQm90dG9tTGVmdFJhZGl1c1kgKiAoMS4wIC0gS0FQUEEpO1xuICAgIGNvbnN0IGJvdHRvbUxlZnRYQ29vcmQgPSBsZWZ0ICsgTWF0aC5tYXgocmJsLCBib3JkZXJMZWZ0V2lkdGgpO1xuICAgIC8vIENsaXAgaW5uZXIgdG9wIGxlZnQgY2FwXG4gICAgY3R4LmJlemllckN1cnZlVG8obGVmdCArIGJvcmRlckxlZnRXaWR0aCwgdG9wICsgaGVpZ2h0IC0gYm9yZGVyQm90dG9tV2lkdGggLSBjNCwgbGVmdCArIGJvcmRlckxlZnRXaWR0aCArIGMzLCB0b3AgKyBoZWlnaHQgLSBib3JkZXJCb3R0b21XaWR0aCwgYm90dG9tTGVmdFhDb29yZCwgdG9wICsgaGVpZ2h0IC0gYm9yZGVyQm90dG9tV2lkdGgpO1xuICAgIGN0eC5saW5lVG8oYm90dG9tTGVmdFhDb29yZCwgdG9wICsgaGVpZ2h0KTtcbiAgICAvLyBNb3ZlIGxlZnQgaW4gY2FzZSB0aGUgbWFyZ2luIGV4Y2VlZGVzIHRoZSByYWRpdXNcbiAgICBjdHgubGluZVRvKGxlZnQgKyByYmwsIHRvcCArIGhlaWdodCk7XG4gICAgLy8gRWxsaXBzZSBjb2VmZmljaWVudHMgb3V0ZXIgdG9wIHJpZ2h0IGNhcFxuICAgIGNvbnN0IGM1ID0gcmJsICogKDEuMCAtIEtBUFBBKTtcbiAgICAvLyBDbGlwIG91dGVyIHRvcCByaWdodCBjYXBcbiAgICBjdHguYmV6aWVyQ3VydmVUbyhsZWZ0ICsgYzUsIHRvcCArIGhlaWdodCwgbGVmdCwgdG9wICsgaGVpZ2h0IC0gYzUsIGxlZnQsIHRvcCArIGhlaWdodCAtIHJibCk7XG4gICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgIGN0eC5jbGlwKCk7XG4gICAgLy8gQ2xpcCBib3JkZXIgcmlnaHQgY2FwIGpvaW5zXG4gICAgaWYgKGJvcmRlckJvdHRvbVdpZHRoKSB7XG4gICAgICAgIGNvbnN0IHRyU2xvcGUgPSAtYm9yZGVyQm90dG9tV2lkdGggLyBib3JkZXJMZWZ0V2lkdGg7XG4gICAgICAgIGN0eC5tb3ZlVG8obGVmdCArIHdpZHRoIC8gMiwgdHJTbG9wZSAqICh3aWR0aCAvIDIpICsgdG9wICsgaGVpZ2h0KTtcbiAgICAgICAgY3R4LmxpbmVUbyhsZWZ0LCB0b3AgKyBoZWlnaHQpO1xuICAgICAgICBjdHgubGluZVRvKGxlZnQsIHRvcCk7XG4gICAgICAgIGN0eC5saW5lVG8obGVmdCArIHdpZHRoLCB0b3ApO1xuICAgICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICAgIGN0eC5jbGlwKCk7XG4gICAgfVxuICAgIGlmIChib3JkZXJCb3R0b21XaWR0aCkge1xuICAgICAgICBjb25zdCB0clNsb3BlID0gLWJvcmRlclRvcFdpZHRoIC8gYm9yZGVyTGVmdFdpZHRoO1xuICAgICAgICBjdHgubW92ZVRvKGxlZnQgKyB3aWR0aCAvIDIsIHRyU2xvcGUgKiAoLXdpZHRoIC8gMikgKyB0b3ApO1xuICAgICAgICBjdHgubGluZVRvKGxlZnQsIHRvcCk7XG4gICAgICAgIGN0eC5saW5lVG8obGVmdCwgdG9wICsgaGVpZ2h0KTtcbiAgICAgICAgY3R4LmxpbmVUbyhsZWZ0ICsgd2lkdGgsIHRvcCArIGhlaWdodCk7XG4gICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgICAgY3R4LmNsaXAoKTtcbiAgICB9XG59O1xuY29uc3QgZmlsbEJvcmRlckxlZnQgPSAoY3R4LCBsYXlvdXQsIHN0eWxlLCByYmwsIHJ0bCkgPT4ge1xuICAgIGNvbnN0IHsgdG9wLCBsZWZ0LCBoZWlnaHQgfSA9IGxheW91dDtcbiAgICBjb25zdCB7IGJvcmRlckxlZnRDb2xvciwgYm9yZGVyTGVmdFN0eWxlLCBib3JkZXJMZWZ0V2lkdGgsIGJvcmRlclRvcFdpZHRoLCBib3JkZXJCb3R0b21XaWR0aCwgfSA9IHN0eWxlO1xuICAgIGNvbnN0IGMwID0gcmJsICogKDEuMCAtIEtBUFBBKTtcbiAgICBjb25zdCBjMSA9IHJ0bCAqICgxLjAgLSBLQVBQQSk7XG4gICAgY3R4Lm1vdmVUbyhsZWZ0ICsgcmJsLCB0b3AgKyBoZWlnaHQpO1xuICAgIGN0eC5iZXppZXJDdXJ2ZVRvKGxlZnQgKyBjMCwgdG9wICsgaGVpZ2h0LCBsZWZ0LCB0b3AgKyBoZWlnaHQgLSBjMCwgbGVmdCwgdG9wICsgaGVpZ2h0IC0gcmJsKTtcbiAgICBjdHgubGluZVRvKGxlZnQsIHRvcCArIHJ0bCk7XG4gICAgY3R4LmJlemllckN1cnZlVG8obGVmdCwgdG9wICsgYzEsIGxlZnQgKyBjMSwgdG9wLCBsZWZ0ICsgcnRsLCB0b3ApO1xuICAgIGN0eC5zdHJva2VDb2xvcihib3JkZXJMZWZ0Q29sb3IpO1xuICAgIGN0eC5saW5lV2lkdGgoTWF0aC5tYXgoYm9yZGVyTGVmdFdpZHRoLCBib3JkZXJUb3BXaWR0aCwgYm9yZGVyQm90dG9tV2lkdGgpICogMik7XG4gICAgaWYgKGJvcmRlckxlZnRTdHlsZSA9PT0gJ2Rhc2hlZCcpIHtcbiAgICAgICAgY3R4LmRhc2goYm9yZGVyTGVmdFdpZHRoICogMiwgeyBzcGFjZTogYm9yZGVyTGVmdFdpZHRoICogMS4yIH0pO1xuICAgIH1cbiAgICBlbHNlIGlmIChib3JkZXJMZWZ0U3R5bGUgPT09ICdkb3R0ZWQnKSB7XG4gICAgICAgIGN0eC5kYXNoKGJvcmRlckxlZnRXaWR0aCwgeyBzcGFjZTogYm9yZGVyTGVmdFdpZHRoICogMS4yIH0pO1xuICAgIH1cbiAgICBjdHguc3Ryb2tlKCk7XG4gICAgY3R4LnVuZGFzaCgpO1xufTtcbmNvbnN0IHNob3VsZFJlbmRlckJvcmRlcnMgPSAobm9kZSkgPT4gbm9kZS5ib3ggJiZcbiAgICAobm9kZS5ib3guYm9yZGVyVG9wV2lkdGggfHxcbiAgICAgICAgbm9kZS5ib3guYm9yZGVyUmlnaHRXaWR0aCB8fFxuICAgICAgICBub2RlLmJveC5ib3JkZXJCb3R0b21XaWR0aCB8fFxuICAgICAgICBub2RlLmJveC5ib3JkZXJMZWZ0V2lkdGgpO1xuY29uc3QgcmVuZGVyQm9yZGVycyA9IChjdHgsIG5vZGUpID0+IHtcbiAgICBpZiAoIW5vZGUuYm94KVxuICAgICAgICByZXR1cm47XG4gICAgaWYgKCFzaG91bGRSZW5kZXJCb3JkZXJzKG5vZGUpKVxuICAgICAgICByZXR1cm47XG4gICAgY29uc3QgeyB3aWR0aCwgaGVpZ2h0LCBib3JkZXJUb3BXaWR0aCA9IDAsIGJvcmRlckxlZnRXaWR0aCA9IDAsIGJvcmRlclJpZ2h0V2lkdGggPSAwLCBib3JkZXJCb3R0b21XaWR0aCA9IDAsIH0gPSBub2RlLmJveDtcbiAgICBjb25zdCB7IG9wYWNpdHkgPSAxLCBib3JkZXJUb3BDb2xvciA9ICdibGFjaycsIGJvcmRlclRvcFN0eWxlID0gJ3NvbGlkJywgYm9yZGVyTGVmdENvbG9yID0gJ2JsYWNrJywgYm9yZGVyTGVmdFN0eWxlID0gJ3NvbGlkJywgYm9yZGVyUmlnaHRDb2xvciA9ICdibGFjaycsIGJvcmRlclJpZ2h0U3R5bGUgPSAnc29saWQnLCBib3JkZXJCb3R0b21Db2xvciA9ICdibGFjaycsIGJvcmRlckJvdHRvbVN0eWxlID0gJ3NvbGlkJywgfSA9IG5vZGUuc3R5bGU7XG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvciB0aGlzIGlzIGFsd2F5cyBhIG51bWJlciBkdWUgdG8gcmVzb2x2ZSBib3JkZXIgcmFkaXVzIHN0ZXBcbiAgICBjb25zdCBib3JkZXJUb3BMZWZ0UmFkaXVzID0gbm9kZS5zdHlsZS5ib3JkZXJUb3BMZWZ0UmFkaXVzIHx8IDA7XG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvciB0aGlzIGlzIGFsd2F5cyBhIG51bWJlciBkdWUgdG8gcmVzb2x2ZSBib3JkZXIgcmFkaXVzIHN0ZXBcbiAgICBjb25zdCBib3JkZXJUb3BSaWdodFJhZGl1cyA9IG5vZGUuc3R5bGUuYm9yZGVyVG9wUmlnaHRSYWRpdXMgfHwgMDtcbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yIHRoaXMgaXMgYWx3YXlzIGEgbnVtYmVyIGR1ZSB0byByZXNvbHZlIGJvcmRlciByYWRpdXMgc3RlcFxuICAgIGNvbnN0IGJvcmRlckJvdHRvbUxlZnRSYWRpdXMgPSBub2RlLnN0eWxlLmJvcmRlckJvdHRvbUxlZnRSYWRpdXMgfHwgMDtcbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yIHRoaXMgaXMgYWx3YXlzIGEgbnVtYmVyIGR1ZSB0byByZXNvbHZlIGJvcmRlciByYWRpdXMgc3RlcFxuICAgIGNvbnN0IGJvcmRlckJvdHRvbVJpZ2h0UmFkaXVzID0gbm9kZS5zdHlsZS5ib3JkZXJCb3R0b21SaWdodFJhZGl1cyB8fCAwO1xuICAgIGNvbnN0IHN0eWxlID0ge1xuICAgICAgICBib3JkZXJUb3BDb2xvcixcbiAgICAgICAgYm9yZGVyVG9wV2lkdGgsXG4gICAgICAgIGJvcmRlclRvcFN0eWxlLFxuICAgICAgICBib3JkZXJMZWZ0Q29sb3IsXG4gICAgICAgIGJvcmRlckxlZnRXaWR0aCxcbiAgICAgICAgYm9yZGVyTGVmdFN0eWxlLFxuICAgICAgICBib3JkZXJSaWdodENvbG9yLFxuICAgICAgICBib3JkZXJSaWdodFdpZHRoLFxuICAgICAgICBib3JkZXJSaWdodFN0eWxlLFxuICAgICAgICBib3JkZXJCb3R0b21Db2xvcixcbiAgICAgICAgYm9yZGVyQm90dG9tV2lkdGgsXG4gICAgICAgIGJvcmRlckJvdHRvbVN0eWxlfTtcbiAgICBjb25zdCBydHIgPSBNYXRoLm1pbihib3JkZXJUb3BSaWdodFJhZGl1cywgMC41ICogd2lkdGgsIDAuNSAqIGhlaWdodCk7XG4gICAgY29uc3QgcnRsID0gTWF0aC5taW4oYm9yZGVyVG9wTGVmdFJhZGl1cywgMC41ICogd2lkdGgsIDAuNSAqIGhlaWdodCk7XG4gICAgY29uc3QgcmJyID0gTWF0aC5taW4oYm9yZGVyQm90dG9tUmlnaHRSYWRpdXMsIDAuNSAqIHdpZHRoLCAwLjUgKiBoZWlnaHQpO1xuICAgIGNvbnN0IHJibCA9IE1hdGgubWluKGJvcmRlckJvdHRvbUxlZnRSYWRpdXMsIDAuNSAqIHdpZHRoLCAwLjUgKiBoZWlnaHQpO1xuICAgIGN0eC5zYXZlKCk7XG4gICAgY3R4LnN0cm9rZU9wYWNpdHkob3BhY2l0eSk7XG4gICAgaWYgKGJvcmRlclRvcFdpZHRoKSB7XG4gICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgIGNsaXBCb3JkZXJUb3AoY3R4LCBub2RlLmJveCwgc3R5bGUsIHJ0ciwgcnRsKTtcbiAgICAgICAgZmlsbEJvcmRlclRvcChjdHgsIG5vZGUuYm94LCBzdHlsZSwgcnRyLCBydGwpO1xuICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgIH1cbiAgICBpZiAoYm9yZGVyUmlnaHRXaWR0aCkge1xuICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICBjbGlwQm9yZGVyUmlnaHQoY3R4LCBub2RlLmJveCwgc3R5bGUsIHJ0ciwgcmJyKTtcbiAgICAgICAgZmlsbEJvcmRlclJpZ2h0KGN0eCwgbm9kZS5ib3gsIHN0eWxlLCBydHIsIHJicik7XG4gICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgfVxuICAgIGlmIChib3JkZXJCb3R0b21XaWR0aCkge1xuICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICBjbGlwQm9yZGVyQm90dG9tKGN0eCwgbm9kZS5ib3gsIHN0eWxlLCByYmwsIHJicik7XG4gICAgICAgIGZpbGxCb3JkZXJCb3R0b20oY3R4LCBub2RlLmJveCwgc3R5bGUsIHJibCwgcmJyKTtcbiAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICB9XG4gICAgaWYgKGJvcmRlckxlZnRXaWR0aCkge1xuICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICBjbGlwQm9yZGVyTGVmdChjdHgsIG5vZGUuYm94LCBzdHlsZSwgcmJsLCBydGwpO1xuICAgICAgICBmaWxsQm9yZGVyTGVmdChjdHgsIG5vZGUuYm94LCBzdHlsZSwgcmJsLCBydGwpO1xuICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgIH1cbiAgICBjdHgucmVzdG9yZSgpO1xufTtcblxuY29uc3QgZHJhd0JhY2tncm91bmQgPSAoY3R4LCBub2RlKSA9PiB7XG4gICAgaWYgKCFub2RlLmJveClcbiAgICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHsgdG9wLCBsZWZ0LCB3aWR0aCwgaGVpZ2h0IH0gPSBub2RlLmJveDtcbiAgICBjb25zdCBjb2xvciA9IHBhcnNlQ29sb3Iobm9kZS5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IpO1xuICAgIGNvbnN0IG5vZGVPcGFjaXR5ID0gaXNOaWwobm9kZS5zdHlsZT8ub3BhY2l0eSkgPyAxIDogbm9kZS5zdHlsZS5vcGFjaXR5O1xuICAgIGNvbnN0IG9wYWNpdHkgPSBNYXRoLm1pbihjb2xvci5vcGFjaXR5LCBub2RlT3BhY2l0eSk7XG4gICAgY3R4XG4gICAgICAgIC5maWxsT3BhY2l0eShvcGFjaXR5KVxuICAgICAgICAuZmlsbENvbG9yKGNvbG9yLnZhbHVlKVxuICAgICAgICAucmVjdChsZWZ0LCB0b3AsIHdpZHRoLCBoZWlnaHQpXG4gICAgICAgIC5maWxsKCk7XG59O1xuY29uc3QgcmVuZGVyQmFja2dyb3VuZCA9IChjdHgsIG5vZGUpID0+IHtcbiAgICBjb25zdCBoYXNCYWNrZ3JvdW5kID0gISFub2RlLmJveCAmJiAhIW5vZGUuc3R5bGU/LmJhY2tncm91bmRDb2xvcjtcbiAgICBpZiAoaGFzQmFja2dyb3VuZCkge1xuICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICBjbGlwTm9kZShjdHgsIG5vZGUpO1xuICAgICAgICBkcmF3QmFja2dyb3VuZChjdHgsIG5vZGUpO1xuICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgIH1cbn07XG5cbmNvbnN0IGlzU3RyaW5nID0gKHZhbHVlKSA9PiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnO1xuY29uc3QgaXNTcmNJZCA9ICh2YWx1ZSkgPT4gL14jLisvLnRlc3QodmFsdWUpO1xuY29uc3QgcmVuZGVyTGluayA9IChjdHgsIG5vZGUsIHNyYykgPT4ge1xuICAgIGlmICghc3JjIHx8ICFub2RlLmJveClcbiAgICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IGlzSWQgPSBpc1NyY0lkKHNyYyk7XG4gICAgY29uc3QgbWV0aG9kID0gaXNJZCA/ICdnb1RvJyA6ICdsaW5rJztcbiAgICBjb25zdCB2YWx1ZSA9IGlzSWQgPyBzcmMuc2xpY2UoMSkgOiBzcmM7XG4gICAgY29uc3QgeyB0b3AsIGxlZnQsIHdpZHRoLCBoZWlnaHQgfSA9IG5vZGUuYm94O1xuICAgIGN0eFttZXRob2RdKGxlZnQsIHRvcCwgd2lkdGgsIGhlaWdodCwgdmFsdWUpO1xufTtcbmNvbnN0IHNldExpbmsgPSAoY3R4LCBub2RlKSA9PiB7XG4gICAgY29uc3QgcHJvcHMgPSBub2RlLnByb3BzIHx8IHt9O1xuICAgIGlmICgnc3JjJyBpbiBwcm9wcyAmJiBpc1N0cmluZyhwcm9wcy5zcmMpKVxuICAgICAgICByZXR1cm4gcmVuZGVyTGluayhjdHgsIG5vZGUsIHByb3BzLnNyYyk7XG4gICAgaWYgKCdocmVmJyBpbiBwcm9wcyAmJiBpc1N0cmluZyhwcm9wcy5ocmVmKSlcbiAgICAgICAgcmV0dXJuIHJlbmRlckxpbmsoY3R4LCBub2RlLCBwcm9wcy5ocmVmKTtcbn07XG5cbmNvbnN0IHNldERlc3RpbmF0aW9uID0gKGN0eCwgbm9kZSkgPT4ge1xuICAgIGlmICghbm9kZS5ib3gpXG4gICAgICAgIHJldHVybjtcbiAgICBpZiAoIW5vZGUucHJvcHMpXG4gICAgICAgIHJldHVybjtcbiAgICBpZiAoJ2lkJyBpbiBub2RlLnByb3BzKSB7XG4gICAgICAgIGN0eC5hZGROYW1lZERlc3RpbmF0aW9uKG5vZGUucHJvcHMuaWQsICdYWVonLCBudWxsLCBub2RlLmJveC50b3AsIG51bGwpO1xuICAgIH1cbn07XG5cbmNvbnN0IGNsZWFuID0gKG9wdGlvbnMpID0+IHtcbiAgICBjb25zdCBvcHQgPSB7IC4uLm9wdGlvbnMgfTtcbiAgICAvLyBXZSBuZWVkIHRvIGVuc3VyZSB0aGUgZWxlbWVudHMgYXJlIG5vIHByZXNlbnQgaWYgbm90IHRydWVcbiAgICBPYmplY3QuZW50cmllcyhvcHQpLmZvckVhY2goKHBhaXIpID0+IHtcbiAgICAgICAgaWYgKCFwYWlyWzFdKSB7XG4gICAgICAgICAgICBkZWxldGUgb3B0W3BhaXJbMF1dO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIG9wdDtcbn07XG5jb25zdCBwYXJzZUNvbW1vbkZvcm1PcHRpb25zID0gKG5vZGUpID0+IHtcbiAgICAvLyBDb21tb24gT3B0aW9uc1xuICAgIHJldHVybiB7XG4gICAgICAgIHJlcXVpcmVkOiBub2RlLnByb3BzPy5yZXF1aXJlZCB8fCBmYWxzZSxcbiAgICAgICAgbm9FeHBvcnQ6IG5vZGUucHJvcHM/Lm5vRXhwb3J0IHx8IGZhbHNlLFxuICAgICAgICByZWFkT25seTogbm9kZS5wcm9wcz8ucmVhZE9ubHkgfHwgZmFsc2UsXG4gICAgICAgIHZhbHVlOiBub2RlLnByb3BzPy52YWx1ZSB8fCB1bmRlZmluZWQsXG4gICAgICAgIGRlZmF1bHRWYWx1ZTogbm9kZS5wcm9wcz8uZGVmYXVsdFZhbHVlIHx8IHVuZGVmaW5lZCxcbiAgICB9O1xufTtcbmNvbnN0IHBhcnNlVGV4dElucHV0T3B0aW9ucyA9IChub2RlLCBmaWVsZFNldCkgPT4ge1xuICAgIHJldHVybiBjbGVhbih7XG4gICAgICAgIC4uLnBhcnNlQ29tbW9uRm9ybU9wdGlvbnMobm9kZSksXG4gICAgICAgIHBhcmVudDogZmllbGRTZXQgfHwgdW5kZWZpbmVkLFxuICAgICAgICBhbGlnbjogbm9kZS5wcm9wcz8uYWxpZ24gfHwgJ2xlZnQnLFxuICAgICAgICBtdWx0aWxpbmU6IG5vZGUucHJvcHM/Lm11bHRpbGluZSB8fCB1bmRlZmluZWQsXG4gICAgICAgIHBhc3N3b3JkOiBub2RlLnByb3BzPy5wYXNzd29yZCB8fCBmYWxzZSxcbiAgICAgICAgbm9TcGVsbDogbm9kZS5wcm9wcz8ubm9TcGVsbCB8fCBmYWxzZSxcbiAgICAgICAgZm9ybWF0OiBub2RlLnByb3BzPy5mb3JtYXQgfHwgdW5kZWZpbmVkLFxuICAgICAgICBmb250U2l6ZTogbm9kZS5wcm9wcz8uZm9udFNpemUgfHwgdW5kZWZpbmVkLFxuICAgICAgICBNYXhMZW46IG5vZGUucHJvcHM/Lm1heExlbmd0aCB8fCB1bmRlZmluZWQsXG4gICAgfSk7XG59O1xuY29uc3QgcGFyc2VTZWxlY3RBbmRMaXN0RmllbGRPcHRpb25zID0gKG5vZGUpID0+IHtcbiAgICByZXR1cm4gY2xlYW4oe1xuICAgICAgICAuLi5wYXJzZUNvbW1vbkZvcm1PcHRpb25zKG5vZGUpLFxuICAgICAgICBzb3J0OiBub2RlLnByb3BzPy5zb3J0IHx8IGZhbHNlLFxuICAgICAgICBlZGl0OiBub2RlLnByb3BzPy5lZGl0IHx8IGZhbHNlLFxuICAgICAgICBtdWx0aVNlbGVjdDogbm9kZS5wcm9wcz8ubXVsdGlTZWxlY3QgfHwgZmFsc2UsXG4gICAgICAgIG5vU3BlbGw6IG5vZGUucHJvcHM/Lm5vU3BlbGwgfHwgZmFsc2UsXG4gICAgICAgIHNlbGVjdDogbm9kZS5wcm9wcz8uc2VsZWN0IHx8IFsnJ10sXG4gICAgfSk7XG59O1xuY29uc3QgZ2V0QXBwZWFyYW5jZSA9IChjdHgsIGNvZGVwb2ludCwgd2lkdGgsIGhlaWdodCkgPT4ge1xuICAgIGNvbnN0IGFwcGVhcmFuY2UgPSBjdHgucmVmKHtcbiAgICAgICAgVHlwZTogJ1hPYmplY3QnLFxuICAgICAgICBTdWJ0eXBlOiAnRm9ybScsXG4gICAgICAgIEJCb3g6IFswLCAwLCB3aWR0aCwgaGVpZ2h0XSxcbiAgICAgICAgUmVzb3VyY2VzOiB7XG4gICAgICAgICAgICBQcm9jU2V0OiBbJ1BERicsICdUZXh0JywgJ0ltYWdlQicsICdJbWFnZUMnLCAnSW1hZ2VJJ10sXG4gICAgICAgICAgICBGb250OiB7XG4gICAgICAgICAgICAgICAgWmFEaTogY3R4Ll9hY3JvZm9ybS5mb250cy5aYURpLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICB9KTtcbiAgICBhcHBlYXJhbmNlLmluaXREZWZsYXRlKCk7XG4gICAgYXBwZWFyYW5jZS53cml0ZShgL1R4IEJNQ1xcbnFcXG4vWmFEaSAke2hlaWdodCAqIDAuOH0gVGZcXG5CVFxcbiR7d2lkdGggKiAwLjQ1fSAke2hlaWdodCAvIDR9IFRkICgke2NvZGVwb2ludH0pIFRqXFxuRVRcXG5RXFxuRU1DYCk7XG4gICAgYXBwZWFyYW5jZS5lbmQobnVsbCk7XG4gICAgcmV0dXJuIGFwcGVhcmFuY2U7XG59O1xuY29uc3QgcGFyc2VDaGVja2JveE9wdGlvbnMgPSAoY3R4LCBub2RlLCBmaWVsZFNldCkgPT4ge1xuICAgIGNvbnN0IHsgd2lkdGgsIGhlaWdodCB9ID0gbm9kZS5ib3ggfHwge307XG4gICAgY29uc3Qgb25PcHRpb24gPSBub2RlLnByb3BzPy5vblN0YXRlIHx8ICdZZXMnO1xuICAgIGNvbnN0IG9mZk9wdGlvbiA9IG5vZGUucHJvcHM/Lm9mZlN0YXRlIHx8ICdPZmYnO1xuICAgIGNvbnN0IHhNYXJrID0gbm9kZS5wcm9wcz8ueE1hcmsgfHwgZmFsc2U7XG4gICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoY3R4Ll9hY3JvZm9ybS5mb250cywgJ1phRGknKSkge1xuICAgICAgICBjb25zdCByZWYgPSBjdHgucmVmKHtcbiAgICAgICAgICAgIFR5cGU6ICdGb250JyxcbiAgICAgICAgICAgIFN1YnR5cGU6ICdUeXBlMScsXG4gICAgICAgICAgICBCYXNlRm9udDogJ1phcGZEaW5nYmF0cycsXG4gICAgICAgIH0pO1xuICAgICAgICBjdHguX2Fjcm9mb3JtLmZvbnRzLlphRGkgPSByZWY7XG4gICAgICAgIHJlZi5lbmQobnVsbCk7XG4gICAgfVxuICAgIGNvbnN0IG5vcm1hbEFwcGVhcmFuY2UgPSB7XG4gICAgICAgIFtvbk9wdGlvbl06IGdldEFwcGVhcmFuY2UoY3R4LCB4TWFyayA/ICc4JyA6ICc0Jywgd2lkdGgsIGhlaWdodCksXG4gICAgICAgIFtvZmZPcHRpb25dOiBnZXRBcHBlYXJhbmNlKGN0eCwgeE1hcmsgPyAnICcgOiAnOCcsIHdpZHRoLCBoZWlnaHQpLFxuICAgIH07XG4gICAgcmV0dXJuIGNsZWFuKHtcbiAgICAgICAgLi4ucGFyc2VDb21tb25Gb3JtT3B0aW9ucyhub2RlKSxcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiBub2RlLnByb3BzPy5iYWNrZ3JvdW5kQ29sb3IgfHwgdW5kZWZpbmVkLFxuICAgICAgICBib3JkZXJDb2xvcjogbm9kZS5wcm9wcz8uYm9yZGVyQ29sb3IgfHwgdW5kZWZpbmVkLFxuICAgICAgICBwYXJlbnQ6IGZpZWxkU2V0IHx8IHVuZGVmaW5lZCxcbiAgICAgICAgdmFsdWU6IGAvJHtub2RlLnByb3BzPy5jaGVja2VkID09PSB0cnVlID8gb25PcHRpb24gOiBvZmZPcHRpb259YCxcbiAgICAgICAgZGVmYXVsdFZhbHVlOiBgLyR7bm9kZS5wcm9wcz8uY2hlY2tlZCA9PT0gdHJ1ZSA/IG9uT3B0aW9uIDogb2ZmT3B0aW9ufWAsXG4gICAgICAgIEFTOiBub2RlLnByb3BzPy5jaGVja2VkID09PSB0cnVlID8gb25PcHRpb24gOiBvZmZPcHRpb24sXG4gICAgICAgIEFQOiB7IE46IG5vcm1hbEFwcGVhcmFuY2UsIEQ6IG5vcm1hbEFwcGVhcmFuY2UgfSxcbiAgICB9KTtcbn07XG5cbmNvbnN0IHJlbmRlclRleHRJbnB1dCA9IChjdHgsIG5vZGUsIG9wdGlvbnMpID0+IHtcbiAgICBpZiAoIW5vZGUuYm94KVxuICAgICAgICByZXR1cm47XG4gICAgY29uc3QgeyB0b3AsIGxlZnQsIHdpZHRoLCBoZWlnaHQgfSA9IG5vZGUuYm94O1xuICAgIC8vIEVsZW1lbnQncyBuYW1lXG4gICAgY29uc3QgbmFtZSA9IG5vZGUucHJvcHM/Lm5hbWUgfHwgJyc7XG4gICAgY29uc3QgZmllbGRTZXRPcHRpb25zID0gb3B0aW9ucy5maWVsZFNldHM/LmF0KDApO1xuICAgIGlmICghY3R4Ll9yb290LmRhdGEuQWNyb0Zvcm0pIHtcbiAgICAgICAgY3R4LmluaXRGb3JtKCk7XG4gICAgfVxuICAgIGN0eC5mb3JtVGV4dChuYW1lLCBsZWZ0LCB0b3AsIHdpZHRoLCBoZWlnaHQsIHBhcnNlVGV4dElucHV0T3B0aW9ucyhub2RlLCBmaWVsZFNldE9wdGlvbnMpKTtcbn07XG5cbmNvbnN0IHJlbmRlclNlbGVjdCA9IChjdHgsIG5vZGUpID0+IHtcbiAgICBpZiAoIW5vZGUuYm94KVxuICAgICAgICByZXR1cm47XG4gICAgY29uc3QgeyB0b3AsIGxlZnQsIHdpZHRoLCBoZWlnaHQgfSA9IG5vZGUuYm94O1xuICAgIC8vIEVsZW1lbnQncyBuYW1lXG4gICAgY29uc3QgbmFtZSA9IG5vZGUucHJvcHM/Lm5hbWUgfHwgJyc7XG4gICAgaWYgKCFjdHguX3Jvb3QuZGF0YS5BY3JvRm9ybSkge1xuICAgICAgICBjdHguaW5pdEZvcm0oKTtcbiAgICB9XG4gICAgY3R4LmZvcm1Db21ibyhuYW1lLCBsZWZ0LCB0b3AsIHdpZHRoLCBoZWlnaHQsIHBhcnNlU2VsZWN0QW5kTGlzdEZpZWxkT3B0aW9ucyhub2RlKSk7XG59O1xuXG5jb25zdCByZW5kZXJGaWVsZFNldCA9IChjdHgsIG5vZGUsIG9wdGlvbnMpID0+IHtcbiAgICBjb25zdCBuYW1lID0gbm9kZS5wcm9wcz8ubmFtZSB8fCAnJztcbiAgICBpZiAoIWN0eC5fcm9vdC5kYXRhLkFjcm9Gb3JtKSB7XG4gICAgICAgIGN0eC5pbml0Rm9ybSgpO1xuICAgIH1cbiAgICBjb25zdCBmb3JtRmllbGQgPSBjdHguZm9ybUZpZWxkKG5hbWUpO1xuICAgIGNvbnN0IG9wdGlvbiA9IG9wdGlvbnM7XG4gICAgaWYgKCFvcHRpb24uZmllbGRTZXRzKSB7XG4gICAgICAgIG9wdGlvbi5maWVsZFNldHMgPSBbZm9ybUZpZWxkXTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIG9wdGlvbi5maWVsZFNldHMucHVzaChmb3JtRmllbGQpO1xuICAgIH1cbn07XG5jb25zdCBjbGVhblVwRmllbGRTZXQgPSAoX2N0eCwgX25vZGUsIG9wdGlvbnMpID0+IHtcbiAgICBvcHRpb25zLmZpZWxkU2V0cy5wb3AoKTtcbn07XG5cbmNvbnN0IHJlbmRlckxpc3QgPSAoY3R4LCBub2RlKSA9PiB7XG4gICAgaWYgKCFub2RlLmJveClcbiAgICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHsgdG9wLCBsZWZ0LCB3aWR0aCwgaGVpZ2h0IH0gPSBub2RlLmJveCB8fCB7fTtcbiAgICAvLyBFbGVtZW50J3MgbmFtZVxuICAgIGNvbnN0IG5hbWUgPSAoJ25hbWUnIGluIG5vZGUucHJvcHMgPyBub2RlLnByb3BzLm5hbWUgfHwgJycgOiAnJyk7XG4gICAgaWYgKCFjdHguX3Jvb3QuZGF0YS5BY3JvRm9ybSkge1xuICAgICAgICBjdHguaW5pdEZvcm0oKTtcbiAgICB9XG4gICAgY3R4LmZvcm1MaXN0KG5hbWUsIGxlZnQsIHRvcCwgd2lkdGgsIGhlaWdodCwgcGFyc2VTZWxlY3RBbmRMaXN0RmllbGRPcHRpb25zKG5vZGUpKTtcbn07XG5cbmNvbnN0IHJlbmRlckNoZWNrYm94ID0gKGN0eCwgbm9kZSwgb3B0aW9ucykgPT4ge1xuICAgIGlmICghbm9kZS5ib3gpXG4gICAgICAgIHJldHVybjtcbiAgICBjb25zdCB7IHRvcCwgbGVmdCwgd2lkdGgsIGhlaWdodCB9ID0gbm9kZS5ib3g7XG4gICAgLy8gRWxlbWVudCdzIG5hbWVcbiAgICBjb25zdCBuYW1lID0gbm9kZS5wcm9wcz8ubmFtZSB8fCAnJztcbiAgICBjb25zdCBmaWVsZFNldE9wdGlvbnMgPSBvcHRpb25zLmZpZWxkU2V0cz8uYXQoMCk7XG4gICAgaWYgKCFjdHguX3Jvb3QuZGF0YS5BY3JvRm9ybSkge1xuICAgICAgICBjdHguaW5pdEZvcm0oKTtcbiAgICB9XG4gICAgY3R4LmZvcm1DaGVja2JveChuYW1lLCBsZWZ0LCB0b3AsIHdpZHRoLCBoZWlnaHQsIHBhcnNlQ2hlY2tib3hPcHRpb25zKGN0eCwgbm9kZSwgZmllbGRTZXRPcHRpb25zKSk7XG59O1xuXG5jb25zdCBpc1JlY3Vyc2l2ZU5vZGUgPSAobm9kZSkgPT4gbm9kZS50eXBlICE9PSBQLlRleHQgJiYgbm9kZS50eXBlICE9PSBQLlN2ZztcbmNvbnN0IHJlbmRlckNoaWxkcmVuID0gKGN0eCwgbm9kZSwgb3B0aW9ucykgPT4ge1xuICAgIGN0eC5zYXZlKCk7XG4gICAgaWYgKG5vZGUuYm94KSB7XG4gICAgICAgIGN0eC50cmFuc2xhdGUobm9kZS5ib3gubGVmdCwgbm9kZS5ib3gudG9wKTtcbiAgICB9XG4gICAgY29uc3QgY2hpbGRyZW4gPSBub2RlLmNoaWxkcmVuIHx8IFtdO1xuICAgIGNvbnN0IHJlbmRlckNoaWxkID0gKGNoaWxkKSA9PiByZW5kZXJOb2RlKGN0eCwgY2hpbGQsIG9wdGlvbnMpO1xuICAgIGNoaWxkcmVuLmZvckVhY2gocmVuZGVyQ2hpbGQpO1xuICAgIGN0eC5yZXN0b3JlKCk7XG59O1xuY29uc3QgcmVuZGVyRm5zID0ge1xuICAgIFtQLlRleHRdOiByZW5kZXJUZXh0LFxuICAgIFtQLk5vdGVdOiByZW5kZXJOb3RlLFxuICAgIFtQLkltYWdlXTogcmVuZGVySW1hZ2UsXG4gICAgW1AuRmllbGRTZXRdOiByZW5kZXJGaWVsZFNldCxcbiAgICBbUC5UZXh0SW5wdXRdOiByZW5kZXJUZXh0SW5wdXQsXG4gICAgW1AuU2VsZWN0XTogcmVuZGVyU2VsZWN0LFxuICAgIFtQLkNoZWNrYm94XTogcmVuZGVyQ2hlY2tib3gsXG4gICAgW1AuTGlzdF06IHJlbmRlckxpc3QsXG4gICAgW1AuQ2FudmFzXTogcmVuZGVyQ2FudmFzLFxuICAgIFtQLlN2Z106IHJlbmRlclN2ZyxcbiAgICBbUC5MaW5rXTogc2V0TGluayxcbn07XG5jb25zdCBjbGVhblVwRm5zID0ge1xuICAgIFtQLkZpZWxkU2V0XTogY2xlYW5VcEZpZWxkU2V0LFxufTtcbmNvbnN0IHJlbmRlck5vZGUgPSAoY3R4LCBub2RlLCBvcHRpb25zKSA9PiB7XG4gICAgY29uc3Qgb3ZlcmZsb3dIaWRkZW4gPSBub2RlLnN0eWxlPy5vdmVyZmxvdyA9PT0gJ2hpZGRlbic7XG4gICAgY29uc3Qgc2hvdWxkUmVuZGVyQ2hpbGRyZW4gPSBpc1JlY3Vyc2l2ZU5vZGUobm9kZSk7XG4gICAgaWYgKG5vZGUudHlwZSA9PT0gUC5QYWdlKVxuICAgICAgICByZW5kZXJQYWdlKGN0eCwgbm9kZSk7XG4gICAgY3R4LnNhdmUoKTtcbiAgICBpZiAob3ZlcmZsb3dIaWRkZW4pXG4gICAgICAgIGNsaXBOb2RlKGN0eCwgbm9kZSk7XG4gICAgYXBwbHlUcmFuc2Zvcm1hdGlvbnMoY3R4LCBub2RlKTtcbiAgICByZW5kZXJCYWNrZ3JvdW5kKGN0eCwgbm9kZSk7XG4gICAgcmVuZGVyQm9yZGVycyhjdHgsIG5vZGUpO1xuICAgIGNvbnN0IHJlbmRlckZuID0gcmVuZGVyRm5zW25vZGUudHlwZV07XG4gICAgaWYgKHJlbmRlckZuKVxuICAgICAgICByZW5kZXJGbihjdHgsIG5vZGUsIG9wdGlvbnMpO1xuICAgIGlmIChzaG91bGRSZW5kZXJDaGlsZHJlbilcbiAgICAgICAgcmVuZGVyQ2hpbGRyZW4oY3R4LCBub2RlLCBvcHRpb25zKTtcbiAgICBjb25zdCBjbGVhblVwRm4gPSBjbGVhblVwRm5zW25vZGUudHlwZV07XG4gICAgaWYgKGNsZWFuVXBGbilcbiAgICAgICAgY2xlYW5VcEZuKGN0eCwgbm9kZSwgb3B0aW9ucyk7XG4gICAgc2V0RGVzdGluYXRpb24oY3R4LCBub2RlKTtcbiAgICByZW5kZXJEZWJ1ZyhjdHgsIG5vZGUpO1xuICAgIGN0eC5yZXN0b3JlKCk7XG59O1xuXG5jb25zdCBhZGROb2RlQm9va21hcmsgPSAoY3R4LCBub2RlLCBwYWdlTnVtYmVyLCByZWdpc3RyeSkgPT4ge1xuICAgIGlmICghbm9kZS5ib3gpXG4gICAgICAgIHJldHVybjtcbiAgICBpZiAoIW5vZGUucHJvcHMpXG4gICAgICAgIHJldHVybjtcbiAgICBpZiAoJ2Jvb2ttYXJrJyBpbiBub2RlLnByb3BzICYmIG5vZGUucHJvcHMuYm9va21hcmspIHtcbiAgICAgICAgY29uc3QgYm9va21hcmsgPSBub2RlLnByb3BzLmJvb2ttYXJrO1xuICAgICAgICBjb25zdCB7IHRpdGxlLCBwYXJlbnQsIGV4cGFuZGVkLCB6b29tLCBmaXQgfSA9IGJvb2ttYXJrO1xuICAgICAgICBjb25zdCBvdXRsaW5lID0gcmVnaXN0cnlbcGFyZW50XSB8fCBjdHgub3V0bGluZTtcbiAgICAgICAgY29uc3QgdG9wID0gYm9va21hcmsudG9wIHx8IG5vZGUuYm94LnRvcDtcbiAgICAgICAgY29uc3QgbGVmdCA9IGJvb2ttYXJrLmxlZnQgfHwgbm9kZS5ib3gubGVmdDtcbiAgICAgICAgY29uc3QgaW5zdGFuY2UgPSBvdXRsaW5lLmFkZEl0ZW0odGl0bGUsIHtcbiAgICAgICAgICAgIHBhZ2VOdW1iZXIsXG4gICAgICAgICAgICBleHBhbmRlZCxcbiAgICAgICAgICAgIHRvcCxcbiAgICAgICAgICAgIGxlZnQsXG4gICAgICAgICAgICB6b29tLFxuICAgICAgICAgICAgZml0LFxuICAgICAgICB9KTtcbiAgICAgICAgcmVnaXN0cnlbYm9va21hcmsucmVmXSA9IGluc3RhbmNlO1xuICAgIH1cbiAgICBpZiAoIW5vZGUuY2hpbGRyZW4pXG4gICAgICAgIHJldHVybjtcbiAgICBub2RlLmNoaWxkcmVuLmZvckVhY2goKGNoaWxkKSA9PiBhZGROb2RlQm9va21hcmsoY3R4LCBjaGlsZCwgcGFnZU51bWJlciwgcmVnaXN0cnkpKTtcbn07XG5jb25zdCBhZGRCb29rbWFya3MgPSAoY3R4LCByb290KSA9PiB7XG4gICAgY29uc3QgcmVnaXN0cnkgPSB7fTtcbiAgICBjb25zdCBwYWdlcyA9IHJvb3QuY2hpbGRyZW4gfHwgW107XG4gICAgcGFnZXMuZm9yRWFjaCgocGFnZSwgaSkgPT4ge1xuICAgICAgICBhZGROb2RlQm9va21hcmsoY3R4LCBwYWdlLCBpLCByZWdpc3RyeSk7XG4gICAgfSk7XG59O1xuXG5jb25zdCByZW5kZXIgPSAoY3R4LCBkb2MpID0+IHtcbiAgICBjb25zdCBwYWdlcyA9IGRvYy5jaGlsZHJlbiB8fCBbXTtcbiAgICBjb25zdCBvcHRpb25zID0geyBpbWFnZUNhY2hlOiBuZXcgTWFwKCksIGZpZWxkU2V0czogW10gfTtcbiAgICBwYWdlcy5mb3JFYWNoKChwYWdlKSA9PiByZW5kZXJOb2RlKGN0eCwgcGFnZSwgb3B0aW9ucykpO1xuICAgIGFkZEJvb2ttYXJrcyhjdHgsIGRvYyk7XG4gICAgY3R4LmVuZCgpO1xuICAgIHJldHVybiBjdHg7XG59O1xuXG5leHBvcnQgeyByZW5kZXIgYXMgZGVmYXVsdCB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@react-pdf+render@4.3.0/node_modules/@react-pdf/render/lib/index.js\n");

/***/ })

};
;