"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@react-pdf+image@3.0.3";
exports.ids = ["vendor-chunks/@react-pdf+image@3.0.3"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/@react-pdf+image@3.0.3/node_modules/@react-pdf/image/lib/index.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/.pnpm/@react-pdf+image@3.0.3/node_modules/@react-pdf/image/lib/index.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ resolveImage)\n/* harmony export */ });\n/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! fs */ \"fs\");\n/* harmony import */ var url__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! url */ \"url\");\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! path */ \"path\");\n/* harmony import */ var _react_pdf_png_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @react-pdf/png-js */ \"(ssr)/./node_modules/.pnpm/@react-pdf+png-js@3.0.0/node_modules/@react-pdf/png-js/lib/png-js.js\");\n/* harmony import */ var jay_peg__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! jay-peg */ \"(ssr)/./node_modules/.pnpm/jay-peg@1.1.1/node_modules/jay-peg/src/index.js\");\n\n\n\n\n\n\nclass PNG {\n    data;\n    width;\n    height;\n    format;\n    constructor(data) {\n        const png = new _react_pdf_png_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"](data);\n        this.data = data;\n        this.width = png.width;\n        this.height = png.height;\n        this.format = 'png';\n    }\n    static isValid(data) {\n        try {\n            return !!new PNG(data);\n        }\n        catch {\n            return false;\n        }\n    }\n}\n\nclass JPEG {\n    data;\n    width;\n    height;\n    format;\n    constructor(data) {\n        this.data = data;\n        this.format = 'jpeg';\n        this.width = 0;\n        this.height = 0;\n        if (data.readUInt16BE(0) !== 0xffd8) {\n            throw new Error('SOI not found in JPEG');\n        }\n        const markers = jay_peg__WEBPACK_IMPORTED_MODULE_4__[\"default\"].decode(this.data);\n        let orientation;\n        for (let i = 0; i < markers.length; i += 1) {\n            const marker = markers[i];\n            if (marker.name === 'EXIF' && marker.entries.orientation) {\n                orientation = marker.entries.orientation;\n            }\n            if (marker.name === 'SOF') {\n                this.width ||= marker.width;\n                this.height ||= marker.height;\n            }\n        }\n        if (orientation > 4) {\n            [this.width, this.height] = [this.height, this.width];\n        }\n    }\n    static isValid(data) {\n        return data && Buffer.isBuffer(data) && data.readUInt16BE(0) === 0xffd8;\n    }\n}\n\nconst createCache = ({ limit = 100 } = {}) => {\n    let cache = {};\n    let keys = [];\n    return {\n        get: (key) => (key ? cache[key] : null),\n        set: (key, value) => {\n            keys.push(key);\n            if (keys.length > limit) {\n                delete cache[keys.shift()];\n            }\n            cache[key] = value;\n        },\n        reset: () => {\n            cache = {};\n            keys = [];\n        },\n        length: () => keys.length,\n    };\n};\n\nconst IMAGE_CACHE = createCache({ limit: 30 });\nconst isBuffer = Buffer.isBuffer;\nconst isBlob = (src) => {\n    return typeof Blob !== 'undefined' && src instanceof Blob;\n};\nconst isDataImageSrc = (src) => {\n    return 'data' in src;\n};\nconst isBase64Src = (imageSrc) => 'uri' in imageSrc &&\n    /^data:image\\/[a-zA-Z]*;base64,[^\"]*/g.test(imageSrc.uri);\nconst getAbsoluteLocalPath = (src) => {\n    const { protocol, auth, host, port, hostname, path: pathname, } = url__WEBPACK_IMPORTED_MODULE_1__.parse(src);\n    const absolutePath = pathname ? path__WEBPACK_IMPORTED_MODULE_2__.resolve(pathname) : undefined;\n    if ((protocol && protocol !== 'file:') || auth || host || port || hostname) {\n        return undefined;\n    }\n    return absolutePath;\n};\nconst fetchLocalFile = (src) => new Promise((resolve, reject) => {\n    try {\n        if (false) {}\n        const absolutePath = getAbsoluteLocalPath(src.uri);\n        if (!absolutePath) {\n            reject(new Error(`Cannot fetch non-local path: ${src}`));\n            return;\n        }\n        fs__WEBPACK_IMPORTED_MODULE_0__.readFile(absolutePath, (err, data) => err ? reject(err) : resolve(data));\n    }\n    catch (err) {\n        reject(err);\n    }\n});\nconst fetchRemoteFile = async (src) => {\n    const { method = 'GET', headers, body, credentials } = src;\n    const response = await fetch(src.uri, {\n        method,\n        headers,\n        body,\n        credentials,\n    });\n    const buffer = await response.arrayBuffer();\n    return Buffer.from(buffer);\n};\nconst isValidFormat = (format) => {\n    const lower = format.toLowerCase();\n    return lower === 'jpg' || lower === 'jpeg' || lower === 'png';\n};\nconst guessFormat = (buffer) => {\n    let format;\n    if (JPEG.isValid(buffer)) {\n        format = 'jpg';\n    }\n    else if (PNG.isValid(buffer)) {\n        format = 'png';\n    }\n    return format;\n};\nfunction getImage(body, format) {\n    switch (format.toLowerCase()) {\n        case 'jpg':\n        case 'jpeg':\n            return new JPEG(body);\n        case 'png':\n            return new PNG(body);\n        default:\n            return null;\n    }\n}\nconst resolveBase64Image = async ({ uri }) => {\n    const match = /^data:image\\/([a-zA-Z]*);base64,([^\"]*)/g.exec(uri);\n    if (!match)\n        throw new Error(`Invalid base64 image: ${uri}`);\n    const format = match[1];\n    const data = match[2];\n    if (!isValidFormat(format))\n        throw new Error(`Base64 image invalid format: ${format}`);\n    return getImage(Buffer.from(data, 'base64'), format);\n};\nconst resolveImageFromData = async (src) => {\n    if (src.data && src.format) {\n        return getImage(src.data, src.format);\n    }\n    throw new Error(`Invalid data given for local file: ${JSON.stringify(src)}`);\n};\nconst resolveBufferImage = async (buffer) => {\n    const format = guessFormat(buffer);\n    if (format) {\n        return getImage(buffer, format);\n    }\n    return null;\n};\nconst resolveBlobImage = async (blob) => {\n    const { type } = blob;\n    if (!type || type === 'application/octet-stream') {\n        const arrayBuffer = await blob.arrayBuffer();\n        const buffer = Buffer.from(arrayBuffer);\n        return resolveBufferImage(buffer);\n    }\n    if (!type.startsWith('image/')) {\n        throw new Error(`Invalid blob type: ${type}`);\n    }\n    const format = type.replace('image/', '');\n    if (!isValidFormat(format)) {\n        throw new Error(`Invalid blob type: ${type}`);\n    }\n    const buffer = await blob.arrayBuffer();\n    return getImage(Buffer.from(buffer), format);\n};\nconst getImageFormat = (body) => {\n    const isPng = body[0] === 137 &&\n        body[1] === 80 &&\n        body[2] === 78 &&\n        body[3] === 71 &&\n        body[4] === 13 &&\n        body[5] === 10 &&\n        body[6] === 26 &&\n        body[7] === 10;\n    const isJpg = body[0] === 255 && body[1] === 216 && body[2] === 255;\n    let extension = '';\n    if (isPng) {\n        extension = 'png';\n    }\n    else if (isJpg) {\n        extension = 'jpg';\n    }\n    else {\n        throw new Error('Not valid image extension');\n    }\n    return extension;\n};\nconst resolveImageFromUrl = async (src) => {\n    const data = getAbsoluteLocalPath(src.uri)\n        ? await fetchLocalFile(src)\n        : await fetchRemoteFile(src);\n    const format = getImageFormat(data);\n    return getImage(data, format);\n};\nconst getCacheKey = (src) => {\n    if (isBlob(src) || isBuffer(src))\n        return null;\n    if (isDataImageSrc(src))\n        return src.data.toString();\n    return src.uri;\n};\nconst resolveImage = (src, { cache = true } = {}) => {\n    let image;\n    const cacheKey = getCacheKey(src);\n    if (isBlob(src)) {\n        image = resolveBlobImage(src);\n    }\n    else if (isBuffer(src)) {\n        image = resolveBufferImage(src);\n    }\n    else if (cache && IMAGE_CACHE.get(cacheKey)) {\n        return IMAGE_CACHE.get(cacheKey);\n    }\n    else if (isBase64Src(src)) {\n        image = resolveBase64Image(src);\n    }\n    else if (isDataImageSrc(src)) {\n        image = resolveImageFromData(src);\n    }\n    else {\n        image = resolveImageFromUrl(src);\n    }\n    if (!image) {\n        throw new Error('Cannot resolve image');\n    }\n    if (cache && cacheKey) {\n        IMAGE_CACHE.set(cacheKey, image);\n    }\n    return image;\n};\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQHJlYWN0LXBkZitpbWFnZUAzLjAuMy9ub2RlX21vZHVsZXMvQHJlYWN0LXBkZi9pbWFnZS9saWIvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQW9CO0FBQ0U7QUFDRTtBQUNhO0FBQ1Q7O0FBRTVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix5REFBSTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLCtDQUFLO0FBQzdCO0FBQ0Esd0JBQXdCLG9CQUFvQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHVCQUF1QixjQUFjLElBQUk7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQSxrQ0FBa0MsV0FBVztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0EsWUFBWSx3REFBd0QsRUFBRSxzQ0FBUztBQUMvRSxvQ0FBb0MseUNBQVk7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLEtBQUssRUFBRSxFQUFDO0FBQ3BCO0FBQ0E7QUFDQSw2REFBNkQsSUFBSTtBQUNqRTtBQUNBO0FBQ0EsUUFBUSx3Q0FBVztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLFlBQVksNkNBQTZDO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsS0FBSztBQUN6Qyw0Q0FBNEM7QUFDNUM7QUFDQSxpREFBaUQsSUFBSTtBQUNyRDtBQUNBO0FBQ0E7QUFDQSx3REFBd0QsT0FBTztBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQsb0JBQW9CO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsS0FBSztBQUNuRDtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsS0FBSztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixlQUFlLElBQUk7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRW1DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZGlzZWFzZS1wcmVkaWN0aW9uLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzLy5wbnBtL0ByZWFjdC1wZGYraW1hZ2VAMy4wLjMvbm9kZV9tb2R1bGVzL0ByZWFjdC1wZGYvaW1hZ2UvbGliL2luZGV4LmpzPzRhZWQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGZzIGZyb20gJ2ZzJztcbmltcG9ydCB1cmwgZnJvbSAndXJsJztcbmltcG9ydCBwYXRoIGZyb20gJ3BhdGgnO1xuaW1wb3J0IF9QTkcgZnJvbSAnQHJlYWN0LXBkZi9wbmctanMnO1xuaW1wb3J0IF9KUEVHIGZyb20gJ2pheS1wZWcnO1xuXG5jbGFzcyBQTkcge1xuICAgIGRhdGE7XG4gICAgd2lkdGg7XG4gICAgaGVpZ2h0O1xuICAgIGZvcm1hdDtcbiAgICBjb25zdHJ1Y3RvcihkYXRhKSB7XG4gICAgICAgIGNvbnN0IHBuZyA9IG5ldyBfUE5HKGRhdGEpO1xuICAgICAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgICAgICB0aGlzLndpZHRoID0gcG5nLndpZHRoO1xuICAgICAgICB0aGlzLmhlaWdodCA9IHBuZy5oZWlnaHQ7XG4gICAgICAgIHRoaXMuZm9ybWF0ID0gJ3BuZyc7XG4gICAgfVxuICAgIHN0YXRpYyBpc1ZhbGlkKGRhdGEpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiAhIW5ldyBQTkcoZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2gge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5jbGFzcyBKUEVHIHtcbiAgICBkYXRhO1xuICAgIHdpZHRoO1xuICAgIGhlaWdodDtcbiAgICBmb3JtYXQ7XG4gICAgY29uc3RydWN0b3IoZGF0YSkge1xuICAgICAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgICAgICB0aGlzLmZvcm1hdCA9ICdqcGVnJztcbiAgICAgICAgdGhpcy53aWR0aCA9IDA7XG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gMDtcbiAgICAgICAgaWYgKGRhdGEucmVhZFVJbnQxNkJFKDApICE9PSAweGZmZDgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignU09JIG5vdCBmb3VuZCBpbiBKUEVHJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWFya2VycyA9IF9KUEVHLmRlY29kZSh0aGlzLmRhdGEpO1xuICAgICAgICBsZXQgb3JpZW50YXRpb247XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWFya2Vycy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgY29uc3QgbWFya2VyID0gbWFya2Vyc1tpXTtcbiAgICAgICAgICAgIGlmIChtYXJrZXIubmFtZSA9PT0gJ0VYSUYnICYmIG1hcmtlci5lbnRyaWVzLm9yaWVudGF0aW9uKSB7XG4gICAgICAgICAgICAgICAgb3JpZW50YXRpb24gPSBtYXJrZXIuZW50cmllcy5vcmllbnRhdGlvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtYXJrZXIubmFtZSA9PT0gJ1NPRicpIHtcbiAgICAgICAgICAgICAgICB0aGlzLndpZHRoIHx8PSBtYXJrZXIud2lkdGg7XG4gICAgICAgICAgICAgICAgdGhpcy5oZWlnaHQgfHw9IG1hcmtlci5oZWlnaHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9yaWVudGF0aW9uID4gNCkge1xuICAgICAgICAgICAgW3RoaXMud2lkdGgsIHRoaXMuaGVpZ2h0XSA9IFt0aGlzLmhlaWdodCwgdGhpcy53aWR0aF07XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhdGljIGlzVmFsaWQoZGF0YSkge1xuICAgICAgICByZXR1cm4gZGF0YSAmJiBCdWZmZXIuaXNCdWZmZXIoZGF0YSkgJiYgZGF0YS5yZWFkVUludDE2QkUoMCkgPT09IDB4ZmZkODtcbiAgICB9XG59XG5cbmNvbnN0IGNyZWF0ZUNhY2hlID0gKHsgbGltaXQgPSAxMDAgfSA9IHt9KSA9PiB7XG4gICAgbGV0IGNhY2hlID0ge307XG4gICAgbGV0IGtleXMgPSBbXTtcbiAgICByZXR1cm4ge1xuICAgICAgICBnZXQ6IChrZXkpID0+IChrZXkgPyBjYWNoZVtrZXldIDogbnVsbCksXG4gICAgICAgIHNldDogKGtleSwgdmFsdWUpID0+IHtcbiAgICAgICAgICAgIGtleXMucHVzaChrZXkpO1xuICAgICAgICAgICAgaWYgKGtleXMubGVuZ3RoID4gbGltaXQpIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgY2FjaGVba2V5cy5zaGlmdCgpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhY2hlW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgcmVzZXQ6ICgpID0+IHtcbiAgICAgICAgICAgIGNhY2hlID0ge307XG4gICAgICAgICAgICBrZXlzID0gW107XG4gICAgICAgIH0sXG4gICAgICAgIGxlbmd0aDogKCkgPT4ga2V5cy5sZW5ndGgsXG4gICAgfTtcbn07XG5cbmNvbnN0IElNQUdFX0NBQ0hFID0gY3JlYXRlQ2FjaGUoeyBsaW1pdDogMzAgfSk7XG5jb25zdCBpc0J1ZmZlciA9IEJ1ZmZlci5pc0J1ZmZlcjtcbmNvbnN0IGlzQmxvYiA9IChzcmMpID0+IHtcbiAgICByZXR1cm4gdHlwZW9mIEJsb2IgIT09ICd1bmRlZmluZWQnICYmIHNyYyBpbnN0YW5jZW9mIEJsb2I7XG59O1xuY29uc3QgaXNEYXRhSW1hZ2VTcmMgPSAoc3JjKSA9PiB7XG4gICAgcmV0dXJuICdkYXRhJyBpbiBzcmM7XG59O1xuY29uc3QgaXNCYXNlNjRTcmMgPSAoaW1hZ2VTcmMpID0+ICd1cmknIGluIGltYWdlU3JjICYmXG4gICAgL15kYXRhOmltYWdlXFwvW2EtekEtWl0qO2Jhc2U2NCxbXlwiXSovZy50ZXN0KGltYWdlU3JjLnVyaSk7XG5jb25zdCBnZXRBYnNvbHV0ZUxvY2FsUGF0aCA9IChzcmMpID0+IHtcbiAgICBjb25zdCB7IHByb3RvY29sLCBhdXRoLCBob3N0LCBwb3J0LCBob3N0bmFtZSwgcGF0aDogcGF0aG5hbWUsIH0gPSB1cmwucGFyc2Uoc3JjKTtcbiAgICBjb25zdCBhYnNvbHV0ZVBhdGggPSBwYXRobmFtZSA/IHBhdGgucmVzb2x2ZShwYXRobmFtZSkgOiB1bmRlZmluZWQ7XG4gICAgaWYgKChwcm90b2NvbCAmJiBwcm90b2NvbCAhPT0gJ2ZpbGU6JykgfHwgYXV0aCB8fCBob3N0IHx8IHBvcnQgfHwgaG9zdG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgcmV0dXJuIGFic29sdXRlUGF0aDtcbn07XG5jb25zdCBmZXRjaExvY2FsRmlsZSA9IChzcmMpID0+IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICB0cnkge1xuICAgICAgICBpZiAoZmFsc2UpIDtcbiAgICAgICAgY29uc3QgYWJzb2x1dGVQYXRoID0gZ2V0QWJzb2x1dGVMb2NhbFBhdGgoc3JjLnVyaSk7XG4gICAgICAgIGlmICghYWJzb2x1dGVQYXRoKSB7XG4gICAgICAgICAgICByZWplY3QobmV3IEVycm9yKGBDYW5ub3QgZmV0Y2ggbm9uLWxvY2FsIHBhdGg6ICR7c3JjfWApKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBmcy5yZWFkRmlsZShhYnNvbHV0ZVBhdGgsIChlcnIsIGRhdGEpID0+IGVyciA/IHJlamVjdChlcnIpIDogcmVzb2x2ZShkYXRhKSk7XG4gICAgfVxuICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgcmVqZWN0KGVycik7XG4gICAgfVxufSk7XG5jb25zdCBmZXRjaFJlbW90ZUZpbGUgPSBhc3luYyAoc3JjKSA9PiB7XG4gICAgY29uc3QgeyBtZXRob2QgPSAnR0VUJywgaGVhZGVycywgYm9keSwgY3JlZGVudGlhbHMgfSA9IHNyYztcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHNyYy51cmksIHtcbiAgICAgICAgbWV0aG9kLFxuICAgICAgICBoZWFkZXJzLFxuICAgICAgICBib2R5LFxuICAgICAgICBjcmVkZW50aWFscyxcbiAgICB9KTtcbiAgICBjb25zdCBidWZmZXIgPSBhd2FpdCByZXNwb25zZS5hcnJheUJ1ZmZlcigpO1xuICAgIHJldHVybiBCdWZmZXIuZnJvbShidWZmZXIpO1xufTtcbmNvbnN0IGlzVmFsaWRGb3JtYXQgPSAoZm9ybWF0KSA9PiB7XG4gICAgY29uc3QgbG93ZXIgPSBmb3JtYXQudG9Mb3dlckNhc2UoKTtcbiAgICByZXR1cm4gbG93ZXIgPT09ICdqcGcnIHx8IGxvd2VyID09PSAnanBlZycgfHwgbG93ZXIgPT09ICdwbmcnO1xufTtcbmNvbnN0IGd1ZXNzRm9ybWF0ID0gKGJ1ZmZlcikgPT4ge1xuICAgIGxldCBmb3JtYXQ7XG4gICAgaWYgKEpQRUcuaXNWYWxpZChidWZmZXIpKSB7XG4gICAgICAgIGZvcm1hdCA9ICdqcGcnO1xuICAgIH1cbiAgICBlbHNlIGlmIChQTkcuaXNWYWxpZChidWZmZXIpKSB7XG4gICAgICAgIGZvcm1hdCA9ICdwbmcnO1xuICAgIH1cbiAgICByZXR1cm4gZm9ybWF0O1xufTtcbmZ1bmN0aW9uIGdldEltYWdlKGJvZHksIGZvcm1hdCkge1xuICAgIHN3aXRjaCAoZm9ybWF0LnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgY2FzZSAnanBnJzpcbiAgICAgICAgY2FzZSAnanBlZyc6XG4gICAgICAgICAgICByZXR1cm4gbmV3IEpQRUcoYm9keSk7XG4gICAgICAgIGNhc2UgJ3BuZyc6XG4gICAgICAgICAgICByZXR1cm4gbmV3IFBORyhib2R5KTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn1cbmNvbnN0IHJlc29sdmVCYXNlNjRJbWFnZSA9IGFzeW5jICh7IHVyaSB9KSA9PiB7XG4gICAgY29uc3QgbWF0Y2ggPSAvXmRhdGE6aW1hZ2VcXC8oW2EtekEtWl0qKTtiYXNlNjQsKFteXCJdKikvZy5leGVjKHVyaSk7XG4gICAgaWYgKCFtYXRjaClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGJhc2U2NCBpbWFnZTogJHt1cml9YCk7XG4gICAgY29uc3QgZm9ybWF0ID0gbWF0Y2hbMV07XG4gICAgY29uc3QgZGF0YSA9IG1hdGNoWzJdO1xuICAgIGlmICghaXNWYWxpZEZvcm1hdChmb3JtYXQpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEJhc2U2NCBpbWFnZSBpbnZhbGlkIGZvcm1hdDogJHtmb3JtYXR9YCk7XG4gICAgcmV0dXJuIGdldEltYWdlKEJ1ZmZlci5mcm9tKGRhdGEsICdiYXNlNjQnKSwgZm9ybWF0KTtcbn07XG5jb25zdCByZXNvbHZlSW1hZ2VGcm9tRGF0YSA9IGFzeW5jIChzcmMpID0+IHtcbiAgICBpZiAoc3JjLmRhdGEgJiYgc3JjLmZvcm1hdCkge1xuICAgICAgICByZXR1cm4gZ2V0SW1hZ2Uoc3JjLmRhdGEsIHNyYy5mb3JtYXQpO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgZGF0YSBnaXZlbiBmb3IgbG9jYWwgZmlsZTogJHtKU09OLnN0cmluZ2lmeShzcmMpfWApO1xufTtcbmNvbnN0IHJlc29sdmVCdWZmZXJJbWFnZSA9IGFzeW5jIChidWZmZXIpID0+IHtcbiAgICBjb25zdCBmb3JtYXQgPSBndWVzc0Zvcm1hdChidWZmZXIpO1xuICAgIGlmIChmb3JtYXQpIHtcbiAgICAgICAgcmV0dXJuIGdldEltYWdlKGJ1ZmZlciwgZm9ybWF0KTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59O1xuY29uc3QgcmVzb2x2ZUJsb2JJbWFnZSA9IGFzeW5jIChibG9iKSA9PiB7XG4gICAgY29uc3QgeyB0eXBlIH0gPSBibG9iO1xuICAgIGlmICghdHlwZSB8fCB0eXBlID09PSAnYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtJykge1xuICAgICAgICBjb25zdCBhcnJheUJ1ZmZlciA9IGF3YWl0IGJsb2IuYXJyYXlCdWZmZXIoKTtcbiAgICAgICAgY29uc3QgYnVmZmVyID0gQnVmZmVyLmZyb20oYXJyYXlCdWZmZXIpO1xuICAgICAgICByZXR1cm4gcmVzb2x2ZUJ1ZmZlckltYWdlKGJ1ZmZlcik7XG4gICAgfVxuICAgIGlmICghdHlwZS5zdGFydHNXaXRoKCdpbWFnZS8nKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgYmxvYiB0eXBlOiAke3R5cGV9YCk7XG4gICAgfVxuICAgIGNvbnN0IGZvcm1hdCA9IHR5cGUucmVwbGFjZSgnaW1hZ2UvJywgJycpO1xuICAgIGlmICghaXNWYWxpZEZvcm1hdChmb3JtYXQpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBibG9iIHR5cGU6ICR7dHlwZX1gKTtcbiAgICB9XG4gICAgY29uc3QgYnVmZmVyID0gYXdhaXQgYmxvYi5hcnJheUJ1ZmZlcigpO1xuICAgIHJldHVybiBnZXRJbWFnZShCdWZmZXIuZnJvbShidWZmZXIpLCBmb3JtYXQpO1xufTtcbmNvbnN0IGdldEltYWdlRm9ybWF0ID0gKGJvZHkpID0+IHtcbiAgICBjb25zdCBpc1BuZyA9IGJvZHlbMF0gPT09IDEzNyAmJlxuICAgICAgICBib2R5WzFdID09PSA4MCAmJlxuICAgICAgICBib2R5WzJdID09PSA3OCAmJlxuICAgICAgICBib2R5WzNdID09PSA3MSAmJlxuICAgICAgICBib2R5WzRdID09PSAxMyAmJlxuICAgICAgICBib2R5WzVdID09PSAxMCAmJlxuICAgICAgICBib2R5WzZdID09PSAyNiAmJlxuICAgICAgICBib2R5WzddID09PSAxMDtcbiAgICBjb25zdCBpc0pwZyA9IGJvZHlbMF0gPT09IDI1NSAmJiBib2R5WzFdID09PSAyMTYgJiYgYm9keVsyXSA9PT0gMjU1O1xuICAgIGxldCBleHRlbnNpb24gPSAnJztcbiAgICBpZiAoaXNQbmcpIHtcbiAgICAgICAgZXh0ZW5zaW9uID0gJ3BuZyc7XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzSnBnKSB7XG4gICAgICAgIGV4dGVuc2lvbiA9ICdqcGcnO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOb3QgdmFsaWQgaW1hZ2UgZXh0ZW5zaW9uJyk7XG4gICAgfVxuICAgIHJldHVybiBleHRlbnNpb247XG59O1xuY29uc3QgcmVzb2x2ZUltYWdlRnJvbVVybCA9IGFzeW5jIChzcmMpID0+IHtcbiAgICBjb25zdCBkYXRhID0gZ2V0QWJzb2x1dGVMb2NhbFBhdGgoc3JjLnVyaSlcbiAgICAgICAgPyBhd2FpdCBmZXRjaExvY2FsRmlsZShzcmMpXG4gICAgICAgIDogYXdhaXQgZmV0Y2hSZW1vdGVGaWxlKHNyYyk7XG4gICAgY29uc3QgZm9ybWF0ID0gZ2V0SW1hZ2VGb3JtYXQoZGF0YSk7XG4gICAgcmV0dXJuIGdldEltYWdlKGRhdGEsIGZvcm1hdCk7XG59O1xuY29uc3QgZ2V0Q2FjaGVLZXkgPSAoc3JjKSA9PiB7XG4gICAgaWYgKGlzQmxvYihzcmMpIHx8IGlzQnVmZmVyKHNyYykpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIGlmIChpc0RhdGFJbWFnZVNyYyhzcmMpKVxuICAgICAgICByZXR1cm4gc3JjLmRhdGEudG9TdHJpbmcoKTtcbiAgICByZXR1cm4gc3JjLnVyaTtcbn07XG5jb25zdCByZXNvbHZlSW1hZ2UgPSAoc3JjLCB7IGNhY2hlID0gdHJ1ZSB9ID0ge30pID0+IHtcbiAgICBsZXQgaW1hZ2U7XG4gICAgY29uc3QgY2FjaGVLZXkgPSBnZXRDYWNoZUtleShzcmMpO1xuICAgIGlmIChpc0Jsb2Ioc3JjKSkge1xuICAgICAgICBpbWFnZSA9IHJlc29sdmVCbG9iSW1hZ2Uoc3JjKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNCdWZmZXIoc3JjKSkge1xuICAgICAgICBpbWFnZSA9IHJlc29sdmVCdWZmZXJJbWFnZShzcmMpO1xuICAgIH1cbiAgICBlbHNlIGlmIChjYWNoZSAmJiBJTUFHRV9DQUNIRS5nZXQoY2FjaGVLZXkpKSB7XG4gICAgICAgIHJldHVybiBJTUFHRV9DQUNIRS5nZXQoY2FjaGVLZXkpO1xuICAgIH1cbiAgICBlbHNlIGlmIChpc0Jhc2U2NFNyYyhzcmMpKSB7XG4gICAgICAgIGltYWdlID0gcmVzb2x2ZUJhc2U2NEltYWdlKHNyYyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzRGF0YUltYWdlU3JjKHNyYykpIHtcbiAgICAgICAgaW1hZ2UgPSByZXNvbHZlSW1hZ2VGcm9tRGF0YShzcmMpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaW1hZ2UgPSByZXNvbHZlSW1hZ2VGcm9tVXJsKHNyYyk7XG4gICAgfVxuICAgIGlmICghaW1hZ2UpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgcmVzb2x2ZSBpbWFnZScpO1xuICAgIH1cbiAgICBpZiAoY2FjaGUgJiYgY2FjaGVLZXkpIHtcbiAgICAgICAgSU1BR0VfQ0FDSEUuc2V0KGNhY2hlS2V5LCBpbWFnZSk7XG4gICAgfVxuICAgIHJldHVybiBpbWFnZTtcbn07XG5cbmV4cG9ydCB7IHJlc29sdmVJbWFnZSBhcyBkZWZhdWx0IH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@react-pdf+image@3.0.3/node_modules/@react-pdf/image/lib/index.js\n");

/***/ })

};
;