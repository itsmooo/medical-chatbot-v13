"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@react-pdf+stylesheet@6.1.0";
exports.ids = ["vendor-chunks/@react-pdf+stylesheet@6.1.0"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/@react-pdf+stylesheet@6.1.0/node_modules/@react-pdf/stylesheet/lib/index.js":
/*!********************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@react-pdf+stylesheet@6.1.0/node_modules/@react-pdf/stylesheet/lib/index.js ***!
  \********************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ resolveStyles),\n/* harmony export */   flatten: () => (/* binding */ flatten),\n/* harmony export */   transformColor: () => (/* binding */ transformColor)\n/* harmony export */ });\n/* harmony import */ var _react_pdf_fns__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @react-pdf/fns */ \"(ssr)/./node_modules/.pnpm/@react-pdf+fns@3.1.2/node_modules/@react-pdf/fns/lib/index.js\");\n/* harmony import */ var media_engine__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! media-engine */ \"(ssr)/./node_modules/.pnpm/media-engine@1.0.3/node_modules/media-engine/src/index.js\");\n/* harmony import */ var hsl_to_hex__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! hsl-to-hex */ \"(ssr)/./node_modules/.pnpm/hsl-to-hex@1.0.0/node_modules/hsl-to-hex/index.js\");\n/* harmony import */ var color_string__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! color-string */ \"(ssr)/./node_modules/.pnpm/color-string@1.9.1/node_modules/color-string/index.js\");\n/* harmony import */ var postcss_value_parser_lib_parse_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! postcss-value-parser/lib/parse.js */ \"(ssr)/./node_modules/.pnpm/postcss-value-parser@4.2.0/node_modules/postcss-value-parser/lib/parse.js\");\n/* harmony import */ var postcss_value_parser_lib_unit_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! postcss-value-parser/lib/unit.js */ \"(ssr)/./node_modules/.pnpm/postcss-value-parser@4.2.0/node_modules/postcss-value-parser/lib/unit.js\");\n\n\n\n\n\n\n\n/**\n * Remove nil values from array\n *\n * @param array - Style array\n * @returns Style array without nils\n */\nconst compact = (array) => array.filter(Boolean);\n/**\n * Merges style objects array\n *\n * @param styles - Style array\n * @returns Merged style object\n */\nconst mergeStyles = (styles) => styles.reduce((acc, style) => {\n    const s = Array.isArray(style) ? flatten(style) : style;\n    Object.keys(s).forEach((key) => {\n        if (s[key] !== null && s[key] !== undefined) {\n            acc[key] = s[key];\n        }\n    });\n    return acc;\n}, {});\n/**\n * Flattens an array of style objects, into one aggregated style object.\n *\n * @param styles - Style or style array\n * @returns Flattened style object\n */\nconst flatten = (0,_react_pdf_fns__WEBPACK_IMPORTED_MODULE_0__.compose)(mergeStyles, compact, (_react_pdf_fns__WEBPACK_IMPORTED_MODULE_0__.castArray));\n\n/**\n * Resolves media queries in styles object\n *\n * @param container - Container for which styles are resolved\n * @param style - Style description\n * @returns Resolved style object\n */\nconst resolveMediaQueries = (container, style) => {\n    return Object.keys(style).reduce((acc, key) => {\n        if (/@media/.test(key)) {\n            return {\n                ...acc,\n                ...media_engine__WEBPACK_IMPORTED_MODULE_1__({ [key]: style[key] }, container),\n            };\n        }\n        return { ...acc, [key]: style[key] };\n    }, {});\n};\n\nconst isRgb = (value) => /rgba?/g.test(value);\nconst isHsl = (value) => /hsla?/g.test(value);\n/**\n * Transform rgb color to hexa\n *\n * @param value - Styles value\n * @returns Transformed value\n */\nconst parseRgb = (value) => {\n    const rgb = color_string__WEBPACK_IMPORTED_MODULE_3__.get.rgb(value);\n    return color_string__WEBPACK_IMPORTED_MODULE_3__.to.hex(rgb);\n};\n/**\n * Transform Hsl color to hexa\n *\n * @param value - Styles value\n * @returns Transformed value\n */\nconst parseHsl = (value) => {\n    const hsl = color_string__WEBPACK_IMPORTED_MODULE_3__.get.hsl(value).map(Math.round);\n    const hex = hsl_to_hex__WEBPACK_IMPORTED_MODULE_2__(...hsl);\n    return hex.toUpperCase();\n};\n/**\n * Transform given color to hexa\n *\n * @param value - Styles value\n * @returns Transformed value\n */\nconst transformColor = (value) => {\n    if (isRgb(value))\n        return parseRgb(value);\n    if (isHsl(value))\n        return parseHsl(value);\n    return value;\n};\n\n/**\n * Parses scalar value in value and unit pairs\n *\n * @param value - Scalar value\n * @returns Parsed value\n */\nconst parseValue = (value) => {\n    if (typeof value === 'number')\n        return { value, unit: undefined };\n    const match = /^(-?\\d*\\.?\\d+)(in|mm|cm|pt|vh|vw|px|rem)?$/g.exec(value);\n    return match\n        ? { value: parseFloat(match[1]), unit: match[2] || 'pt' }\n        : { value, unit: undefined };\n};\n/**\n * Transform given scalar value\n *\n * @param container\n * @param value - Styles value\n * @returns Transformed value\n */\nconst transformUnit = (container, value) => {\n    const scalar = parseValue(value);\n    const outputDpi = 72;\n    const inputDpi = container.dpi || 72;\n    const mmFactor = (1 / 25.4) * outputDpi;\n    const cmFactor = (1 / 2.54) * outputDpi;\n    if (typeof scalar.value !== 'number')\n        return scalar.value;\n    switch (scalar.unit) {\n        case 'rem':\n            return scalar.value * (container.remBase || 18);\n        case 'in':\n            return scalar.value * outputDpi;\n        case 'mm':\n            return scalar.value * mmFactor;\n        case 'cm':\n            return scalar.value * cmFactor;\n        case 'vh':\n            return scalar.value * (container.height / 100);\n        case 'vw':\n            return scalar.value * (container.width / 100);\n        case 'px':\n            return Math.round(scalar.value * (outputDpi / inputDpi));\n        default:\n            return scalar.value;\n    }\n};\n\nconst processNumberValue = (key, value) => ({\n    [key]: (0,_react_pdf_fns__WEBPACK_IMPORTED_MODULE_0__.parseFloat)(value),\n});\nconst processUnitValue = (key, value, container) => ({\n    [key]: transformUnit(container, value),\n});\nconst processColorValue = (key, value) => {\n    const result = { [key]: transformColor(value) };\n    return result;\n};\nconst processNoopValue = (key, value) => ({\n    [key]: value,\n});\n\nconst BORDER_SHORTHAND_REGEX = /(-?\\d+(\\.\\d+)?(in|mm|cm|pt|vw|vh|px|rem)?)\\s(\\S+)\\s(.+)/;\nconst matchBorderShorthand = (value) => value.match(BORDER_SHORTHAND_REGEX) || [];\nconst resolveBorderShorthand = (key, value, container) => {\n    const match = matchBorderShorthand(`${value}`);\n    if (match) {\n        const widthMatch = match[1] || value;\n        const styleMatch = match[4] || value;\n        const colorMatch = match[5] || value;\n        const style = styleMatch;\n        const color = colorMatch ? transformColor(colorMatch) : undefined;\n        const width = widthMatch ? transformUnit(container, widthMatch) : undefined;\n        if (key.match(/(Top|Right|Bottom|Left)$/)) {\n            return {\n                [`${key}Color`]: color,\n                [`${key}Style`]: style,\n                [`${key}Width`]: width,\n            };\n        }\n        if (key.match(/Color$/)) {\n            return {\n                borderTopColor: color,\n                borderRightColor: color,\n                borderBottomColor: color,\n                borderLeftColor: color,\n            };\n        }\n        if (key.match(/Style$/)) {\n            if (typeof style === 'number')\n                throw new Error(`Invalid border style: ${style}`);\n            return {\n                borderTopStyle: style,\n                borderRightStyle: style,\n                borderBottomStyle: style,\n                borderLeftStyle: style,\n            };\n        }\n        if (key.match(/Width$/)) {\n            if (typeof width !== 'number')\n                throw new Error(`Invalid border width: ${width}`);\n            return {\n                borderTopWidth: width,\n                borderRightWidth: width,\n                borderBottomWidth: width,\n                borderLeftWidth: width,\n            };\n        }\n        if (key.match(/Radius$/)) {\n            const radius = value ? transformUnit(container, value) : undefined;\n            if (typeof radius !== 'number')\n                throw new Error(`Invalid border radius: ${radius}`);\n            return {\n                borderTopLeftRadius: radius,\n                borderTopRightRadius: radius,\n                borderBottomRightRadius: radius,\n                borderBottomLeftRadius: radius,\n            };\n        }\n        if (typeof width !== 'number')\n            throw new Error(`Invalid border width: ${width}`);\n        if (typeof style === 'number')\n            throw new Error(`Invalid border style: ${style}`);\n        return {\n            borderTopColor: color,\n            borderTopStyle: style,\n            borderTopWidth: width,\n            borderRightColor: color,\n            borderRightStyle: style,\n            borderRightWidth: width,\n            borderBottomColor: color,\n            borderBottomStyle: style,\n            borderBottomWidth: width,\n            borderLeftColor: color,\n            borderLeftStyle: style,\n            borderLeftWidth: width,\n        };\n    }\n    return { [key]: value };\n};\nconst handlers$b = {\n    border: (resolveBorderShorthand),\n    borderBottom: (resolveBorderShorthand),\n    borderBottomColor: (processColorValue),\n    borderBottomLeftRadius: (processUnitValue),\n    borderBottomRightRadius: (processUnitValue),\n    borderBottomStyle: (processNoopValue),\n    borderBottomWidth: (processUnitValue),\n    borderColor: (resolveBorderShorthand),\n    borderLeft: (resolveBorderShorthand),\n    borderLeftColor: (processColorValue),\n    borderLeftStyle: (processNoopValue),\n    borderLeftWidth: (processUnitValue),\n    borderRadius: (resolveBorderShorthand),\n    borderRight: (resolveBorderShorthand),\n    borderRightColor: (processColorValue),\n    borderRightStyle: (processNoopValue),\n    borderRightWidth: (processUnitValue),\n    borderStyle: (resolveBorderShorthand),\n    borderTop: (resolveBorderShorthand),\n    borderTopColor: (processColorValue),\n    borderTopLeftRadius: (processUnitValue),\n    borderTopRightRadius: (processUnitValue),\n    borderTopStyle: (processNoopValue),\n    borderTopWidth: (processUnitValue),\n    borderWidth: (resolveBorderShorthand),\n};\n\nconst handlers$a = {\n    backgroundColor: (processColorValue),\n    color: (processColorValue),\n    opacity: (processNumberValue),\n};\n\nconst handlers$9 = {\n    height: (processUnitValue),\n    maxHeight: (processUnitValue),\n    maxWidth: (processUnitValue),\n    minHeight: (processUnitValue),\n    minWidth: (processUnitValue),\n    width: (processUnitValue),\n};\n\n// https://developer.mozilla.org/en-US/docs/Web/CSS/flex#values\n// TODO: change flex defaults to [0, 1, 'auto'] as in spec in next major release\nconst flexDefaults = [1, 1, 0];\nconst flexAuto = [1, 1, 'auto'];\nconst processFlexShorthand = (key, value, container) => {\n    let defaults = flexDefaults;\n    let matches = [];\n    if (value === 'auto') {\n        defaults = flexAuto;\n    }\n    else {\n        matches = `${value}`.split(' ');\n    }\n    const flexGrow = (0,_react_pdf_fns__WEBPACK_IMPORTED_MODULE_0__.parseFloat)(matches[0] || defaults[0]);\n    const flexShrink = (0,_react_pdf_fns__WEBPACK_IMPORTED_MODULE_0__.parseFloat)(matches[1] || defaults[1]);\n    const flexBasis = transformUnit(container, matches[2] || defaults[2]);\n    return { flexGrow, flexShrink, flexBasis };\n};\nconst handlers$8 = {\n    alignContent: (processNoopValue),\n    alignItems: (processNoopValue),\n    alignSelf: (processNoopValue),\n    flex: (processFlexShorthand),\n    flexBasis: (processUnitValue),\n    flexDirection: (processNoopValue),\n    flexFlow: (processNoopValue),\n    flexGrow: (processNumberValue),\n    flexShrink: (processNumberValue),\n    flexWrap: (processNoopValue),\n    justifyContent: (processNoopValue),\n    justifySelf: (processNoopValue),\n};\n\nconst processGapShorthand = (key, value, container) => {\n    const match = `${value}`.split(' ');\n    const rowGap = transformUnit(container, match?.[0] || value);\n    const columnGap = transformUnit(container, match?.[1] || value);\n    return { rowGap, columnGap };\n};\nconst handlers$7 = {\n    gap: (processGapShorthand),\n    columnGap: (processUnitValue),\n    rowGap: (processUnitValue),\n};\n\nconst handlers$6 = {\n    aspectRatio: (processNumberValue),\n    bottom: (processUnitValue),\n    display: (processNoopValue),\n    left: (processUnitValue),\n    position: (processNoopValue),\n    right: (processUnitValue),\n    top: (processUnitValue),\n    overflow: (processNoopValue),\n    zIndex: (processNumberValue),\n};\n\nconst BOX_MODEL_UNITS = 'px,in,mm,cm,pt,%,vw,vh';\nconst logError = (style, value) => {\n    const name = style.toString();\n    // eslint-disable-next-line no-console\n    console.error(`\n    @react-pdf/stylesheet parsing error:\n    ${name}: ${value},\n    ${' '.repeat(name.length + 2)}^\n    Unsupported ${name} value format\n  `);\n};\n/**\n * @param options\n * @param [options.expandsTo]\n * @param [options.maxValues]\n * @param [options.autoSupported]\n */\nconst expandBoxModel = ({ expandsTo, maxValues = 1, autoSupported = false, } = {}) => (model, value, container) => {\n    const nodes = postcss_value_parser_lib_parse_js__WEBPACK_IMPORTED_MODULE_4__(`${value}`);\n    const parts = [];\n    for (let i = 0; i < nodes.length; i++) {\n        const node = nodes[i];\n        // value contains `calc`, `url` or other css function\n        // `,`, `/` or strings that unsupported by margin and padding\n        if (node.type === 'function' ||\n            node.type === 'string' ||\n            node.type === 'div') {\n            logError(model, value);\n            return {};\n        }\n        if (node.type === 'word') {\n            if (node.value === 'auto' && autoSupported) {\n                parts.push(node.value);\n            }\n            else {\n                const result = postcss_value_parser_lib_unit_js__WEBPACK_IMPORTED_MODULE_5__(node.value);\n                // when unit isn't specified this condition is true\n                if (result && BOX_MODEL_UNITS.includes(result.unit)) {\n                    parts.push(node.value);\n                }\n                else {\n                    logError(model, value);\n                    return {};\n                }\n            }\n        }\n    }\n    // checks that we have enough parsed values\n    if (parts.length > maxValues) {\n        logError(model, value);\n        return {};\n    }\n    const first = transformUnit(container, parts[0]);\n    if (expandsTo) {\n        const second = transformUnit(container, parts[1] || parts[0]);\n        const third = transformUnit(container, parts[2] || parts[0]);\n        const fourth = transformUnit(container, parts[3] || parts[1] || parts[0]);\n        return expandsTo({ first, second, third, fourth });\n    }\n    return {\n        [model]: first,\n    };\n};\n\nconst processMargin = expandBoxModel({\n    expandsTo: ({ first, second, third, fourth }) => ({\n        marginTop: first,\n        marginRight: second,\n        marginBottom: third,\n        marginLeft: fourth,\n    }),\n    maxValues: 4,\n    autoSupported: true,\n});\nconst processMarginVertical = expandBoxModel({\n    expandsTo: ({ first, second }) => ({\n        marginTop: first,\n        marginBottom: second,\n    }),\n    maxValues: 2,\n    autoSupported: true,\n});\nconst processMarginHorizontal = expandBoxModel({\n    expandsTo: ({ first, second }) => ({\n        marginRight: first,\n        marginLeft: second,\n    }),\n    maxValues: 2,\n    autoSupported: true,\n});\nconst processMarginSingle = expandBoxModel({\n    autoSupported: true,\n});\nconst handlers$5 = {\n    margin: (processMargin),\n    marginBottom: (processMarginSingle),\n    marginHorizontal: (processMarginHorizontal),\n    marginLeft: (processMarginSingle),\n    marginRight: (processMarginSingle),\n    marginTop: (processMarginSingle),\n    marginVertical: (processMarginVertical),\n};\n\nconst processPadding = expandBoxModel({\n    expandsTo: ({ first, second, third, fourth }) => ({\n        paddingTop: first,\n        paddingRight: second,\n        paddingBottom: third,\n        paddingLeft: fourth,\n    }),\n    maxValues: 4,\n});\nconst processPaddingVertical = expandBoxModel({\n    expandsTo: ({ first, second }) => ({\n        paddingTop: first,\n        paddingBottom: second,\n    }),\n    maxValues: 2,\n});\nconst processPaddingHorizontal = expandBoxModel({\n    expandsTo: ({ first, second }) => ({\n        paddingRight: first,\n        paddingLeft: second,\n    }),\n    maxValues: 2,\n});\nconst processPaddingSingle = expandBoxModel();\nconst handlers$4 = {\n    padding: (processPadding),\n    paddingBottom: (processPaddingSingle),\n    paddingHorizontal: (processPaddingHorizontal),\n    paddingLeft: (processPaddingSingle),\n    paddingRight: (processPaddingSingle),\n    paddingTop: (processPaddingSingle),\n    paddingVertical: (processPaddingVertical),\n};\n\nconst offsetKeyword = (value) => {\n    switch (value) {\n        case 'top':\n        case 'left':\n            return '0%';\n        case 'right':\n        case 'bottom':\n            return '100%';\n        case 'center':\n            return '50%';\n        default:\n            return value;\n    }\n};\n\nconst processObjectPosition = (key, value, container) => {\n    const match = `${value}`.split(' ');\n    const objectPositionX = offsetKeyword(transformUnit(container, match?.[0] || value));\n    const objectPositionY = offsetKeyword(transformUnit(container, match?.[1] || value));\n    return { objectPositionX, objectPositionY };\n};\nconst processObjectPositionValue = (key, value, container) => ({\n    [key]: offsetKeyword(transformUnit(container, value)),\n});\nconst handlers$3 = {\n    objectPosition: (processObjectPosition),\n    objectPositionX: (processObjectPositionValue),\n    objectPositionY: (processObjectPositionValue),\n    objectFit: (processNoopValue),\n};\n\nconst castInt = (value) => {\n    if (typeof value === 'number')\n        return value;\n    return parseInt(value, 10);\n};\n\nconst FONT_WEIGHTS = {\n    thin: 100,\n    hairline: 100,\n    ultralight: 200,\n    extralight: 200,\n    light: 300,\n    normal: 400,\n    medium: 500,\n    semibold: 600,\n    demibold: 600,\n    bold: 700,\n    ultrabold: 800,\n    extrabold: 800,\n    heavy: 900,\n    black: 900,\n};\nconst transformFontWeight = (value) => {\n    if (!value)\n        return FONT_WEIGHTS.normal;\n    if (typeof value === 'number')\n        return value;\n    const lv = value.toLowerCase();\n    if (FONT_WEIGHTS[lv])\n        return FONT_WEIGHTS[lv];\n    return castInt(value);\n};\nconst processFontWeight = (key, value) => {\n    return { [key]: transformFontWeight(value) };\n};\nconst transformLineHeight = (value, styles, container) => {\n    if (value === '')\n        return value;\n    const fontSize = transformUnit(container, styles.fontSize || 18);\n    const lineHeight = transformUnit(container, value);\n    // Percent values: use this number multiplied by the element's font size\n    const { percent } = (0,_react_pdf_fns__WEBPACK_IMPORTED_MODULE_0__.matchPercent)(lineHeight) || {};\n    if (percent)\n        return percent * fontSize;\n    // Unitless values: use this number multiplied by the element's font size\n    return isNaN(value) ? lineHeight : lineHeight * fontSize;\n};\nconst processLineHeight = (key, value, container, styles) => {\n    return {\n        [key]: transformLineHeight(value, styles, container),\n    };\n};\nconst handlers$2 = {\n    direction: (processNoopValue),\n    fontFamily: (processNoopValue),\n    fontSize: (processUnitValue),\n    fontStyle: (processNoopValue),\n    fontWeight: (processFontWeight),\n    letterSpacing: (processUnitValue),\n    lineHeight: (processLineHeight),\n    maxLines: (processNumberValue),\n    textAlign: (processNoopValue),\n    textDecoration: (processNoopValue),\n    textDecorationColor: (processColorValue),\n    textDecorationStyle: (processNoopValue),\n    textIndent: (processNoopValue),\n    textOverflow: (processNoopValue),\n    textTransform: (processNoopValue),\n    verticalAlign: (processNoopValue),\n};\n\nconst matchNumber = (value) => typeof value === 'string' && /^-?\\d*\\.?\\d*$/.test(value);\nconst castFloat = (value) => {\n    if (typeof value !== 'string')\n        return value;\n    if (matchNumber(value))\n        return parseFloat(value);\n    return value;\n};\n\nconst parse = (transformString) => {\n    const transforms = transformString.trim().split(/\\)[ ,]|\\)/);\n    // Handle \"initial\", \"inherit\", \"unset\".\n    if (transforms.length === 1) {\n        return [[transforms[0], true]];\n    }\n    const parsed = [];\n    for (let i = 0; i < transforms.length; i += 1) {\n        const transform = transforms[i];\n        if (transform) {\n            const [name, rawValue] = transform.split('(');\n            const splitChar = rawValue.indexOf(',') >= 0 ? ',' : ' ';\n            const value = rawValue.split(splitChar).map((val) => val.trim());\n            parsed.push({ operation: name.trim(), value });\n        }\n    }\n    return parsed;\n};\nconst parseAngle = (value) => {\n    const unitsRegexp = /(-?\\d*\\.?\\d*)(\\w*)?/i;\n    const [, angle, unit] = unitsRegexp.exec(value);\n    const number = Number.parseFloat(angle);\n    return unit === 'rad' ? (number * 180) / Math.PI : number;\n};\nconst normalizeTransformOperation = ({ operation, value }) => {\n    switch (operation) {\n        case 'scale': {\n            const [scaleX, scaleY = scaleX] = value.map((num) => Number.parseFloat(num));\n            return { operation: 'scale', value: [scaleX, scaleY] };\n        }\n        case 'scaleX': {\n            return { operation: 'scale', value: [Number.parseFloat(value), 1] };\n        }\n        case 'scaleY': {\n            return { operation: 'scale', value: [1, Number.parseFloat(value)] };\n        }\n        case 'rotate': {\n            return { operation: 'rotate', value: [parseAngle(value)] };\n        }\n        case 'translate': {\n            return {\n                operation: 'translate',\n                value: value.map((num) => Number.parseFloat(num)),\n            };\n        }\n        case 'translateX': {\n            return {\n                operation: 'translate',\n                value: [Number.parseFloat(value), 0],\n            };\n        }\n        case 'translateY': {\n            return { operation: 'translate', value: [0, Number.parseFloat(value)] };\n        }\n        case 'skew': {\n            return { operation: 'skew', value: value.map(parseAngle) };\n        }\n        case 'skewX': {\n            return { operation: 'skew', value: [parseAngle(value), 0] };\n        }\n        case 'skewY': {\n            return { operation: 'skew', value: [0, parseAngle(value)] };\n        }\n        default: {\n            return { operation, value: value.map((num) => Number.parseFloat(num)) };\n        }\n    }\n};\nconst normalize = (operations) => {\n    return operations.map((operation) => normalizeTransformOperation(operation));\n};\nconst processTransform = (key, value) => {\n    if (typeof value !== 'string')\n        return { [key]: value };\n    return { [key]: normalize(parse(value)) };\n};\nconst Y_AXIS_SHORTHANDS = { top: true, bottom: true };\nconst sortTransformOriginPair = (a, b) => {\n    if (Y_AXIS_SHORTHANDS[a])\n        return 1;\n    if (Y_AXIS_SHORTHANDS[b])\n        return -1;\n    return 0;\n};\nconst getTransformOriginPair = (values) => {\n    if (!values || values.length === 0)\n        return ['center', 'center'];\n    const pair = values.length === 1 ? [values[0], 'center'] : values;\n    return pair.sort(sortTransformOriginPair);\n};\n// Transforms shorthand transformOrigin values\nconst processTransformOriginShorthand = (key, value, container) => {\n    const match = `${value}`.split(' ');\n    const pair = getTransformOriginPair(match);\n    const transformOriginX = transformUnit(container, pair[0]);\n    const transformOriginY = transformUnit(container, pair[1]);\n    return {\n        transformOriginX: offsetKeyword(transformOriginX) || castFloat(transformOriginX),\n        transformOriginY: offsetKeyword(transformOriginY) || castFloat(transformOriginY),\n    };\n};\nconst processTransformOriginValue = (key, value, container) => {\n    const v = transformUnit(container, value);\n    return { [key]: offsetKeyword(v) || castFloat(v) };\n};\nconst handlers$1 = {\n    transform: processTransform,\n    gradientTransform: processTransform,\n    transformOrigin: (processTransformOriginShorthand),\n    transformOriginX: (processTransformOriginValue),\n    transformOriginY: (processTransformOriginValue),\n};\n\nconst handlers = {\n    fill: (processColorValue),\n    stroke: (processColorValue),\n    strokeDasharray: (processNoopValue),\n    strokeWidth: (processUnitValue),\n    fillOpacity: (processNumberValue),\n    strokeOpacity: (processNumberValue),\n    fillRule: (processNoopValue),\n    textAnchor: (processNoopValue),\n    strokeLinecap: (processNoopValue),\n    strokeLinejoin: (processNoopValue),\n    visibility: (processNoopValue),\n    clipPath: (processNoopValue),\n    dominantBaseline: (processNoopValue),\n};\n\nconst shorthands = {\n    ...handlers$b,\n    ...handlers$a,\n    ...handlers$9,\n    ...handlers$8,\n    ...handlers$7,\n    ...handlers$6,\n    ...handlers$5,\n    ...handlers$4,\n    ...handlers$3,\n    ...handlers$2,\n    ...handlers$1,\n    ...handlers,\n};\n/**\n * Expand the shorthand properties.\n *\n * @param style - Style object\n * @returns Expanded style object\n */\nconst resolve = (container) => (style) => {\n    const propsArray = Object.keys(style);\n    const resolvedStyle = {};\n    for (let i = 0; i < propsArray.length; i += 1) {\n        const key = propsArray[i];\n        const value = style[key];\n        if (!shorthands[key]) {\n            resolvedStyle[key] = value;\n            continue;\n        }\n        const resolved = shorthands[key](key, value, container, style);\n        const keys = Object.keys(resolved);\n        for (let j = 0; j < keys.length; j += 1) {\n            const propName = keys[j];\n            const propValue = resolved[propName];\n            resolvedStyle[propName] = propValue;\n        }\n    }\n    return resolvedStyle;\n};\n\n/**\n * Resolves styles\n *\n * @param container\n * @param style - Style\n * @returns Resolved style\n */\nconst resolveStyles = (container, style) => {\n    const computeMediaQueries = (value) => resolveMediaQueries(container, value);\n    return (0,_react_pdf_fns__WEBPACK_IMPORTED_MODULE_0__.compose)(resolve(container), computeMediaQueries, flatten)(style);\n};\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQHJlYWN0LXBkZitzdHlsZXNoZWV0QDYuMS4wL25vZGVfbW9kdWxlcy9AcmVhY3QtcGRmL3N0eWxlc2hlZXQvbGliL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUE4RjtBQUN4RDtBQUNKO0FBQ0s7QUFDaUI7QUFDQzs7QUFFekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxDQUFDLElBQUk7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsdURBQU8sd0JBQXdCLHFEQUFTOztBQUV4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIseUNBQVUsR0FBRyxtQkFBbUI7QUFDbkQ7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixLQUFLLElBQUk7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsNkNBQWU7QUFDL0IsV0FBVyw0Q0FBYztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDZDQUFlO0FBQy9CLGdCQUFnQix1Q0FBUTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsWUFBWTtBQUNaLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsdUJBQXVCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsaUJBQWlCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsdURBQU87QUFDbEI7O0FBRTZEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZGlzZWFzZS1wcmVkaWN0aW9uLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzLy5wbnBtL0ByZWFjdC1wZGYrc3R5bGVzaGVldEA2LjEuMC9ub2RlX21vZHVsZXMvQHJlYWN0LXBkZi9zdHlsZXNoZWV0L2xpYi9pbmRleC5qcz85ODI2Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGNvbXBvc2UsIGNhc3RBcnJheSwgcGFyc2VGbG9hdCBhcyBwYXJzZUZsb2F0JDEsIG1hdGNoUGVyY2VudCB9IGZyb20gJ0ByZWFjdC1wZGYvZm5zJztcbmltcG9ydCBtYXRjaE1lZGlhIGZyb20gJ21lZGlhLWVuZ2luZSc7XG5pbXBvcnQgaGxzVG9IZXggZnJvbSAnaHNsLXRvLWhleCc7XG5pbXBvcnQgY29sb3JTdHJpbmcgZnJvbSAnY29sb3Itc3RyaW5nJztcbmltcG9ydCBwYXJzZSQxIGZyb20gJ3Bvc3Rjc3MtdmFsdWUtcGFyc2VyL2xpYi9wYXJzZS5qcyc7XG5pbXBvcnQgcGFyc2VVbml0IGZyb20gJ3Bvc3Rjc3MtdmFsdWUtcGFyc2VyL2xpYi91bml0LmpzJztcblxuLyoqXG4gKiBSZW1vdmUgbmlsIHZhbHVlcyBmcm9tIGFycmF5XG4gKlxuICogQHBhcmFtIGFycmF5IC0gU3R5bGUgYXJyYXlcbiAqIEByZXR1cm5zIFN0eWxlIGFycmF5IHdpdGhvdXQgbmlsc1xuICovXG5jb25zdCBjb21wYWN0ID0gKGFycmF5KSA9PiBhcnJheS5maWx0ZXIoQm9vbGVhbik7XG4vKipcbiAqIE1lcmdlcyBzdHlsZSBvYmplY3RzIGFycmF5XG4gKlxuICogQHBhcmFtIHN0eWxlcyAtIFN0eWxlIGFycmF5XG4gKiBAcmV0dXJucyBNZXJnZWQgc3R5bGUgb2JqZWN0XG4gKi9cbmNvbnN0IG1lcmdlU3R5bGVzID0gKHN0eWxlcykgPT4gc3R5bGVzLnJlZHVjZSgoYWNjLCBzdHlsZSkgPT4ge1xuICAgIGNvbnN0IHMgPSBBcnJheS5pc0FycmF5KHN0eWxlKSA/IGZsYXR0ZW4oc3R5bGUpIDogc3R5bGU7XG4gICAgT2JqZWN0LmtleXMocykuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgIGlmIChzW2tleV0gIT09IG51bGwgJiYgc1trZXldICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGFjY1trZXldID0gc1trZXldO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGFjYztcbn0sIHt9KTtcbi8qKlxuICogRmxhdHRlbnMgYW4gYXJyYXkgb2Ygc3R5bGUgb2JqZWN0cywgaW50byBvbmUgYWdncmVnYXRlZCBzdHlsZSBvYmplY3QuXG4gKlxuICogQHBhcmFtIHN0eWxlcyAtIFN0eWxlIG9yIHN0eWxlIGFycmF5XG4gKiBAcmV0dXJucyBGbGF0dGVuZWQgc3R5bGUgb2JqZWN0XG4gKi9cbmNvbnN0IGZsYXR0ZW4gPSBjb21wb3NlKG1lcmdlU3R5bGVzLCBjb21wYWN0LCAoY2FzdEFycmF5KSk7XG5cbi8qKlxuICogUmVzb2x2ZXMgbWVkaWEgcXVlcmllcyBpbiBzdHlsZXMgb2JqZWN0XG4gKlxuICogQHBhcmFtIGNvbnRhaW5lciAtIENvbnRhaW5lciBmb3Igd2hpY2ggc3R5bGVzIGFyZSByZXNvbHZlZFxuICogQHBhcmFtIHN0eWxlIC0gU3R5bGUgZGVzY3JpcHRpb25cbiAqIEByZXR1cm5zIFJlc29sdmVkIHN0eWxlIG9iamVjdFxuICovXG5jb25zdCByZXNvbHZlTWVkaWFRdWVyaWVzID0gKGNvbnRhaW5lciwgc3R5bGUpID0+IHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXMoc3R5bGUpLnJlZHVjZSgoYWNjLCBrZXkpID0+IHtcbiAgICAgICAgaWYgKC9AbWVkaWEvLnRlc3Qoa2V5KSkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAuLi5hY2MsXG4gICAgICAgICAgICAgICAgLi4ubWF0Y2hNZWRpYSh7IFtrZXldOiBzdHlsZVtrZXldIH0sIGNvbnRhaW5lciksXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IC4uLmFjYywgW2tleV06IHN0eWxlW2tleV0gfTtcbiAgICB9LCB7fSk7XG59O1xuXG5jb25zdCBpc1JnYiA9ICh2YWx1ZSkgPT4gL3JnYmE/L2cudGVzdCh2YWx1ZSk7XG5jb25zdCBpc0hzbCA9ICh2YWx1ZSkgPT4gL2hzbGE/L2cudGVzdCh2YWx1ZSk7XG4vKipcbiAqIFRyYW5zZm9ybSByZ2IgY29sb3IgdG8gaGV4YVxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFN0eWxlcyB2YWx1ZVxuICogQHJldHVybnMgVHJhbnNmb3JtZWQgdmFsdWVcbiAqL1xuY29uc3QgcGFyc2VSZ2IgPSAodmFsdWUpID0+IHtcbiAgICBjb25zdCByZ2IgPSBjb2xvclN0cmluZy5nZXQucmdiKHZhbHVlKTtcbiAgICByZXR1cm4gY29sb3JTdHJpbmcudG8uaGV4KHJnYik7XG59O1xuLyoqXG4gKiBUcmFuc2Zvcm0gSHNsIGNvbG9yIHRvIGhleGFcbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBTdHlsZXMgdmFsdWVcbiAqIEByZXR1cm5zIFRyYW5zZm9ybWVkIHZhbHVlXG4gKi9cbmNvbnN0IHBhcnNlSHNsID0gKHZhbHVlKSA9PiB7XG4gICAgY29uc3QgaHNsID0gY29sb3JTdHJpbmcuZ2V0LmhzbCh2YWx1ZSkubWFwKE1hdGgucm91bmQpO1xuICAgIGNvbnN0IGhleCA9IGhsc1RvSGV4KC4uLmhzbCk7XG4gICAgcmV0dXJuIGhleC50b1VwcGVyQ2FzZSgpO1xufTtcbi8qKlxuICogVHJhbnNmb3JtIGdpdmVuIGNvbG9yIHRvIGhleGFcbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBTdHlsZXMgdmFsdWVcbiAqIEByZXR1cm5zIFRyYW5zZm9ybWVkIHZhbHVlXG4gKi9cbmNvbnN0IHRyYW5zZm9ybUNvbG9yID0gKHZhbHVlKSA9PiB7XG4gICAgaWYgKGlzUmdiKHZhbHVlKSlcbiAgICAgICAgcmV0dXJuIHBhcnNlUmdiKHZhbHVlKTtcbiAgICBpZiAoaXNIc2wodmFsdWUpKVxuICAgICAgICByZXR1cm4gcGFyc2VIc2wodmFsdWUpO1xuICAgIHJldHVybiB2YWx1ZTtcbn07XG5cbi8qKlxuICogUGFyc2VzIHNjYWxhciB2YWx1ZSBpbiB2YWx1ZSBhbmQgdW5pdCBwYWlyc1xuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFNjYWxhciB2YWx1ZVxuICogQHJldHVybnMgUGFyc2VkIHZhbHVlXG4gKi9cbmNvbnN0IHBhcnNlVmFsdWUgPSAodmFsdWUpID0+IHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJylcbiAgICAgICAgcmV0dXJuIHsgdmFsdWUsIHVuaXQ6IHVuZGVmaW5lZCB9O1xuICAgIGNvbnN0IG1hdGNoID0gL14oLT9cXGQqXFwuP1xcZCspKGlufG1tfGNtfHB0fHZofHZ3fHB4fHJlbSk/JC9nLmV4ZWModmFsdWUpO1xuICAgIHJldHVybiBtYXRjaFxuICAgICAgICA/IHsgdmFsdWU6IHBhcnNlRmxvYXQobWF0Y2hbMV0pLCB1bml0OiBtYXRjaFsyXSB8fCAncHQnIH1cbiAgICAgICAgOiB7IHZhbHVlLCB1bml0OiB1bmRlZmluZWQgfTtcbn07XG4vKipcbiAqIFRyYW5zZm9ybSBnaXZlbiBzY2FsYXIgdmFsdWVcbiAqXG4gKiBAcGFyYW0gY29udGFpbmVyXG4gKiBAcGFyYW0gdmFsdWUgLSBTdHlsZXMgdmFsdWVcbiAqIEByZXR1cm5zIFRyYW5zZm9ybWVkIHZhbHVlXG4gKi9cbmNvbnN0IHRyYW5zZm9ybVVuaXQgPSAoY29udGFpbmVyLCB2YWx1ZSkgPT4ge1xuICAgIGNvbnN0IHNjYWxhciA9IHBhcnNlVmFsdWUodmFsdWUpO1xuICAgIGNvbnN0IG91dHB1dERwaSA9IDcyO1xuICAgIGNvbnN0IGlucHV0RHBpID0gY29udGFpbmVyLmRwaSB8fCA3MjtcbiAgICBjb25zdCBtbUZhY3RvciA9ICgxIC8gMjUuNCkgKiBvdXRwdXREcGk7XG4gICAgY29uc3QgY21GYWN0b3IgPSAoMSAvIDIuNTQpICogb3V0cHV0RHBpO1xuICAgIGlmICh0eXBlb2Ygc2NhbGFyLnZhbHVlICE9PSAnbnVtYmVyJylcbiAgICAgICAgcmV0dXJuIHNjYWxhci52YWx1ZTtcbiAgICBzd2l0Y2ggKHNjYWxhci51bml0KSB7XG4gICAgICAgIGNhc2UgJ3JlbSc6XG4gICAgICAgICAgICByZXR1cm4gc2NhbGFyLnZhbHVlICogKGNvbnRhaW5lci5yZW1CYXNlIHx8IDE4KTtcbiAgICAgICAgY2FzZSAnaW4nOlxuICAgICAgICAgICAgcmV0dXJuIHNjYWxhci52YWx1ZSAqIG91dHB1dERwaTtcbiAgICAgICAgY2FzZSAnbW0nOlxuICAgICAgICAgICAgcmV0dXJuIHNjYWxhci52YWx1ZSAqIG1tRmFjdG9yO1xuICAgICAgICBjYXNlICdjbSc6XG4gICAgICAgICAgICByZXR1cm4gc2NhbGFyLnZhbHVlICogY21GYWN0b3I7XG4gICAgICAgIGNhc2UgJ3ZoJzpcbiAgICAgICAgICAgIHJldHVybiBzY2FsYXIudmFsdWUgKiAoY29udGFpbmVyLmhlaWdodCAvIDEwMCk7XG4gICAgICAgIGNhc2UgJ3Z3JzpcbiAgICAgICAgICAgIHJldHVybiBzY2FsYXIudmFsdWUgKiAoY29udGFpbmVyLndpZHRoIC8gMTAwKTtcbiAgICAgICAgY2FzZSAncHgnOlxuICAgICAgICAgICAgcmV0dXJuIE1hdGgucm91bmQoc2NhbGFyLnZhbHVlICogKG91dHB1dERwaSAvIGlucHV0RHBpKSk7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gc2NhbGFyLnZhbHVlO1xuICAgIH1cbn07XG5cbmNvbnN0IHByb2Nlc3NOdW1iZXJWYWx1ZSA9IChrZXksIHZhbHVlKSA9PiAoe1xuICAgIFtrZXldOiBwYXJzZUZsb2F0JDEodmFsdWUpLFxufSk7XG5jb25zdCBwcm9jZXNzVW5pdFZhbHVlID0gKGtleSwgdmFsdWUsIGNvbnRhaW5lcikgPT4gKHtcbiAgICBba2V5XTogdHJhbnNmb3JtVW5pdChjb250YWluZXIsIHZhbHVlKSxcbn0pO1xuY29uc3QgcHJvY2Vzc0NvbG9yVmFsdWUgPSAoa2V5LCB2YWx1ZSkgPT4ge1xuICAgIGNvbnN0IHJlc3VsdCA9IHsgW2tleV06IHRyYW5zZm9ybUNvbG9yKHZhbHVlKSB9O1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuY29uc3QgcHJvY2Vzc05vb3BWYWx1ZSA9IChrZXksIHZhbHVlKSA9PiAoe1xuICAgIFtrZXldOiB2YWx1ZSxcbn0pO1xuXG5jb25zdCBCT1JERVJfU0hPUlRIQU5EX1JFR0VYID0gLygtP1xcZCsoXFwuXFxkKyk/KGlufG1tfGNtfHB0fHZ3fHZofHB4fHJlbSk/KVxccyhcXFMrKVxccyguKykvO1xuY29uc3QgbWF0Y2hCb3JkZXJTaG9ydGhhbmQgPSAodmFsdWUpID0+IHZhbHVlLm1hdGNoKEJPUkRFUl9TSE9SVEhBTkRfUkVHRVgpIHx8IFtdO1xuY29uc3QgcmVzb2x2ZUJvcmRlclNob3J0aGFuZCA9IChrZXksIHZhbHVlLCBjb250YWluZXIpID0+IHtcbiAgICBjb25zdCBtYXRjaCA9IG1hdGNoQm9yZGVyU2hvcnRoYW5kKGAke3ZhbHVlfWApO1xuICAgIGlmIChtYXRjaCkge1xuICAgICAgICBjb25zdCB3aWR0aE1hdGNoID0gbWF0Y2hbMV0gfHwgdmFsdWU7XG4gICAgICAgIGNvbnN0IHN0eWxlTWF0Y2ggPSBtYXRjaFs0XSB8fCB2YWx1ZTtcbiAgICAgICAgY29uc3QgY29sb3JNYXRjaCA9IG1hdGNoWzVdIHx8IHZhbHVlO1xuICAgICAgICBjb25zdCBzdHlsZSA9IHN0eWxlTWF0Y2g7XG4gICAgICAgIGNvbnN0IGNvbG9yID0gY29sb3JNYXRjaCA/IHRyYW5zZm9ybUNvbG9yKGNvbG9yTWF0Y2gpIDogdW5kZWZpbmVkO1xuICAgICAgICBjb25zdCB3aWR0aCA9IHdpZHRoTWF0Y2ggPyB0cmFuc2Zvcm1Vbml0KGNvbnRhaW5lciwgd2lkdGhNYXRjaCkgOiB1bmRlZmluZWQ7XG4gICAgICAgIGlmIChrZXkubWF0Y2goLyhUb3B8UmlnaHR8Qm90dG9tfExlZnQpJC8pKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIFtgJHtrZXl9Q29sb3JgXTogY29sb3IsXG4gICAgICAgICAgICAgICAgW2Ake2tleX1TdHlsZWBdOiBzdHlsZSxcbiAgICAgICAgICAgICAgICBbYCR7a2V5fVdpZHRoYF06IHdpZHRoLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoa2V5Lm1hdGNoKC9Db2xvciQvKSkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBib3JkZXJUb3BDb2xvcjogY29sb3IsXG4gICAgICAgICAgICAgICAgYm9yZGVyUmlnaHRDb2xvcjogY29sb3IsXG4gICAgICAgICAgICAgICAgYm9yZGVyQm90dG9tQ29sb3I6IGNvbG9yLFxuICAgICAgICAgICAgICAgIGJvcmRlckxlZnRDb2xvcjogY29sb3IsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChrZXkubWF0Y2goL1N0eWxlJC8pKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHN0eWxlID09PSAnbnVtYmVyJylcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgYm9yZGVyIHN0eWxlOiAke3N0eWxlfWApO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBib3JkZXJUb3BTdHlsZTogc3R5bGUsXG4gICAgICAgICAgICAgICAgYm9yZGVyUmlnaHRTdHlsZTogc3R5bGUsXG4gICAgICAgICAgICAgICAgYm9yZGVyQm90dG9tU3R5bGU6IHN0eWxlLFxuICAgICAgICAgICAgICAgIGJvcmRlckxlZnRTdHlsZTogc3R5bGUsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChrZXkubWF0Y2goL1dpZHRoJC8pKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHdpZHRoICE9PSAnbnVtYmVyJylcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgYm9yZGVyIHdpZHRoOiAke3dpZHRofWApO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBib3JkZXJUb3BXaWR0aDogd2lkdGgsXG4gICAgICAgICAgICAgICAgYm9yZGVyUmlnaHRXaWR0aDogd2lkdGgsXG4gICAgICAgICAgICAgICAgYm9yZGVyQm90dG9tV2lkdGg6IHdpZHRoLFxuICAgICAgICAgICAgICAgIGJvcmRlckxlZnRXaWR0aDogd2lkdGgsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChrZXkubWF0Y2goL1JhZGl1cyQvKSkge1xuICAgICAgICAgICAgY29uc3QgcmFkaXVzID0gdmFsdWUgPyB0cmFuc2Zvcm1Vbml0KGNvbnRhaW5lciwgdmFsdWUpIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiByYWRpdXMgIT09ICdudW1iZXInKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBib3JkZXIgcmFkaXVzOiAke3JhZGl1c31gKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgYm9yZGVyVG9wTGVmdFJhZGl1czogcmFkaXVzLFxuICAgICAgICAgICAgICAgIGJvcmRlclRvcFJpZ2h0UmFkaXVzOiByYWRpdXMsXG4gICAgICAgICAgICAgICAgYm9yZGVyQm90dG9tUmlnaHRSYWRpdXM6IHJhZGl1cyxcbiAgICAgICAgICAgICAgICBib3JkZXJCb3R0b21MZWZ0UmFkaXVzOiByYWRpdXMsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Ygd2lkdGggIT09ICdudW1iZXInKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGJvcmRlciB3aWR0aDogJHt3aWR0aH1gKTtcbiAgICAgICAgaWYgKHR5cGVvZiBzdHlsZSA9PT0gJ251bWJlcicpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgYm9yZGVyIHN0eWxlOiAke3N0eWxlfWApO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYm9yZGVyVG9wQ29sb3I6IGNvbG9yLFxuICAgICAgICAgICAgYm9yZGVyVG9wU3R5bGU6IHN0eWxlLFxuICAgICAgICAgICAgYm9yZGVyVG9wV2lkdGg6IHdpZHRoLFxuICAgICAgICAgICAgYm9yZGVyUmlnaHRDb2xvcjogY29sb3IsXG4gICAgICAgICAgICBib3JkZXJSaWdodFN0eWxlOiBzdHlsZSxcbiAgICAgICAgICAgIGJvcmRlclJpZ2h0V2lkdGg6IHdpZHRoLFxuICAgICAgICAgICAgYm9yZGVyQm90dG9tQ29sb3I6IGNvbG9yLFxuICAgICAgICAgICAgYm9yZGVyQm90dG9tU3R5bGU6IHN0eWxlLFxuICAgICAgICAgICAgYm9yZGVyQm90dG9tV2lkdGg6IHdpZHRoLFxuICAgICAgICAgICAgYm9yZGVyTGVmdENvbG9yOiBjb2xvcixcbiAgICAgICAgICAgIGJvcmRlckxlZnRTdHlsZTogc3R5bGUsXG4gICAgICAgICAgICBib3JkZXJMZWZ0V2lkdGg6IHdpZHRoLFxuICAgICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4geyBba2V5XTogdmFsdWUgfTtcbn07XG5jb25zdCBoYW5kbGVycyRiID0ge1xuICAgIGJvcmRlcjogKHJlc29sdmVCb3JkZXJTaG9ydGhhbmQpLFxuICAgIGJvcmRlckJvdHRvbTogKHJlc29sdmVCb3JkZXJTaG9ydGhhbmQpLFxuICAgIGJvcmRlckJvdHRvbUNvbG9yOiAocHJvY2Vzc0NvbG9yVmFsdWUpLFxuICAgIGJvcmRlckJvdHRvbUxlZnRSYWRpdXM6IChwcm9jZXNzVW5pdFZhbHVlKSxcbiAgICBib3JkZXJCb3R0b21SaWdodFJhZGl1czogKHByb2Nlc3NVbml0VmFsdWUpLFxuICAgIGJvcmRlckJvdHRvbVN0eWxlOiAocHJvY2Vzc05vb3BWYWx1ZSksXG4gICAgYm9yZGVyQm90dG9tV2lkdGg6IChwcm9jZXNzVW5pdFZhbHVlKSxcbiAgICBib3JkZXJDb2xvcjogKHJlc29sdmVCb3JkZXJTaG9ydGhhbmQpLFxuICAgIGJvcmRlckxlZnQ6IChyZXNvbHZlQm9yZGVyU2hvcnRoYW5kKSxcbiAgICBib3JkZXJMZWZ0Q29sb3I6IChwcm9jZXNzQ29sb3JWYWx1ZSksXG4gICAgYm9yZGVyTGVmdFN0eWxlOiAocHJvY2Vzc05vb3BWYWx1ZSksXG4gICAgYm9yZGVyTGVmdFdpZHRoOiAocHJvY2Vzc1VuaXRWYWx1ZSksXG4gICAgYm9yZGVyUmFkaXVzOiAocmVzb2x2ZUJvcmRlclNob3J0aGFuZCksXG4gICAgYm9yZGVyUmlnaHQ6IChyZXNvbHZlQm9yZGVyU2hvcnRoYW5kKSxcbiAgICBib3JkZXJSaWdodENvbG9yOiAocHJvY2Vzc0NvbG9yVmFsdWUpLFxuICAgIGJvcmRlclJpZ2h0U3R5bGU6IChwcm9jZXNzTm9vcFZhbHVlKSxcbiAgICBib3JkZXJSaWdodFdpZHRoOiAocHJvY2Vzc1VuaXRWYWx1ZSksXG4gICAgYm9yZGVyU3R5bGU6IChyZXNvbHZlQm9yZGVyU2hvcnRoYW5kKSxcbiAgICBib3JkZXJUb3A6IChyZXNvbHZlQm9yZGVyU2hvcnRoYW5kKSxcbiAgICBib3JkZXJUb3BDb2xvcjogKHByb2Nlc3NDb2xvclZhbHVlKSxcbiAgICBib3JkZXJUb3BMZWZ0UmFkaXVzOiAocHJvY2Vzc1VuaXRWYWx1ZSksXG4gICAgYm9yZGVyVG9wUmlnaHRSYWRpdXM6IChwcm9jZXNzVW5pdFZhbHVlKSxcbiAgICBib3JkZXJUb3BTdHlsZTogKHByb2Nlc3NOb29wVmFsdWUpLFxuICAgIGJvcmRlclRvcFdpZHRoOiAocHJvY2Vzc1VuaXRWYWx1ZSksXG4gICAgYm9yZGVyV2lkdGg6IChyZXNvbHZlQm9yZGVyU2hvcnRoYW5kKSxcbn07XG5cbmNvbnN0IGhhbmRsZXJzJGEgPSB7XG4gICAgYmFja2dyb3VuZENvbG9yOiAocHJvY2Vzc0NvbG9yVmFsdWUpLFxuICAgIGNvbG9yOiAocHJvY2Vzc0NvbG9yVmFsdWUpLFxuICAgIG9wYWNpdHk6IChwcm9jZXNzTnVtYmVyVmFsdWUpLFxufTtcblxuY29uc3QgaGFuZGxlcnMkOSA9IHtcbiAgICBoZWlnaHQ6IChwcm9jZXNzVW5pdFZhbHVlKSxcbiAgICBtYXhIZWlnaHQ6IChwcm9jZXNzVW5pdFZhbHVlKSxcbiAgICBtYXhXaWR0aDogKHByb2Nlc3NVbml0VmFsdWUpLFxuICAgIG1pbkhlaWdodDogKHByb2Nlc3NVbml0VmFsdWUpLFxuICAgIG1pbldpZHRoOiAocHJvY2Vzc1VuaXRWYWx1ZSksXG4gICAgd2lkdGg6IChwcm9jZXNzVW5pdFZhbHVlKSxcbn07XG5cbi8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0NTUy9mbGV4I3ZhbHVlc1xuLy8gVE9ETzogY2hhbmdlIGZsZXggZGVmYXVsdHMgdG8gWzAsIDEsICdhdXRvJ10gYXMgaW4gc3BlYyBpbiBuZXh0IG1ham9yIHJlbGVhc2VcbmNvbnN0IGZsZXhEZWZhdWx0cyA9IFsxLCAxLCAwXTtcbmNvbnN0IGZsZXhBdXRvID0gWzEsIDEsICdhdXRvJ107XG5jb25zdCBwcm9jZXNzRmxleFNob3J0aGFuZCA9IChrZXksIHZhbHVlLCBjb250YWluZXIpID0+IHtcbiAgICBsZXQgZGVmYXVsdHMgPSBmbGV4RGVmYXVsdHM7XG4gICAgbGV0IG1hdGNoZXMgPSBbXTtcbiAgICBpZiAodmFsdWUgPT09ICdhdXRvJykge1xuICAgICAgICBkZWZhdWx0cyA9IGZsZXhBdXRvO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgbWF0Y2hlcyA9IGAke3ZhbHVlfWAuc3BsaXQoJyAnKTtcbiAgICB9XG4gICAgY29uc3QgZmxleEdyb3cgPSBwYXJzZUZsb2F0JDEobWF0Y2hlc1swXSB8fCBkZWZhdWx0c1swXSk7XG4gICAgY29uc3QgZmxleFNocmluayA9IHBhcnNlRmxvYXQkMShtYXRjaGVzWzFdIHx8IGRlZmF1bHRzWzFdKTtcbiAgICBjb25zdCBmbGV4QmFzaXMgPSB0cmFuc2Zvcm1Vbml0KGNvbnRhaW5lciwgbWF0Y2hlc1syXSB8fCBkZWZhdWx0c1syXSk7XG4gICAgcmV0dXJuIHsgZmxleEdyb3csIGZsZXhTaHJpbmssIGZsZXhCYXNpcyB9O1xufTtcbmNvbnN0IGhhbmRsZXJzJDggPSB7XG4gICAgYWxpZ25Db250ZW50OiAocHJvY2Vzc05vb3BWYWx1ZSksXG4gICAgYWxpZ25JdGVtczogKHByb2Nlc3NOb29wVmFsdWUpLFxuICAgIGFsaWduU2VsZjogKHByb2Nlc3NOb29wVmFsdWUpLFxuICAgIGZsZXg6IChwcm9jZXNzRmxleFNob3J0aGFuZCksXG4gICAgZmxleEJhc2lzOiAocHJvY2Vzc1VuaXRWYWx1ZSksXG4gICAgZmxleERpcmVjdGlvbjogKHByb2Nlc3NOb29wVmFsdWUpLFxuICAgIGZsZXhGbG93OiAocHJvY2Vzc05vb3BWYWx1ZSksXG4gICAgZmxleEdyb3c6IChwcm9jZXNzTnVtYmVyVmFsdWUpLFxuICAgIGZsZXhTaHJpbms6IChwcm9jZXNzTnVtYmVyVmFsdWUpLFxuICAgIGZsZXhXcmFwOiAocHJvY2Vzc05vb3BWYWx1ZSksXG4gICAganVzdGlmeUNvbnRlbnQ6IChwcm9jZXNzTm9vcFZhbHVlKSxcbiAgICBqdXN0aWZ5U2VsZjogKHByb2Nlc3NOb29wVmFsdWUpLFxufTtcblxuY29uc3QgcHJvY2Vzc0dhcFNob3J0aGFuZCA9IChrZXksIHZhbHVlLCBjb250YWluZXIpID0+IHtcbiAgICBjb25zdCBtYXRjaCA9IGAke3ZhbHVlfWAuc3BsaXQoJyAnKTtcbiAgICBjb25zdCByb3dHYXAgPSB0cmFuc2Zvcm1Vbml0KGNvbnRhaW5lciwgbWF0Y2g/LlswXSB8fCB2YWx1ZSk7XG4gICAgY29uc3QgY29sdW1uR2FwID0gdHJhbnNmb3JtVW5pdChjb250YWluZXIsIG1hdGNoPy5bMV0gfHwgdmFsdWUpO1xuICAgIHJldHVybiB7IHJvd0dhcCwgY29sdW1uR2FwIH07XG59O1xuY29uc3QgaGFuZGxlcnMkNyA9IHtcbiAgICBnYXA6IChwcm9jZXNzR2FwU2hvcnRoYW5kKSxcbiAgICBjb2x1bW5HYXA6IChwcm9jZXNzVW5pdFZhbHVlKSxcbiAgICByb3dHYXA6IChwcm9jZXNzVW5pdFZhbHVlKSxcbn07XG5cbmNvbnN0IGhhbmRsZXJzJDYgPSB7XG4gICAgYXNwZWN0UmF0aW86IChwcm9jZXNzTnVtYmVyVmFsdWUpLFxuICAgIGJvdHRvbTogKHByb2Nlc3NVbml0VmFsdWUpLFxuICAgIGRpc3BsYXk6IChwcm9jZXNzTm9vcFZhbHVlKSxcbiAgICBsZWZ0OiAocHJvY2Vzc1VuaXRWYWx1ZSksXG4gICAgcG9zaXRpb246IChwcm9jZXNzTm9vcFZhbHVlKSxcbiAgICByaWdodDogKHByb2Nlc3NVbml0VmFsdWUpLFxuICAgIHRvcDogKHByb2Nlc3NVbml0VmFsdWUpLFxuICAgIG92ZXJmbG93OiAocHJvY2Vzc05vb3BWYWx1ZSksXG4gICAgekluZGV4OiAocHJvY2Vzc051bWJlclZhbHVlKSxcbn07XG5cbmNvbnN0IEJPWF9NT0RFTF9VTklUUyA9ICdweCxpbixtbSxjbSxwdCwlLHZ3LHZoJztcbmNvbnN0IGxvZ0Vycm9yID0gKHN0eWxlLCB2YWx1ZSkgPT4ge1xuICAgIGNvbnN0IG5hbWUgPSBzdHlsZS50b1N0cmluZygpO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgY29uc29sZS5lcnJvcihgXG4gICAgQHJlYWN0LXBkZi9zdHlsZXNoZWV0IHBhcnNpbmcgZXJyb3I6XG4gICAgJHtuYW1lfTogJHt2YWx1ZX0sXG4gICAgJHsnICcucmVwZWF0KG5hbWUubGVuZ3RoICsgMil9XlxuICAgIFVuc3VwcG9ydGVkICR7bmFtZX0gdmFsdWUgZm9ybWF0XG4gIGApO1xufTtcbi8qKlxuICogQHBhcmFtIG9wdGlvbnNcbiAqIEBwYXJhbSBbb3B0aW9ucy5leHBhbmRzVG9dXG4gKiBAcGFyYW0gW29wdGlvbnMubWF4VmFsdWVzXVxuICogQHBhcmFtIFtvcHRpb25zLmF1dG9TdXBwb3J0ZWRdXG4gKi9cbmNvbnN0IGV4cGFuZEJveE1vZGVsID0gKHsgZXhwYW5kc1RvLCBtYXhWYWx1ZXMgPSAxLCBhdXRvU3VwcG9ydGVkID0gZmFsc2UsIH0gPSB7fSkgPT4gKG1vZGVsLCB2YWx1ZSwgY29udGFpbmVyKSA9PiB7XG4gICAgY29uc3Qgbm9kZXMgPSBwYXJzZSQxKGAke3ZhbHVlfWApO1xuICAgIGNvbnN0IHBhcnRzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBub2RlID0gbm9kZXNbaV07XG4gICAgICAgIC8vIHZhbHVlIGNvbnRhaW5zIGBjYWxjYCwgYHVybGAgb3Igb3RoZXIgY3NzIGZ1bmN0aW9uXG4gICAgICAgIC8vIGAsYCwgYC9gIG9yIHN0cmluZ3MgdGhhdCB1bnN1cHBvcnRlZCBieSBtYXJnaW4gYW5kIHBhZGRpbmdcbiAgICAgICAgaWYgKG5vZGUudHlwZSA9PT0gJ2Z1bmN0aW9uJyB8fFxuICAgICAgICAgICAgbm9kZS50eXBlID09PSAnc3RyaW5nJyB8fFxuICAgICAgICAgICAgbm9kZS50eXBlID09PSAnZGl2Jykge1xuICAgICAgICAgICAgbG9nRXJyb3IobW9kZWwsIHZhbHVlKTtcbiAgICAgICAgICAgIHJldHVybiB7fTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobm9kZS50eXBlID09PSAnd29yZCcpIHtcbiAgICAgICAgICAgIGlmIChub2RlLnZhbHVlID09PSAnYXV0bycgJiYgYXV0b1N1cHBvcnRlZCkge1xuICAgICAgICAgICAgICAgIHBhcnRzLnB1c2gobm9kZS52YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBwYXJzZVVuaXQobm9kZS52YWx1ZSk7XG4gICAgICAgICAgICAgICAgLy8gd2hlbiB1bml0IGlzbid0IHNwZWNpZmllZCB0aGlzIGNvbmRpdGlvbiBpcyB0cnVlXG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdCAmJiBCT1hfTU9ERUxfVU5JVFMuaW5jbHVkZXMocmVzdWx0LnVuaXQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcnRzLnB1c2gobm9kZS52YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsb2dFcnJvcihtb2RlbCwgdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge307XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8vIGNoZWNrcyB0aGF0IHdlIGhhdmUgZW5vdWdoIHBhcnNlZCB2YWx1ZXNcbiAgICBpZiAocGFydHMubGVuZ3RoID4gbWF4VmFsdWVzKSB7XG4gICAgICAgIGxvZ0Vycm9yKG1vZGVsLCB2YWx1ZSk7XG4gICAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gICAgY29uc3QgZmlyc3QgPSB0cmFuc2Zvcm1Vbml0KGNvbnRhaW5lciwgcGFydHNbMF0pO1xuICAgIGlmIChleHBhbmRzVG8pIHtcbiAgICAgICAgY29uc3Qgc2Vjb25kID0gdHJhbnNmb3JtVW5pdChjb250YWluZXIsIHBhcnRzWzFdIHx8IHBhcnRzWzBdKTtcbiAgICAgICAgY29uc3QgdGhpcmQgPSB0cmFuc2Zvcm1Vbml0KGNvbnRhaW5lciwgcGFydHNbMl0gfHwgcGFydHNbMF0pO1xuICAgICAgICBjb25zdCBmb3VydGggPSB0cmFuc2Zvcm1Vbml0KGNvbnRhaW5lciwgcGFydHNbM10gfHwgcGFydHNbMV0gfHwgcGFydHNbMF0pO1xuICAgICAgICByZXR1cm4gZXhwYW5kc1RvKHsgZmlyc3QsIHNlY29uZCwgdGhpcmQsIGZvdXJ0aCB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgW21vZGVsXTogZmlyc3QsXG4gICAgfTtcbn07XG5cbmNvbnN0IHByb2Nlc3NNYXJnaW4gPSBleHBhbmRCb3hNb2RlbCh7XG4gICAgZXhwYW5kc1RvOiAoeyBmaXJzdCwgc2Vjb25kLCB0aGlyZCwgZm91cnRoIH0pID0+ICh7XG4gICAgICAgIG1hcmdpblRvcDogZmlyc3QsXG4gICAgICAgIG1hcmdpblJpZ2h0OiBzZWNvbmQsXG4gICAgICAgIG1hcmdpbkJvdHRvbTogdGhpcmQsXG4gICAgICAgIG1hcmdpbkxlZnQ6IGZvdXJ0aCxcbiAgICB9KSxcbiAgICBtYXhWYWx1ZXM6IDQsXG4gICAgYXV0b1N1cHBvcnRlZDogdHJ1ZSxcbn0pO1xuY29uc3QgcHJvY2Vzc01hcmdpblZlcnRpY2FsID0gZXhwYW5kQm94TW9kZWwoe1xuICAgIGV4cGFuZHNUbzogKHsgZmlyc3QsIHNlY29uZCB9KSA9PiAoe1xuICAgICAgICBtYXJnaW5Ub3A6IGZpcnN0LFxuICAgICAgICBtYXJnaW5Cb3R0b206IHNlY29uZCxcbiAgICB9KSxcbiAgICBtYXhWYWx1ZXM6IDIsXG4gICAgYXV0b1N1cHBvcnRlZDogdHJ1ZSxcbn0pO1xuY29uc3QgcHJvY2Vzc01hcmdpbkhvcml6b250YWwgPSBleHBhbmRCb3hNb2RlbCh7XG4gICAgZXhwYW5kc1RvOiAoeyBmaXJzdCwgc2Vjb25kIH0pID0+ICh7XG4gICAgICAgIG1hcmdpblJpZ2h0OiBmaXJzdCxcbiAgICAgICAgbWFyZ2luTGVmdDogc2Vjb25kLFxuICAgIH0pLFxuICAgIG1heFZhbHVlczogMixcbiAgICBhdXRvU3VwcG9ydGVkOiB0cnVlLFxufSk7XG5jb25zdCBwcm9jZXNzTWFyZ2luU2luZ2xlID0gZXhwYW5kQm94TW9kZWwoe1xuICAgIGF1dG9TdXBwb3J0ZWQ6IHRydWUsXG59KTtcbmNvbnN0IGhhbmRsZXJzJDUgPSB7XG4gICAgbWFyZ2luOiAocHJvY2Vzc01hcmdpbiksXG4gICAgbWFyZ2luQm90dG9tOiAocHJvY2Vzc01hcmdpblNpbmdsZSksXG4gICAgbWFyZ2luSG9yaXpvbnRhbDogKHByb2Nlc3NNYXJnaW5Ib3Jpem9udGFsKSxcbiAgICBtYXJnaW5MZWZ0OiAocHJvY2Vzc01hcmdpblNpbmdsZSksXG4gICAgbWFyZ2luUmlnaHQ6IChwcm9jZXNzTWFyZ2luU2luZ2xlKSxcbiAgICBtYXJnaW5Ub3A6IChwcm9jZXNzTWFyZ2luU2luZ2xlKSxcbiAgICBtYXJnaW5WZXJ0aWNhbDogKHByb2Nlc3NNYXJnaW5WZXJ0aWNhbCksXG59O1xuXG5jb25zdCBwcm9jZXNzUGFkZGluZyA9IGV4cGFuZEJveE1vZGVsKHtcbiAgICBleHBhbmRzVG86ICh7IGZpcnN0LCBzZWNvbmQsIHRoaXJkLCBmb3VydGggfSkgPT4gKHtcbiAgICAgICAgcGFkZGluZ1RvcDogZmlyc3QsXG4gICAgICAgIHBhZGRpbmdSaWdodDogc2Vjb25kLFxuICAgICAgICBwYWRkaW5nQm90dG9tOiB0aGlyZCxcbiAgICAgICAgcGFkZGluZ0xlZnQ6IGZvdXJ0aCxcbiAgICB9KSxcbiAgICBtYXhWYWx1ZXM6IDQsXG59KTtcbmNvbnN0IHByb2Nlc3NQYWRkaW5nVmVydGljYWwgPSBleHBhbmRCb3hNb2RlbCh7XG4gICAgZXhwYW5kc1RvOiAoeyBmaXJzdCwgc2Vjb25kIH0pID0+ICh7XG4gICAgICAgIHBhZGRpbmdUb3A6IGZpcnN0LFxuICAgICAgICBwYWRkaW5nQm90dG9tOiBzZWNvbmQsXG4gICAgfSksXG4gICAgbWF4VmFsdWVzOiAyLFxufSk7XG5jb25zdCBwcm9jZXNzUGFkZGluZ0hvcml6b250YWwgPSBleHBhbmRCb3hNb2RlbCh7XG4gICAgZXhwYW5kc1RvOiAoeyBmaXJzdCwgc2Vjb25kIH0pID0+ICh7XG4gICAgICAgIHBhZGRpbmdSaWdodDogZmlyc3QsXG4gICAgICAgIHBhZGRpbmdMZWZ0OiBzZWNvbmQsXG4gICAgfSksXG4gICAgbWF4VmFsdWVzOiAyLFxufSk7XG5jb25zdCBwcm9jZXNzUGFkZGluZ1NpbmdsZSA9IGV4cGFuZEJveE1vZGVsKCk7XG5jb25zdCBoYW5kbGVycyQ0ID0ge1xuICAgIHBhZGRpbmc6IChwcm9jZXNzUGFkZGluZyksXG4gICAgcGFkZGluZ0JvdHRvbTogKHByb2Nlc3NQYWRkaW5nU2luZ2xlKSxcbiAgICBwYWRkaW5nSG9yaXpvbnRhbDogKHByb2Nlc3NQYWRkaW5nSG9yaXpvbnRhbCksXG4gICAgcGFkZGluZ0xlZnQ6IChwcm9jZXNzUGFkZGluZ1NpbmdsZSksXG4gICAgcGFkZGluZ1JpZ2h0OiAocHJvY2Vzc1BhZGRpbmdTaW5nbGUpLFxuICAgIHBhZGRpbmdUb3A6IChwcm9jZXNzUGFkZGluZ1NpbmdsZSksXG4gICAgcGFkZGluZ1ZlcnRpY2FsOiAocHJvY2Vzc1BhZGRpbmdWZXJ0aWNhbCksXG59O1xuXG5jb25zdCBvZmZzZXRLZXl3b3JkID0gKHZhbHVlKSA9PiB7XG4gICAgc3dpdGNoICh2YWx1ZSkge1xuICAgICAgICBjYXNlICd0b3AnOlxuICAgICAgICBjYXNlICdsZWZ0JzpcbiAgICAgICAgICAgIHJldHVybiAnMCUnO1xuICAgICAgICBjYXNlICdyaWdodCc6XG4gICAgICAgIGNhc2UgJ2JvdHRvbSc6XG4gICAgICAgICAgICByZXR1cm4gJzEwMCUnO1xuICAgICAgICBjYXNlICdjZW50ZXInOlxuICAgICAgICAgICAgcmV0dXJuICc1MCUnO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbn07XG5cbmNvbnN0IHByb2Nlc3NPYmplY3RQb3NpdGlvbiA9IChrZXksIHZhbHVlLCBjb250YWluZXIpID0+IHtcbiAgICBjb25zdCBtYXRjaCA9IGAke3ZhbHVlfWAuc3BsaXQoJyAnKTtcbiAgICBjb25zdCBvYmplY3RQb3NpdGlvblggPSBvZmZzZXRLZXl3b3JkKHRyYW5zZm9ybVVuaXQoY29udGFpbmVyLCBtYXRjaD8uWzBdIHx8IHZhbHVlKSk7XG4gICAgY29uc3Qgb2JqZWN0UG9zaXRpb25ZID0gb2Zmc2V0S2V5d29yZCh0cmFuc2Zvcm1Vbml0KGNvbnRhaW5lciwgbWF0Y2g/LlsxXSB8fCB2YWx1ZSkpO1xuICAgIHJldHVybiB7IG9iamVjdFBvc2l0aW9uWCwgb2JqZWN0UG9zaXRpb25ZIH07XG59O1xuY29uc3QgcHJvY2Vzc09iamVjdFBvc2l0aW9uVmFsdWUgPSAoa2V5LCB2YWx1ZSwgY29udGFpbmVyKSA9PiAoe1xuICAgIFtrZXldOiBvZmZzZXRLZXl3b3JkKHRyYW5zZm9ybVVuaXQoY29udGFpbmVyLCB2YWx1ZSkpLFxufSk7XG5jb25zdCBoYW5kbGVycyQzID0ge1xuICAgIG9iamVjdFBvc2l0aW9uOiAocHJvY2Vzc09iamVjdFBvc2l0aW9uKSxcbiAgICBvYmplY3RQb3NpdGlvblg6IChwcm9jZXNzT2JqZWN0UG9zaXRpb25WYWx1ZSksXG4gICAgb2JqZWN0UG9zaXRpb25ZOiAocHJvY2Vzc09iamVjdFBvc2l0aW9uVmFsdWUpLFxuICAgIG9iamVjdEZpdDogKHByb2Nlc3NOb29wVmFsdWUpLFxufTtcblxuY29uc3QgY2FzdEludCA9ICh2YWx1ZSkgPT4ge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgcmV0dXJuIHBhcnNlSW50KHZhbHVlLCAxMCk7XG59O1xuXG5jb25zdCBGT05UX1dFSUdIVFMgPSB7XG4gICAgdGhpbjogMTAwLFxuICAgIGhhaXJsaW5lOiAxMDAsXG4gICAgdWx0cmFsaWdodDogMjAwLFxuICAgIGV4dHJhbGlnaHQ6IDIwMCxcbiAgICBsaWdodDogMzAwLFxuICAgIG5vcm1hbDogNDAwLFxuICAgIG1lZGl1bTogNTAwLFxuICAgIHNlbWlib2xkOiA2MDAsXG4gICAgZGVtaWJvbGQ6IDYwMCxcbiAgICBib2xkOiA3MDAsXG4gICAgdWx0cmFib2xkOiA4MDAsXG4gICAgZXh0cmFib2xkOiA4MDAsXG4gICAgaGVhdnk6IDkwMCxcbiAgICBibGFjazogOTAwLFxufTtcbmNvbnN0IHRyYW5zZm9ybUZvbnRXZWlnaHQgPSAodmFsdWUpID0+IHtcbiAgICBpZiAoIXZhbHVlKVxuICAgICAgICByZXR1cm4gRk9OVF9XRUlHSFRTLm5vcm1hbDtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJylcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIGNvbnN0IGx2ID0gdmFsdWUudG9Mb3dlckNhc2UoKTtcbiAgICBpZiAoRk9OVF9XRUlHSFRTW2x2XSlcbiAgICAgICAgcmV0dXJuIEZPTlRfV0VJR0hUU1tsdl07XG4gICAgcmV0dXJuIGNhc3RJbnQodmFsdWUpO1xufTtcbmNvbnN0IHByb2Nlc3NGb250V2VpZ2h0ID0gKGtleSwgdmFsdWUpID0+IHtcbiAgICByZXR1cm4geyBba2V5XTogdHJhbnNmb3JtRm9udFdlaWdodCh2YWx1ZSkgfTtcbn07XG5jb25zdCB0cmFuc2Zvcm1MaW5lSGVpZ2h0ID0gKHZhbHVlLCBzdHlsZXMsIGNvbnRhaW5lcikgPT4ge1xuICAgIGlmICh2YWx1ZSA9PT0gJycpXG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICBjb25zdCBmb250U2l6ZSA9IHRyYW5zZm9ybVVuaXQoY29udGFpbmVyLCBzdHlsZXMuZm9udFNpemUgfHwgMTgpO1xuICAgIGNvbnN0IGxpbmVIZWlnaHQgPSB0cmFuc2Zvcm1Vbml0KGNvbnRhaW5lciwgdmFsdWUpO1xuICAgIC8vIFBlcmNlbnQgdmFsdWVzOiB1c2UgdGhpcyBudW1iZXIgbXVsdGlwbGllZCBieSB0aGUgZWxlbWVudCdzIGZvbnQgc2l6ZVxuICAgIGNvbnN0IHsgcGVyY2VudCB9ID0gbWF0Y2hQZXJjZW50KGxpbmVIZWlnaHQpIHx8IHt9O1xuICAgIGlmIChwZXJjZW50KVxuICAgICAgICByZXR1cm4gcGVyY2VudCAqIGZvbnRTaXplO1xuICAgIC8vIFVuaXRsZXNzIHZhbHVlczogdXNlIHRoaXMgbnVtYmVyIG11bHRpcGxpZWQgYnkgdGhlIGVsZW1lbnQncyBmb250IHNpemVcbiAgICByZXR1cm4gaXNOYU4odmFsdWUpID8gbGluZUhlaWdodCA6IGxpbmVIZWlnaHQgKiBmb250U2l6ZTtcbn07XG5jb25zdCBwcm9jZXNzTGluZUhlaWdodCA9IChrZXksIHZhbHVlLCBjb250YWluZXIsIHN0eWxlcykgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICAgIFtrZXldOiB0cmFuc2Zvcm1MaW5lSGVpZ2h0KHZhbHVlLCBzdHlsZXMsIGNvbnRhaW5lciksXG4gICAgfTtcbn07XG5jb25zdCBoYW5kbGVycyQyID0ge1xuICAgIGRpcmVjdGlvbjogKHByb2Nlc3NOb29wVmFsdWUpLFxuICAgIGZvbnRGYW1pbHk6IChwcm9jZXNzTm9vcFZhbHVlKSxcbiAgICBmb250U2l6ZTogKHByb2Nlc3NVbml0VmFsdWUpLFxuICAgIGZvbnRTdHlsZTogKHByb2Nlc3NOb29wVmFsdWUpLFxuICAgIGZvbnRXZWlnaHQ6IChwcm9jZXNzRm9udFdlaWdodCksXG4gICAgbGV0dGVyU3BhY2luZzogKHByb2Nlc3NVbml0VmFsdWUpLFxuICAgIGxpbmVIZWlnaHQ6IChwcm9jZXNzTGluZUhlaWdodCksXG4gICAgbWF4TGluZXM6IChwcm9jZXNzTnVtYmVyVmFsdWUpLFxuICAgIHRleHRBbGlnbjogKHByb2Nlc3NOb29wVmFsdWUpLFxuICAgIHRleHREZWNvcmF0aW9uOiAocHJvY2Vzc05vb3BWYWx1ZSksXG4gICAgdGV4dERlY29yYXRpb25Db2xvcjogKHByb2Nlc3NDb2xvclZhbHVlKSxcbiAgICB0ZXh0RGVjb3JhdGlvblN0eWxlOiAocHJvY2Vzc05vb3BWYWx1ZSksXG4gICAgdGV4dEluZGVudDogKHByb2Nlc3NOb29wVmFsdWUpLFxuICAgIHRleHRPdmVyZmxvdzogKHByb2Nlc3NOb29wVmFsdWUpLFxuICAgIHRleHRUcmFuc2Zvcm06IChwcm9jZXNzTm9vcFZhbHVlKSxcbiAgICB2ZXJ0aWNhbEFsaWduOiAocHJvY2Vzc05vb3BWYWx1ZSksXG59O1xuXG5jb25zdCBtYXRjaE51bWJlciA9ICh2YWx1ZSkgPT4gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyAmJiAvXi0/XFxkKlxcLj9cXGQqJC8udGVzdCh2YWx1ZSk7XG5jb25zdCBjYXN0RmxvYXQgPSAodmFsdWUpID0+IHtcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJylcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIGlmIChtYXRjaE51bWJlcih2YWx1ZSkpXG4gICAgICAgIHJldHVybiBwYXJzZUZsb2F0KHZhbHVlKTtcbiAgICByZXR1cm4gdmFsdWU7XG59O1xuXG5jb25zdCBwYXJzZSA9ICh0cmFuc2Zvcm1TdHJpbmcpID0+IHtcbiAgICBjb25zdCB0cmFuc2Zvcm1zID0gdHJhbnNmb3JtU3RyaW5nLnRyaW0oKS5zcGxpdCgvXFwpWyAsXXxcXCkvKTtcbiAgICAvLyBIYW5kbGUgXCJpbml0aWFsXCIsIFwiaW5oZXJpdFwiLCBcInVuc2V0XCIuXG4gICAgaWYgKHRyYW5zZm9ybXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHJldHVybiBbW3RyYW5zZm9ybXNbMF0sIHRydWVdXTtcbiAgICB9XG4gICAgY29uc3QgcGFyc2VkID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0cmFuc2Zvcm1zLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGNvbnN0IHRyYW5zZm9ybSA9IHRyYW5zZm9ybXNbaV07XG4gICAgICAgIGlmICh0cmFuc2Zvcm0pIHtcbiAgICAgICAgICAgIGNvbnN0IFtuYW1lLCByYXdWYWx1ZV0gPSB0cmFuc2Zvcm0uc3BsaXQoJygnKTtcbiAgICAgICAgICAgIGNvbnN0IHNwbGl0Q2hhciA9IHJhd1ZhbHVlLmluZGV4T2YoJywnKSA+PSAwID8gJywnIDogJyAnO1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSByYXdWYWx1ZS5zcGxpdChzcGxpdENoYXIpLm1hcCgodmFsKSA9PiB2YWwudHJpbSgpKTtcbiAgICAgICAgICAgIHBhcnNlZC5wdXNoKHsgb3BlcmF0aW9uOiBuYW1lLnRyaW0oKSwgdmFsdWUgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHBhcnNlZDtcbn07XG5jb25zdCBwYXJzZUFuZ2xlID0gKHZhbHVlKSA9PiB7XG4gICAgY29uc3QgdW5pdHNSZWdleHAgPSAvKC0/XFxkKlxcLj9cXGQqKShcXHcqKT8vaTtcbiAgICBjb25zdCBbLCBhbmdsZSwgdW5pdF0gPSB1bml0c1JlZ2V4cC5leGVjKHZhbHVlKTtcbiAgICBjb25zdCBudW1iZXIgPSBOdW1iZXIucGFyc2VGbG9hdChhbmdsZSk7XG4gICAgcmV0dXJuIHVuaXQgPT09ICdyYWQnID8gKG51bWJlciAqIDE4MCkgLyBNYXRoLlBJIDogbnVtYmVyO1xufTtcbmNvbnN0IG5vcm1hbGl6ZVRyYW5zZm9ybU9wZXJhdGlvbiA9ICh7IG9wZXJhdGlvbiwgdmFsdWUgfSkgPT4ge1xuICAgIHN3aXRjaCAob3BlcmF0aW9uKSB7XG4gICAgICAgIGNhc2UgJ3NjYWxlJzoge1xuICAgICAgICAgICAgY29uc3QgW3NjYWxlWCwgc2NhbGVZID0gc2NhbGVYXSA9IHZhbHVlLm1hcCgobnVtKSA9PiBOdW1iZXIucGFyc2VGbG9hdChudW0pKTtcbiAgICAgICAgICAgIHJldHVybiB7IG9wZXJhdGlvbjogJ3NjYWxlJywgdmFsdWU6IFtzY2FsZVgsIHNjYWxlWV0gfTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdzY2FsZVgnOiB7XG4gICAgICAgICAgICByZXR1cm4geyBvcGVyYXRpb246ICdzY2FsZScsIHZhbHVlOiBbTnVtYmVyLnBhcnNlRmxvYXQodmFsdWUpLCAxXSB9O1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ3NjYWxlWSc6IHtcbiAgICAgICAgICAgIHJldHVybiB7IG9wZXJhdGlvbjogJ3NjYWxlJywgdmFsdWU6IFsxLCBOdW1iZXIucGFyc2VGbG9hdCh2YWx1ZSldIH07XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAncm90YXRlJzoge1xuICAgICAgICAgICAgcmV0dXJuIHsgb3BlcmF0aW9uOiAncm90YXRlJywgdmFsdWU6IFtwYXJzZUFuZ2xlKHZhbHVlKV0gfTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlICd0cmFuc2xhdGUnOiB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogJ3RyYW5zbGF0ZScsXG4gICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlLm1hcCgobnVtKSA9PiBOdW1iZXIucGFyc2VGbG9hdChudW0pKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAndHJhbnNsYXRlWCc6IHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uOiAndHJhbnNsYXRlJyxcbiAgICAgICAgICAgICAgICB2YWx1ZTogW051bWJlci5wYXJzZUZsb2F0KHZhbHVlKSwgMF0sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ3RyYW5zbGF0ZVknOiB7XG4gICAgICAgICAgICByZXR1cm4geyBvcGVyYXRpb246ICd0cmFuc2xhdGUnLCB2YWx1ZTogWzAsIE51bWJlci5wYXJzZUZsb2F0KHZhbHVlKV0gfTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdza2V3Jzoge1xuICAgICAgICAgICAgcmV0dXJuIHsgb3BlcmF0aW9uOiAnc2tldycsIHZhbHVlOiB2YWx1ZS5tYXAocGFyc2VBbmdsZSkgfTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdza2V3WCc6IHtcbiAgICAgICAgICAgIHJldHVybiB7IG9wZXJhdGlvbjogJ3NrZXcnLCB2YWx1ZTogW3BhcnNlQW5nbGUodmFsdWUpLCAwXSB9O1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ3NrZXdZJzoge1xuICAgICAgICAgICAgcmV0dXJuIHsgb3BlcmF0aW9uOiAnc2tldycsIHZhbHVlOiBbMCwgcGFyc2VBbmdsZSh2YWx1ZSldIH07XG4gICAgICAgIH1cbiAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgcmV0dXJuIHsgb3BlcmF0aW9uLCB2YWx1ZTogdmFsdWUubWFwKChudW0pID0+IE51bWJlci5wYXJzZUZsb2F0KG51bSkpIH07XG4gICAgICAgIH1cbiAgICB9XG59O1xuY29uc3Qgbm9ybWFsaXplID0gKG9wZXJhdGlvbnMpID0+IHtcbiAgICByZXR1cm4gb3BlcmF0aW9ucy5tYXAoKG9wZXJhdGlvbikgPT4gbm9ybWFsaXplVHJhbnNmb3JtT3BlcmF0aW9uKG9wZXJhdGlvbikpO1xufTtcbmNvbnN0IHByb2Nlc3NUcmFuc2Zvcm0gPSAoa2V5LCB2YWx1ZSkgPT4ge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnKVxuICAgICAgICByZXR1cm4geyBba2V5XTogdmFsdWUgfTtcbiAgICByZXR1cm4geyBba2V5XTogbm9ybWFsaXplKHBhcnNlKHZhbHVlKSkgfTtcbn07XG5jb25zdCBZX0FYSVNfU0hPUlRIQU5EUyA9IHsgdG9wOiB0cnVlLCBib3R0b206IHRydWUgfTtcbmNvbnN0IHNvcnRUcmFuc2Zvcm1PcmlnaW5QYWlyID0gKGEsIGIpID0+IHtcbiAgICBpZiAoWV9BWElTX1NIT1JUSEFORFNbYV0pXG4gICAgICAgIHJldHVybiAxO1xuICAgIGlmIChZX0FYSVNfU0hPUlRIQU5EU1tiXSlcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIHJldHVybiAwO1xufTtcbmNvbnN0IGdldFRyYW5zZm9ybU9yaWdpblBhaXIgPSAodmFsdWVzKSA9PiB7XG4gICAgaWYgKCF2YWx1ZXMgfHwgdmFsdWVzLmxlbmd0aCA9PT0gMClcbiAgICAgICAgcmV0dXJuIFsnY2VudGVyJywgJ2NlbnRlciddO1xuICAgIGNvbnN0IHBhaXIgPSB2YWx1ZXMubGVuZ3RoID09PSAxID8gW3ZhbHVlc1swXSwgJ2NlbnRlciddIDogdmFsdWVzO1xuICAgIHJldHVybiBwYWlyLnNvcnQoc29ydFRyYW5zZm9ybU9yaWdpblBhaXIpO1xufTtcbi8vIFRyYW5zZm9ybXMgc2hvcnRoYW5kIHRyYW5zZm9ybU9yaWdpbiB2YWx1ZXNcbmNvbnN0IHByb2Nlc3NUcmFuc2Zvcm1PcmlnaW5TaG9ydGhhbmQgPSAoa2V5LCB2YWx1ZSwgY29udGFpbmVyKSA9PiB7XG4gICAgY29uc3QgbWF0Y2ggPSBgJHt2YWx1ZX1gLnNwbGl0KCcgJyk7XG4gICAgY29uc3QgcGFpciA9IGdldFRyYW5zZm9ybU9yaWdpblBhaXIobWF0Y2gpO1xuICAgIGNvbnN0IHRyYW5zZm9ybU9yaWdpblggPSB0cmFuc2Zvcm1Vbml0KGNvbnRhaW5lciwgcGFpclswXSk7XG4gICAgY29uc3QgdHJhbnNmb3JtT3JpZ2luWSA9IHRyYW5zZm9ybVVuaXQoY29udGFpbmVyLCBwYWlyWzFdKTtcbiAgICByZXR1cm4ge1xuICAgICAgICB0cmFuc2Zvcm1PcmlnaW5YOiBvZmZzZXRLZXl3b3JkKHRyYW5zZm9ybU9yaWdpblgpIHx8IGNhc3RGbG9hdCh0cmFuc2Zvcm1PcmlnaW5YKSxcbiAgICAgICAgdHJhbnNmb3JtT3JpZ2luWTogb2Zmc2V0S2V5d29yZCh0cmFuc2Zvcm1PcmlnaW5ZKSB8fCBjYXN0RmxvYXQodHJhbnNmb3JtT3JpZ2luWSksXG4gICAgfTtcbn07XG5jb25zdCBwcm9jZXNzVHJhbnNmb3JtT3JpZ2luVmFsdWUgPSAoa2V5LCB2YWx1ZSwgY29udGFpbmVyKSA9PiB7XG4gICAgY29uc3QgdiA9IHRyYW5zZm9ybVVuaXQoY29udGFpbmVyLCB2YWx1ZSk7XG4gICAgcmV0dXJuIHsgW2tleV06IG9mZnNldEtleXdvcmQodikgfHwgY2FzdEZsb2F0KHYpIH07XG59O1xuY29uc3QgaGFuZGxlcnMkMSA9IHtcbiAgICB0cmFuc2Zvcm06IHByb2Nlc3NUcmFuc2Zvcm0sXG4gICAgZ3JhZGllbnRUcmFuc2Zvcm06IHByb2Nlc3NUcmFuc2Zvcm0sXG4gICAgdHJhbnNmb3JtT3JpZ2luOiAocHJvY2Vzc1RyYW5zZm9ybU9yaWdpblNob3J0aGFuZCksXG4gICAgdHJhbnNmb3JtT3JpZ2luWDogKHByb2Nlc3NUcmFuc2Zvcm1PcmlnaW5WYWx1ZSksXG4gICAgdHJhbnNmb3JtT3JpZ2luWTogKHByb2Nlc3NUcmFuc2Zvcm1PcmlnaW5WYWx1ZSksXG59O1xuXG5jb25zdCBoYW5kbGVycyA9IHtcbiAgICBmaWxsOiAocHJvY2Vzc0NvbG9yVmFsdWUpLFxuICAgIHN0cm9rZTogKHByb2Nlc3NDb2xvclZhbHVlKSxcbiAgICBzdHJva2VEYXNoYXJyYXk6IChwcm9jZXNzTm9vcFZhbHVlKSxcbiAgICBzdHJva2VXaWR0aDogKHByb2Nlc3NVbml0VmFsdWUpLFxuICAgIGZpbGxPcGFjaXR5OiAocHJvY2Vzc051bWJlclZhbHVlKSxcbiAgICBzdHJva2VPcGFjaXR5OiAocHJvY2Vzc051bWJlclZhbHVlKSxcbiAgICBmaWxsUnVsZTogKHByb2Nlc3NOb29wVmFsdWUpLFxuICAgIHRleHRBbmNob3I6IChwcm9jZXNzTm9vcFZhbHVlKSxcbiAgICBzdHJva2VMaW5lY2FwOiAocHJvY2Vzc05vb3BWYWx1ZSksXG4gICAgc3Ryb2tlTGluZWpvaW46IChwcm9jZXNzTm9vcFZhbHVlKSxcbiAgICB2aXNpYmlsaXR5OiAocHJvY2Vzc05vb3BWYWx1ZSksXG4gICAgY2xpcFBhdGg6IChwcm9jZXNzTm9vcFZhbHVlKSxcbiAgICBkb21pbmFudEJhc2VsaW5lOiAocHJvY2Vzc05vb3BWYWx1ZSksXG59O1xuXG5jb25zdCBzaG9ydGhhbmRzID0ge1xuICAgIC4uLmhhbmRsZXJzJGIsXG4gICAgLi4uaGFuZGxlcnMkYSxcbiAgICAuLi5oYW5kbGVycyQ5LFxuICAgIC4uLmhhbmRsZXJzJDgsXG4gICAgLi4uaGFuZGxlcnMkNyxcbiAgICAuLi5oYW5kbGVycyQ2LFxuICAgIC4uLmhhbmRsZXJzJDUsXG4gICAgLi4uaGFuZGxlcnMkNCxcbiAgICAuLi5oYW5kbGVycyQzLFxuICAgIC4uLmhhbmRsZXJzJDIsXG4gICAgLi4uaGFuZGxlcnMkMSxcbiAgICAuLi5oYW5kbGVycyxcbn07XG4vKipcbiAqIEV4cGFuZCB0aGUgc2hvcnRoYW5kIHByb3BlcnRpZXMuXG4gKlxuICogQHBhcmFtIHN0eWxlIC0gU3R5bGUgb2JqZWN0XG4gKiBAcmV0dXJucyBFeHBhbmRlZCBzdHlsZSBvYmplY3RcbiAqL1xuY29uc3QgcmVzb2x2ZSA9IChjb250YWluZXIpID0+IChzdHlsZSkgPT4ge1xuICAgIGNvbnN0IHByb3BzQXJyYXkgPSBPYmplY3Qua2V5cyhzdHlsZSk7XG4gICAgY29uc3QgcmVzb2x2ZWRTdHlsZSA9IHt9O1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHJvcHNBcnJheS5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBjb25zdCBrZXkgPSBwcm9wc0FycmF5W2ldO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHN0eWxlW2tleV07XG4gICAgICAgIGlmICghc2hvcnRoYW5kc1trZXldKSB7XG4gICAgICAgICAgICByZXNvbHZlZFN0eWxlW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc29sdmVkID0gc2hvcnRoYW5kc1trZXldKGtleSwgdmFsdWUsIGNvbnRhaW5lciwgc3R5bGUpO1xuICAgICAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMocmVzb2x2ZWQpO1xuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGtleXMubGVuZ3RoOyBqICs9IDEpIHtcbiAgICAgICAgICAgIGNvbnN0IHByb3BOYW1lID0ga2V5c1tqXTtcbiAgICAgICAgICAgIGNvbnN0IHByb3BWYWx1ZSA9IHJlc29sdmVkW3Byb3BOYW1lXTtcbiAgICAgICAgICAgIHJlc29sdmVkU3R5bGVbcHJvcE5hbWVdID0gcHJvcFZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXNvbHZlZFN0eWxlO1xufTtcblxuLyoqXG4gKiBSZXNvbHZlcyBzdHlsZXNcbiAqXG4gKiBAcGFyYW0gY29udGFpbmVyXG4gKiBAcGFyYW0gc3R5bGUgLSBTdHlsZVxuICogQHJldHVybnMgUmVzb2x2ZWQgc3R5bGVcbiAqL1xuY29uc3QgcmVzb2x2ZVN0eWxlcyA9IChjb250YWluZXIsIHN0eWxlKSA9PiB7XG4gICAgY29uc3QgY29tcHV0ZU1lZGlhUXVlcmllcyA9ICh2YWx1ZSkgPT4gcmVzb2x2ZU1lZGlhUXVlcmllcyhjb250YWluZXIsIHZhbHVlKTtcbiAgICByZXR1cm4gY29tcG9zZShyZXNvbHZlKGNvbnRhaW5lciksIGNvbXB1dGVNZWRpYVF1ZXJpZXMsIGZsYXR0ZW4pKHN0eWxlKTtcbn07XG5cbmV4cG9ydCB7IHJlc29sdmVTdHlsZXMgYXMgZGVmYXVsdCwgZmxhdHRlbiwgdHJhbnNmb3JtQ29sb3IgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@react-pdf+stylesheet@6.1.0/node_modules/@react-pdf/stylesheet/lib/index.js\n");

/***/ })

};
;