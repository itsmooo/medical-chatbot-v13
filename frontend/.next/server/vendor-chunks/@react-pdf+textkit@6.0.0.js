"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@react-pdf+textkit@6.0.0";
exports.ids = ["vendor-chunks/@react-pdf+textkit@6.0.0"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/@react-pdf+textkit@6.0.0/node_modules/@react-pdf/textkit/lib/textkit.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@react-pdf+textkit@6.0.0/node_modules/@react-pdf/textkit/lib/textkit.js ***!
  \****************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   bidi: () => (/* binding */ bidiEngine),\n/* harmony export */   \"default\": () => (/* binding */ layoutEngine),\n/* harmony export */   fontSubstitution: () => (/* binding */ fontSubstitution),\n/* harmony export */   fromFragments: () => (/* binding */ fromFragments),\n/* harmony export */   justification: () => (/* binding */ justification),\n/* harmony export */   linebreaker: () => (/* binding */ linebreaker),\n/* harmony export */   scriptItemizer: () => (/* binding */ scriptItemizer),\n/* harmony export */   textDecoration: () => (/* binding */ textDecoration),\n/* harmony export */   wordHyphenation: () => (/* binding */ wordHyphenation)\n/* harmony export */ });\n/* harmony import */ var _react_pdf_fns__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @react-pdf/fns */ \"(ssr)/./node_modules/.pnpm/@react-pdf+fns@3.1.2/node_modules/@react-pdf/fns/lib/index.js\");\n/* harmony import */ var bidi_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! bidi-js */ \"(ssr)/./node_modules/.pnpm/bidi-js@1.0.3/node_modules/bidi-js/dist/bidi.js\");\n/* harmony import */ var unicode_properties__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! unicode-properties */ \"(ssr)/./node_modules/.pnpm/unicode-properties@1.4.1/node_modules/unicode-properties/dist/module.mjs\");\n/* harmony import */ var hyphen__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! hyphen */ \"(ssr)/./node_modules/.pnpm/hyphen@1.10.6/node_modules/hyphen/index.js\");\n/* harmony import */ var hyphen_patterns_en_us_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! hyphen/patterns/en-us.js */ \"(ssr)/./node_modules/.pnpm/hyphen@1.10.6/node_modules/hyphen/patterns/en-us.js\");\n\n\n\n\n\n\n/**\n * Create attributed string from text fragments\n *\n * @param fragments - Fragments\n * @returns Attributed string\n */\nconst fromFragments = (fragments) => {\n    let offset = 0;\n    let string = '';\n    const runs = [];\n    fragments.forEach((fragment) => {\n        string += fragment.string;\n        runs.push({\n            ...fragment,\n            start: offset,\n            end: offset + fragment.string.length,\n            attributes: fragment.attributes || {},\n        });\n        offset += fragment.string.length;\n    });\n    return { string, runs };\n};\n\n/**\n * Default word hyphenation engine used when no one provided.\n * Does not perform word hyphenation at all\n *\n * @param word\n * @returns Same word\n */\nconst defaultHyphenationEngine = (word) => [word];\n/**\n * Wrap words of attribute string\n *\n * @param engines layout engines\n * @param options layout options\n */\nconst wrapWords = (engines = {}, options = {}) => {\n    /**\n     * @param attributedString - Attributed string\n     * @returns Attributed string including syllables\n     */\n    return (attributedString) => {\n        const syllables = [];\n        const fragments = [];\n        const hyphenateWord = options.hyphenationCallback ||\n            engines.wordHyphenation?.() ||\n            defaultHyphenationEngine;\n        for (let i = 0; i < attributedString.runs.length; i += 1) {\n            let string = '';\n            const run = attributedString.runs[i];\n            const words = attributedString.string\n                .slice(run.start, run.end)\n                .split(/([ ]+)/g)\n                .filter(Boolean);\n            for (let j = 0; j < words.length; j += 1) {\n                const word = words[j];\n                const parts = hyphenateWord(word);\n                syllables.push(...parts);\n                string += parts.join('');\n            }\n            fragments.push({ ...run, string });\n        }\n        const result = { ...fromFragments(fragments), syllables };\n        return result;\n    };\n};\n\n/**\n * Clone rect\n *\n * @param rect - Rect\n * @returns Cloned rect\n */\nconst copy = (rect) => {\n    return Object.assign({}, rect);\n};\n\n/**\n * Partition rect in two in the vertical direction\n *\n * @param rect - Rect\n * @param height - Height\n * @returns Partitioned rects\n */\nconst partition = (rect, height) => {\n    const a = Object.assign({}, rect, { height });\n    const b = Object.assign({}, rect, {\n        y: rect.y + height,\n        height: rect.height - height,\n    });\n    return [a, b];\n};\n\n/**\n * Crop upper section of rect\n *\n * @param height - Height\n * @param rect - Rect\n * @returns Cropped rect\n */\nconst crop = (height, rect) => {\n    const [, result] = partition(rect, height);\n    return result;\n};\n\n/**\n * Get paragraph block height\n *\n * @param paragraph - Paragraph\n * @returns Paragraph block height\n */\nconst height$2 = (paragraph) => {\n    return paragraph.reduce((acc, block) => acc + block.box.height, 0);\n};\n\n/**\n * Calculate run scale\n *\n * @param run - Run\n * @returns Scale\n */\nconst calculateScale = (run) => {\n    const attributes = run.attributes || {};\n    const fontSize = attributes.fontSize || 12;\n    const font = attributes.font;\n    const unitsPerEm = typeof font === 'string' ? null : font?.[0]?.unitsPerEm;\n    return unitsPerEm ? fontSize / unitsPerEm : 0;\n};\n/**\n * Get run scale\n *\n * @param  run\n * @returns Scale\n */\nconst scale = (run) => {\n    return run.attributes?.scale || calculateScale(run);\n};\n\n/**\n * Get ligature offset by index\n *\n * Ex. ffi ligature\n *\n *   glyphs:         l  o  f  f  i  m\n *   glyphIndices:   0  1  2  2  2  3\n *   offset:         0  0  0  1  2  0\n *\n * @param index\n * @param run - Run\n * @returns Ligature offset\n */\nconst offset = (index, run) => {\n    if (!run)\n        return 0;\n    const glyphIndices = run.glyphIndices || [];\n    const value = glyphIndices[index];\n    return glyphIndices.slice(0, index).filter((i) => i === value).length;\n};\n\n/**\n * Get run font\n *\n * @param run - Run\n * @returns Font\n */\nconst getFont = (run) => {\n    return run.attributes?.font?.[0] || null;\n};\n\n/**\n * Slice glyph between codePoints range\n * Util for breaking ligatures\n *\n * @param start - Start code point index\n * @param end - End code point index\n * @param font - Font to generate new glyph\n * @param glyph - Glyph to be sliced\n * @returns Sliced glyph parts\n */\nconst slice$2 = (start, end, font, glyph) => {\n    if (!glyph)\n        return [];\n    if (start === end)\n        return [];\n    if (start === 0 && end === glyph.codePoints.length)\n        return [glyph];\n    const codePoints = glyph.codePoints.slice(start, end);\n    const string = String.fromCodePoint(...codePoints);\n    // passing LTR To force fontkit to not reverse the string\n    return font\n        ? font.layout(string, undefined, undefined, undefined, 'ltr').glyphs\n        : [glyph];\n};\n\n/**\n * Return glyph index at string index, if glyph indices present.\n * Otherwise return string index\n *\n * @param index - Index\n * @param run - Run\n * @returns Glyph index\n */\nconst glyphIndexAt = (index, run) => {\n    const result = run?.glyphIndices?.[index];\n    return (0,_react_pdf_fns__WEBPACK_IMPORTED_MODULE_0__.isNil)(result) ? index : result;\n};\n\n/**\n * Returns new array starting with zero, and keeping same relation between consecutive values\n *\n * @param array - List\n * @returns Normalized array\n */\nconst normalize = (array) => {\n    const head = array[0];\n    return array.map((value) => value - head);\n};\n\n/**\n * Slice run between glyph indices range\n *\n * @param start - Glyph index\n * @param end - Glyph index\n * @param run - Run\n * @returns Sliced run\n */\nconst slice$1 = (start, end, run) => {\n    const runScale = scale(run);\n    const font = getFont(run);\n    // Get glyph start and end indices\n    const startIndex = glyphIndexAt(start, run);\n    const endIndex = glyphIndexAt(end, run);\n    // Get start and end glyph\n    const startGlyph = run.glyphs?.[startIndex];\n    const endGlyph = run.glyphs?.[endIndex];\n    // Get start ligature chunks (if any)\n    const startOffset = offset(start, run);\n    const startGlyphs = startOffset > 0 ? slice$2(startOffset, Infinity, font, startGlyph) : [];\n    // Get end ligature chunks (if any)\n    const endOffset = offset(end, run);\n    const endGlyphs = slice$2(0, endOffset, font, endGlyph);\n    // Compute new glyphs\n    const sliceStart = startIndex + Math.min(1, startOffset);\n    const glyphs = (run.glyphs || []).slice(sliceStart, endIndex);\n    // Compute new positions\n    const glyphPosition = (g) => ({\n        xAdvance: g.advanceWidth * runScale,\n        yAdvance: 0,\n        xOffset: 0,\n        yOffset: 0,\n    });\n    const startPositions = startGlyphs.map(glyphPosition);\n    const positions = (run.positions || []).slice(sliceStart, endIndex);\n    const endPositions = endGlyphs.map(glyphPosition);\n    return Object.assign({}, run, {\n        start: run.start + start,\n        end: Math.min(run.end, run.start + end),\n        glyphIndices: normalize((run.glyphIndices || []).slice(start, end)),\n        glyphs: [startGlyphs, glyphs, endGlyphs].flat(),\n        positions: [startPositions, positions, endPositions].flat(),\n    });\n};\n\n/**\n * Get run index that contains passed index\n *\n * @param index - Index\n * @param runs - Runs\n * @returns Run index\n */\nconst runIndexAt$1 = (index, runs) => {\n    if (!runs)\n        return -1;\n    return runs.findIndex((run) => run.start <= index && index < run.end);\n};\n\n/**\n * Filter runs contained between start and end\n *\n * @param start\n * @param end\n * @param runs\n * @returns Filtered runs\n */\nconst filter = (start, end, runs) => {\n    const startIndex = runIndexAt$1(start, runs);\n    const endIndex = Math.max(runIndexAt$1(end - 1, runs), startIndex);\n    return runs.slice(startIndex, endIndex + 1);\n};\n\n/**\n * Subtract scalar to run\n *\n * @param index - Scalar\n * @param run - Run\n * @returns Subtracted run\n */\nconst subtract = (index, run) => {\n    const start = run.start - index;\n    const end = run.end - index;\n    return Object.assign({}, run, { start, end });\n};\n\n/**\n * Slice array of runs\n *\n * @param start - Offset\n * @param end - Offset\n * @param runs\n * @returns Sliced runs\n */\nconst sliceRuns = (start, end, runs) => {\n    const sliceFirstRun = (a) => slice$1(start - a.start, end - a.start, a);\n    const sliceLastRun = (a) => slice$1(0, end - a.start, a);\n    return runs.map((run, i) => {\n        let result = run;\n        const isFirst = i === 0;\n        const isLast = !isFirst && i === runs.length - 1;\n        if (isFirst)\n            result = sliceFirstRun(run);\n        if (isLast)\n            result = sliceLastRun(run);\n        return subtract(start, result);\n    });\n};\n/**\n * Slice attributed string between two indices\n *\n * @param start - Offset\n * @param end - Offset\n * @param attributedString - Attributed string\n * @returns Attributed string\n */\nconst slice = (start, end, attributedString) => {\n    if (attributedString.string.length === 0)\n        return attributedString;\n    const string = attributedString.string.slice(start, end);\n    const filteredRuns = filter(start, end, attributedString.runs);\n    const slicedRuns = sliceRuns(start, end, filteredRuns);\n    return Object.assign({}, attributedString, { string, runs: slicedRuns });\n};\n\nconst findCharIndex = (string) => {\n    return string.search(/\\S/g);\n};\nconst findLastCharIndex = (string) => {\n    const match = string.match(/\\S/g);\n    return match ? string.lastIndexOf(match[match.length - 1]) : -1;\n};\n/**\n * Removes (strips) whitespace from both ends of the attributted string.\n *\n * @param attributedString - Attributed string\n * @returns Attributed string\n */\nconst trim = (attributedString) => {\n    const start = findCharIndex(attributedString.string);\n    const end = findLastCharIndex(attributedString.string);\n    return slice(start, end + 1, attributedString);\n};\n\n/**\n * Returns empty run\n *\n * @returns Empty run\n */\nconst empty$1 = () => {\n    return {\n        start: 0,\n        end: 0,\n        glyphIndices: [],\n        glyphs: [],\n        positions: [],\n        attributes: {},\n    };\n};\n\n/**\n * Check if value is a number\n *\n * @param value - Value to check\n * @returns Whether value is a number\n */\nconst isNumber = (value) => {\n    return typeof value === 'number';\n};\n\n/**\n * Append glyph indices with given length\n *\n * Ex. appendIndices(3, [0, 1, 2, 2]) => [0, 1, 2, 2, 3, 3, 3]\n *\n * @param length - Length\n * @param indices - Glyph indices\n * @returns Extended glyph indices\n */\nconst appendIndices = (length, indices) => {\n    const lastIndex = (0,_react_pdf_fns__WEBPACK_IMPORTED_MODULE_0__.last)(indices);\n    const value = (0,_react_pdf_fns__WEBPACK_IMPORTED_MODULE_0__.isNil)(lastIndex) ? 0 : lastIndex + 1;\n    const newIndices = Array(length).fill(value);\n    return indices.concat(newIndices);\n};\n\n/**\n * Get glyph for a given code point\n *\n * @param value - CodePoint\n * @param font - Font\n * @returns Glyph\n * */\nconst fromCodePoint = (value, font) => {\n    if (typeof font === 'string')\n        return null;\n    return font && value ? font.glyphForCodePoint(value) : null;\n};\n\n/**\n * Append glyph to run\n *\n * @param glyph - Glyph\n * @param run - Run\n * @returns Run with glyph\n */\nconst appendGlyph = (glyph, run) => {\n    const glyphLength = glyph.codePoints?.length || 0;\n    const end = run.end + glyphLength;\n    const glyphs = run.glyphs.concat(glyph);\n    const glyphIndices = appendIndices(glyphLength, run.glyphIndices);\n    if (!run.positions)\n        return Object.assign({}, run, { end, glyphs, glyphIndices });\n    const positions = run.positions.concat({\n        xAdvance: glyph.advanceWidth * scale(run),\n        yAdvance: 0,\n        xOffset: 0,\n        yOffset: 0,\n    });\n    return Object.assign({}, run, { end, glyphs, glyphIndices, positions });\n};\n/**\n * Append glyph or code point to run\n *\n * @param value - Glyph or codePoint\n * @param run - Run\n * @returns Run with glyph\n */\nconst append$1 = (value, run) => {\n    if (!value)\n        return run;\n    const font = getFont(run);\n    const glyph = isNumber(value) ? fromCodePoint(value, font) : value;\n    return appendGlyph(glyph, run);\n};\n\n/**\n * Get string from array of code points\n *\n * @param codePoints - Points\n * @returns String\n */\nconst stringFromCodePoints = (codePoints) => {\n    return String.fromCodePoint(...(codePoints || []));\n};\n\n/**\n * Append glyph into last run of attributed string\n *\n * @param glyph - Glyph or code point\n * @param attributedString - Attributed string\n * @returns Attributed string with new glyph\n */\nconst append = (glyph, attributedString) => {\n    const codePoints = typeof glyph === 'number' ? [glyph] : glyph?.codePoints;\n    const codePointsString = stringFromCodePoints(codePoints || []);\n    const string = attributedString.string + codePointsString;\n    const firstRuns = attributedString.runs.slice(0, -1);\n    const lastRun = (0,_react_pdf_fns__WEBPACK_IMPORTED_MODULE_0__.last)(attributedString.runs) || empty$1();\n    const runs = firstRuns.concat(append$1(glyph, lastRun));\n    return Object.assign({}, attributedString, { string, runs });\n};\n\nconst ELLIPSIS_UNICODE = 8230;\nconst ELLIPSIS_STRING = String.fromCharCode(ELLIPSIS_UNICODE);\n/**\n * Get ellipsis codepoint. This may be different in standard and embedded fonts\n *\n * @param font\n * @returns Ellipsis codepoint\n */\nconst getEllipsisCodePoint = (font) => {\n    if (!font.encode)\n        return ELLIPSIS_UNICODE;\n    const [codePoints] = font.encode(ELLIPSIS_STRING);\n    return parseInt(codePoints[0], 16);\n};\n/**\n * Trucante block with ellipsis\n *\n * @param paragraph - Paragraph\n * @returns Sliced paragraph\n */\nconst truncate = (paragraph) => {\n    const runs = (0,_react_pdf_fns__WEBPACK_IMPORTED_MODULE_0__.last)(paragraph)?.runs || [];\n    const font = (0,_react_pdf_fns__WEBPACK_IMPORTED_MODULE_0__.last)(runs)?.attributes?.font[0];\n    if (font) {\n        const index = paragraph.length - 1;\n        const codePoint = getEllipsisCodePoint(font);\n        const glyph = font.glyphForCodePoint(codePoint);\n        const lastBlock = append(glyph, trim(paragraph[index]));\n        return Object.assign([], paragraph, { [index]: lastBlock });\n    }\n    return paragraph;\n};\n\n/**\n * Omit attribute from run\n *\n * @param value - Attribute key\n * @param run - Run\n * @returns Run without ommited attribute\n */\nconst omit = (value, run) => {\n    const attributes = Object.assign({}, run.attributes);\n    delete attributes[value];\n    return Object.assign({}, run, { attributes });\n};\n\n/**\n * Get run ascent\n *\n * @param run - Run\n * @returns Ascent\n */\nconst ascent$1 = (run) => {\n    const { font, attachment } = run.attributes;\n    const attachmentHeight = attachment?.height || 0;\n    const fontAscent = typeof font === 'string' ? 0 : font?.[0]?.ascent || 0;\n    return Math.max(attachmentHeight, fontAscent * scale(run));\n};\n\n/**\n * Get run descent\n *\n * @param run - Run\n * @returns Descent\n */\nconst descent = (run) => {\n    const font = run.attributes?.font;\n    const fontDescent = typeof font === 'string' ? 0 : font?.[0]?.descent || 0;\n    return scale(run) * fontDescent;\n};\n\n/**\n * Get run lineGap\n *\n * @param run - Run\n * @returns LineGap\n */\nconst lineGap = (run) => {\n    const font = run.attributes?.font;\n    const lineGap = typeof font === 'string' ? 0 : font?.[0]?.lineGap || 0;\n    return lineGap * scale(run);\n};\n\n/**\n * Get run height\n *\n * @param run - Run\n * @returns Height\n */\nconst height$1 = (run) => {\n    const lineHeight = run.attributes?.lineHeight;\n    return lineHeight || lineGap(run) + ascent$1(run) - descent(run);\n};\n\n/**\n * Returns attributed string height\n *\n * @param attributedString - Attributed string\n * @returns Height\n */\nconst height = (attributedString) => {\n    const reducer = (acc, run) => Math.max(acc, height$1(run));\n    return attributedString.runs.reduce(reducer, 0);\n};\n\n/**\n * Checks if two rects intersect each other\n *\n * @param a - Rect A\n * @param b - Rect B\n * @returns Whether rects intersect\n */\nconst intersects = (a, b) => {\n    const x = Math.max(a.x, b.x);\n    const num1 = Math.min(a.x + a.width, b.x + b.width);\n    const y = Math.max(a.y, b.y);\n    const num2 = Math.min(a.y + a.height, b.y + b.height);\n    return num1 >= x && num2 >= y;\n};\n\nconst getLineFragment = (lineRect, excludeRect) => {\n    if (!intersects(excludeRect, lineRect))\n        return [lineRect];\n    const eStart = excludeRect.x;\n    const eEnd = excludeRect.x + excludeRect.width;\n    const lStart = lineRect.x;\n    const lEnd = lineRect.x + lineRect.width;\n    const a = Object.assign({}, lineRect, { width: eStart - lStart });\n    const b = Object.assign({}, lineRect, { x: eEnd, width: lEnd - eEnd });\n    return [a, b].filter((r) => r.width > 0);\n};\nconst getLineFragments = (rect, excludeRects) => {\n    let fragments = [rect];\n    for (let i = 0; i < excludeRects.length; i += 1) {\n        const excludeRect = excludeRects[i];\n        fragments = fragments.reduce((acc, fragment) => {\n            const pieces = getLineFragment(fragment, excludeRect);\n            return acc.concat(pieces);\n        }, []);\n    }\n    return fragments;\n};\nconst generateLineRects = (container, height) => {\n    const { excludeRects, ...rect } = container;\n    if (!excludeRects)\n        return [rect];\n    const lineRects = [];\n    const maxY = Math.max(...excludeRects.map((r) => r.y + r.height));\n    let currentRect = rect;\n    while (currentRect.y < maxY) {\n        const [lineRect, rest] = partition(currentRect, height);\n        const lineRectFragments = getLineFragments(lineRect, excludeRects);\n        currentRect = rest;\n        lineRects.push(...lineRectFragments);\n    }\n    return [...lineRects, currentRect];\n};\n\nconst ATTACHMENT_CODE$1 = '\\ufffc'; // 65532\n/**\n * Remove attachment attribute if no char present\n *\n * @param line - Line\n * @returns Line\n */\nconst purgeAttachments = (line) => {\n    const shouldPurge = !line.string.includes(ATTACHMENT_CODE$1);\n    if (!shouldPurge)\n        return line;\n    const runs = line.runs.map((run) => omit('attachment', run));\n    return Object.assign({}, line, { runs });\n};\n/**\n * Layout paragraphs inside rectangle\n *\n * @param rects - Rects\n * @param lines - Attributed strings\n * @param indent\n * @returns layout blocks\n */\nconst layoutLines = (rects, lines, indent) => {\n    let rect = rects.shift();\n    let currentY = rect.y;\n    return lines.map((line, i) => {\n        const lineIndent = i === 0 ? indent : 0;\n        const style = line.runs?.[0]?.attributes || {};\n        const height$1 = Math.max(height(line), style.lineHeight);\n        if (currentY + height$1 > rect.y + rect.height && rects.length > 0) {\n            rect = rects.shift();\n            currentY = rect.y;\n        }\n        const newLine = {\n            string: line.string,\n            runs: line.runs,\n            box: {\n                x: rect.x + lineIndent,\n                y: currentY,\n                width: rect.width - lineIndent,\n                height: height$1,\n            },\n        };\n        currentY += height$1;\n        return purgeAttachments(newLine);\n    });\n};\n/**\n * Performs line breaking and layout\n *\n * @param engines - Engines\n * @param options - Layout options\n */\nconst layoutParagraph = (engines, options = {}) => {\n    /**\n     * @param container - Container\n     * @param paragraph - Attributed string\n     * @returns Layout block\n     */\n    return (container, paragraph) => {\n        const height$1 = height(paragraph);\n        const indent = paragraph.runs?.[0]?.attributes?.indent || 0;\n        const rects = generateLineRects(container, height$1);\n        const availableWidths = rects.map((r) => r.width);\n        availableWidths.unshift(availableWidths[0] - indent);\n        const lines = engines.linebreaker(options)(paragraph, availableWidths);\n        return layoutLines(rects, lines, indent);\n    };\n};\n\n/**\n * Slice block at given height\n *\n * @param height - Height\n * @param paragraph - Paragraph\n * @returns Sliced paragraph\n */\nconst sliceAtHeight = (height, paragraph) => {\n    const newBlock = [];\n    let counter = 0;\n    for (let i = 0; i < paragraph.length; i += 1) {\n        const line = paragraph[i];\n        counter += line.box.height;\n        if (counter < height) {\n            newBlock.push(line);\n        }\n        else {\n            break;\n        }\n    }\n    return newBlock;\n};\n\n/**\n * Layout paragraphs inside container until it does not\n * fit anymore, performing line wrapping in the process.\n *\n * @param  engines - Engines\n * @param  options - Layout options\n * @param container - Container\n */\nconst typesetter = (engines, options, container) => {\n    /**\n     * @param attributedStrings - Attributed strings (paragraphs)\n     * @returns Paragraph blocks\n     */\n    return (attributedStrings) => {\n        const result = [];\n        const paragraphs = [...attributedStrings];\n        const layout = layoutParagraph(engines, options);\n        const maxLines = (0,_react_pdf_fns__WEBPACK_IMPORTED_MODULE_0__.isNil)(container.maxLines) ? Infinity : container.maxLines;\n        const truncateEllipsis = container.truncateMode === 'ellipsis';\n        let linesCount = maxLines;\n        let paragraphRect = copy(container);\n        let nextParagraph = paragraphs.shift();\n        while (linesCount > 0 && nextParagraph) {\n            const paragraph = layout(paragraphRect, nextParagraph);\n            const slicedBlock = paragraph.slice(0, linesCount);\n            const linesHeight = height$2(slicedBlock);\n            const shouldTruncate = truncateEllipsis && paragraph.length !== slicedBlock.length;\n            linesCount -= slicedBlock.length;\n            if (paragraphRect.height >= linesHeight) {\n                result.push(shouldTruncate ? truncate(slicedBlock) : slicedBlock);\n                paragraphRect = crop(linesHeight, paragraphRect);\n                nextParagraph = paragraphs.shift();\n            }\n            else {\n                result.push(truncate(sliceAtHeight(paragraphRect.height, slicedBlock)));\n                break;\n            }\n        }\n        return result;\n    };\n};\n\n/**\n * Get attributed string start value\n *\n * @param attributedString - Attributed string\n * @returns Start\n */\nconst start = (attributedString) => {\n    const { runs } = attributedString;\n    return runs.length === 0 ? 0 : runs[0].start;\n};\n\n/**\n * Get attributed string end value\n *\n * @param attributedString - Attributed string\n * @returns End\n */\nconst end = (attributedString) => {\n    const { runs } = attributedString;\n    return runs.length === 0 ? 0 : (0,_react_pdf_fns__WEBPACK_IMPORTED_MODULE_0__.last)(runs).end;\n};\n\n/**\n * Get attributed string length\n *\n * @param attributedString - Attributed string\n * @returns End\n */\nconst length$1 = (attributedString) => {\n    return end(attributedString) - start(attributedString);\n};\n\nconst bidi$2 = bidi_js__WEBPACK_IMPORTED_MODULE_1__();\nconst getBidiLevels$1 = (runs) => {\n    return runs.reduce((acc, run) => {\n        const length = run.end - run.start;\n        const levels = (0,_react_pdf_fns__WEBPACK_IMPORTED_MODULE_0__.repeat)(run.attributes.bidiLevel, length);\n        return acc.concat(levels);\n    }, []);\n};\nconst getReorderedIndices = (string, segments) => {\n    // Fill an array with indices\n    const indices = [];\n    for (let i = 0; i < string.length; i += 1) {\n        indices[i] = i;\n    }\n    // Reverse each segment in order\n    segments.forEach(([start, end]) => {\n        const slice = indices.slice(start, end + 1);\n        for (let i = slice.length - 1; i >= 0; i -= 1) {\n            indices[end - i] = slice[i];\n        }\n    });\n    return indices;\n};\nconst getItemAtIndex = (runs, objectName, index) => {\n    for (let i = 0; i < runs.length; i += 1) {\n        const run = runs[i];\n        const updatedIndex = run.glyphIndices[index - run.start];\n        if (index >= run.start && index < run.end) {\n            return run[objectName][updatedIndex];\n        }\n    }\n    throw new Error(`index ${index} out of range`);\n};\nconst reorderLine = (line) => {\n    const levels = getBidiLevels$1(line.runs);\n    const direction = line.runs[0]?.attributes.direction;\n    const level = direction === 'rtl' ? 1 : 0;\n    const end = length$1(line) - 1;\n    const paragraphs = [{ start: 0, end, level }];\n    const embeddingLevels = { paragraphs, levels };\n    const segments = bidi$2.getReorderSegments(line.string, embeddingLevels);\n    // No need for bidi reordering\n    if (segments.length === 0)\n        return line;\n    const indices = getReorderedIndices(line.string, segments);\n    const updatedString = bidi$2.getReorderedString(line.string, embeddingLevels);\n    const updatedRuns = line.runs.map((run) => {\n        const selectedIndices = indices.slice(run.start, run.end);\n        const updatedGlyphs = [];\n        const updatedPositions = [];\n        const addedGlyphs = new Set();\n        for (let i = 0; i < selectedIndices.length; i += 1) {\n            const index = selectedIndices[i];\n            const glyph = getItemAtIndex(line.runs, 'glyphs', index);\n            if (addedGlyphs.has(glyph.id))\n                continue;\n            updatedGlyphs.push(glyph);\n            updatedPositions.push(getItemAtIndex(line.runs, 'positions', index));\n            if (glyph.isLigature) {\n                addedGlyphs.add(glyph.id);\n            }\n        }\n        return {\n            ...run,\n            glyphs: updatedGlyphs,\n            positions: updatedPositions,\n        };\n    });\n    return {\n        box: line.box,\n        runs: updatedRuns,\n        string: updatedString,\n    };\n};\nconst reorderParagraph = (paragraph) => paragraph.map(reorderLine);\n/**\n * Perform bidi reordering\n *\n * @returns Reordered paragraphs\n */\nconst bidiReordering = () => {\n    /**\n     * @param paragraphs - Paragraphs\n     * @returns Reordered paragraphs\n     */\n    return (paragraphs) => paragraphs.map(reorderParagraph);\n};\n\nconst DUMMY_CODEPOINT = 123;\n/**\n * Resolve string indices based on glyphs code points\n *\n * @param glyphs\n * @returns Glyph indices\n */\nconst resolve = (glyphs = []) => {\n    return glyphs.reduce((acc, glyph) => {\n        const codePoints = glyph?.codePoints || [DUMMY_CODEPOINT];\n        if (acc.length === 0)\n            return codePoints.map(() => 0);\n        const last = acc[acc.length - 1];\n        const next = codePoints.map(() => last + 1);\n        return [...acc, ...next];\n    }, []);\n};\n\nconst getCharacterSpacing = (run) => {\n    return run.attributes?.characterSpacing || 0;\n};\n/**\n * Scale run positions\n *\n * @param  run\n * @param  positions\n * @returns Scaled positions\n */\nconst scalePositions = (run, positions) => {\n    const runScale = scale(run);\n    const characterSpacing = getCharacterSpacing(run);\n    return positions.map((position, i) => {\n        const isLast = i === positions.length;\n        const xSpacing = isLast ? 0 : characterSpacing;\n        return Object.assign({}, position, {\n            xAdvance: position.xAdvance * runScale + xSpacing,\n            yAdvance: position.yAdvance * runScale,\n            xOffset: position.xOffset * runScale,\n            yOffset: position.yOffset * runScale,\n        });\n    });\n};\n/**\n * Create glyph run\n *\n * @param string string\n */\nconst layoutRun = (string) => {\n    /**\n     * @param run - Run\n     * @returns Glyph run\n     */\n    return (run) => {\n        const { start, end, attributes = {} } = run;\n        const { font } = attributes;\n        if (!font)\n            return { ...run, glyphs: [], glyphIndices: [], positions: [] };\n        const runString = string.slice(start, end);\n        if (typeof font === 'string')\n            throw new Error('Invalid font');\n        // passing LTR To force fontkit to not reverse the string\n        const glyphRun = font[0].layout(runString, undefined, undefined, undefined, 'ltr');\n        const positions = scalePositions(run, glyphRun.positions);\n        const glyphIndices = resolve(glyphRun.glyphs);\n        const result = {\n            ...run,\n            positions,\n            glyphIndices,\n            glyphs: glyphRun.glyphs,\n        };\n        return result;\n    };\n};\n/**\n * Generate glyphs for single attributed string\n */\nconst generateGlyphs = () => {\n    /**\n     * @param attributedString - Attributed string\n     * @returns Attributed string with glyphs\n     */\n    return (attributedString) => {\n        const runs = attributedString.runs.map(layoutRun(attributedString.string));\n        const res = Object.assign({}, attributedString, { runs });\n        return res;\n    };\n};\n\n/**\n * Resolves yOffset for run\n *\n * @param run - Run\n * @returns Run\n */\nconst resolveRunYOffset = (run) => {\n    if (!run.positions)\n        return run;\n    const unitsPerEm = run.attributes?.font?.[0]?.unitsPerEm || 0;\n    const yOffset = (run.attributes?.yOffset || 0) * unitsPerEm;\n    const positions = run.positions.map((p) => Object.assign({}, p, { yOffset }));\n    return Object.assign({}, run, { positions });\n};\n/**\n * Resolves yOffset for multiple paragraphs\n */\nconst resolveYOffset = () => {\n    /**\n     * @param attributedString - Attributed string\n     * @returns Attributed string\n     */\n    return (attributedString) => {\n        const runs = attributedString.runs.map(resolveRunYOffset);\n        const res = Object.assign({}, attributedString, { runs });\n        return res;\n    };\n};\n\n/**\n * Sort runs in ascending order\n *\n * @param runs\n * @returns Sorted runs\n */\nconst sort = (runs) => {\n    return runs.sort((a, b) => a.start - b.start || a.end - b.end);\n};\n\n/**\n * Is run empty (start === end)\n *\n * @param run - Run\n * @returns Is run empty\n */\nconst isEmpty = (run) => {\n    return run.start === run.end;\n};\n\n/**\n * Sort points in ascending order\n * @param a - First point\n * @param b - Second point\n * @returns Sort order\n */\nconst sortPoints = (a, b) => {\n    return a[1] - b[1] || a[3] - b[3];\n};\n/**\n * @param runs\n * @returns Points\n */\nconst generatePoints = (runs) => {\n    const result = runs.reduce((acc, run, i) => {\n        return acc.concat([\n            ['start', run.start, run.attributes, i],\n            ['end', run.end, run.attributes, i],\n        ]);\n    }, []);\n    return result.sort(sortPoints);\n};\n/**\n * @param runs\n * @returns Merged runs\n */\nconst mergeRuns = (runs) => {\n    return runs.reduce((acc, run) => {\n        const attributes = Object.assign({}, acc.attributes, run.attributes);\n        return Object.assign({}, run, { attributes });\n    }, {});\n};\n/**\n * @param runs\n * @returns Grouped runs\n */\nconst groupEmptyRuns = (runs) => {\n    const groups = runs.reduce((acc, run) => {\n        if (!acc[run.start])\n            acc[run.start] = [];\n        acc[run.start].push(run);\n        return acc;\n    }, []);\n    return Object.values(groups);\n};\n/**\n * @param runs\n * @returns Flattened runs\n */\nconst flattenEmptyRuns = (runs) => {\n    return groupEmptyRuns(runs).map(mergeRuns);\n};\n/**\n * @param runs\n * @returns Flattened runs\n */\nconst flattenRegularRuns = (runs) => {\n    const res = [];\n    const points = generatePoints(runs);\n    let start = -1;\n    let attrs = {};\n    const stack = [];\n    for (let i = 0; i < points.length; i += 1) {\n        const [type, offset, attributes] = points[i];\n        if (start !== -1 && start < offset) {\n            res.push({\n                start,\n                end: offset,\n                attributes: attrs,\n                glyphIndices: [],\n                glyphs: [],\n                positions: [],\n            });\n        }\n        if (type === 'start') {\n            stack.push(attributes);\n            attrs = Object.assign({}, attrs, attributes);\n        }\n        else {\n            attrs = {};\n            for (let j = 0; j < stack.length; j += 1) {\n                if (stack[j] === attributes) {\n                    stack.splice(j--, 1);\n                }\n                else {\n                    attrs = Object.assign({}, attrs, stack[j]);\n                }\n            }\n        }\n        start = offset;\n    }\n    return res;\n};\n/**\n * Flatten many runs\n *\n * @param runs\n * @returns Flattened runs\n */\nconst flatten = (runs = []) => {\n    const emptyRuns = flattenEmptyRuns(runs.filter((run) => isEmpty(run)));\n    const regularRuns = flattenRegularRuns(runs.filter((run) => !isEmpty(run)));\n    return sort(emptyRuns.concat(regularRuns));\n};\n\n/**\n * Returns empty attributed string\n *\n * @returns Empty attributed string\n */\nconst empty = () => ({ string: '', runs: [] });\n\n/**\n *\n * @param attributedString\n * @returns Attributed string without font\n */\nconst omitFont = (attributedString) => {\n    const runs = attributedString.runs.map((run) => omit('font', run));\n    return Object.assign({}, attributedString, { runs });\n};\n/**\n * Performs font substitution and script itemization on attributed string\n *\n * @param engines - engines\n */\nconst preprocessRuns = (engines) => {\n    /**\n     * @param attributedString - Attributed string\n     * @returns Processed attributed string\n     */\n    return (attributedString) => {\n        if ((0,_react_pdf_fns__WEBPACK_IMPORTED_MODULE_0__.isNil)(attributedString))\n            return empty();\n        const { string } = attributedString;\n        const { fontSubstitution, scriptItemizer, bidi } = engines;\n        const { runs: omittedFontRuns } = omitFont(attributedString);\n        const { runs: itemizationRuns } = scriptItemizer()(attributedString);\n        const { runs: substitutedRuns } = fontSubstitution()(attributedString);\n        const { runs: bidiRuns } = bidi()(attributedString);\n        const runs = bidiRuns\n            .concat(substitutedRuns)\n            .concat(itemizationRuns)\n            .concat(omittedFontRuns);\n        return { string, runs: flatten(runs) };\n    };\n};\n\n/**\n * Breaks attributed string into paragraphs\n */\nconst splitParagraphs = () => {\n    /**\n     * @param attributedString - Attributed string\n     * @returns Paragraphs attributed strings\n     */\n    return (attributedString) => {\n        const paragraphs = [];\n        let start = 0;\n        let breakPoint = attributedString.string.indexOf('\\n') + 1;\n        while (breakPoint > 0) {\n            paragraphs.push(slice(start, breakPoint, attributedString));\n            start = breakPoint;\n            breakPoint = attributedString.string.indexOf('\\n', breakPoint) + 1;\n        }\n        if (start === 0) {\n            paragraphs.push(attributedString);\n        }\n        else if (start < attributedString.string.length) {\n            paragraphs.push(slice(start, length$1(attributedString), attributedString));\n        }\n        return paragraphs;\n    };\n};\n\n/**\n * Return positions advance width\n *\n * @param positions - Positions\n * @returns {number} advance width\n */\nconst advanceWidth$2 = (positions) => {\n    return positions.reduce((acc, pos) => acc + (pos.xAdvance || 0), 0);\n};\n\n/**\n * Return run advance width\n *\n * @param run - Run\n * @returns Advance width\n */\nconst advanceWidth$1 = (run) => {\n    return advanceWidth$2(run.positions || []);\n};\n\n/**\n * Returns attributed string advancewidth\n *\n * @param attributedString - Attributed string\n * @returns Advance width\n */\nconst advanceWidth = (attributedString) => {\n    const reducer = (acc, run) => acc + advanceWidth$1(run);\n    return attributedString.runs.reduce(reducer, 0);\n};\n\nconst WHITE_SPACES_CODE = 32;\n/**\n * Check if glyph is white space\n *\n * @param glyph - Glyph\n * @returns Whether glyph is white space\n * */\nconst isWhiteSpace = (glyph) => {\n    const codePoints = glyph?.codePoints || [];\n    return codePoints.includes(WHITE_SPACES_CODE);\n};\n\n/**\n * Get white space leading positions\n *\n * @param run - Run\n * @returns White space leading positions\n */\nconst leadingPositions = (run) => {\n    const glyphs = run.glyphs || [];\n    const positions = run.positions || [];\n    const leadingWhitespaces = glyphs.findIndex((g) => !isWhiteSpace(g));\n    return positions.slice(0, leadingWhitespaces);\n};\n/**\n * Get run leading white space offset\n *\n * @param run - Run\n * @returns Leading white space offset\n */\nconst leadingOffset$1 = (run) => {\n    const positions = leadingPositions(run);\n    return positions.reduce((acc, pos) => acc + (pos.xAdvance || 0), 0);\n};\n\n/**\n * Get attributed string leading white space offset\n *\n * @param attributedString - Attributed string\n * @returns Leading white space offset\n */\nconst leadingOffset = (attributedString) => {\n    const runs = attributedString.runs || [];\n    return leadingOffset$1(runs[0]);\n};\n\n/**\n * Get white space trailing positions\n *\n * @param run run\n * @returns White space trailing positions\n */\nconst trailingPositions = (run) => {\n    const glyphs = (0,_react_pdf_fns__WEBPACK_IMPORTED_MODULE_0__.reverse)(run.glyphs || []);\n    const positions = (0,_react_pdf_fns__WEBPACK_IMPORTED_MODULE_0__.reverse)(run.positions || []);\n    const leadingWhitespaces = glyphs.findIndex((g) => !isWhiteSpace(g));\n    return positions.slice(0, leadingWhitespaces);\n};\n/**\n * Get run trailing white space offset\n *\n * @param run - Run\n * @returns Trailing white space offset\n */\nconst trailingOffset$1 = (run) => {\n    const positions = trailingPositions(run);\n    return positions.reduce((acc, pos) => acc + (pos.xAdvance || 0), 0);\n};\n\n/**\n * Get attributed string trailing white space offset\n *\n * @param attributedString - Attributed string\n * @returns Trailing white space offset\n */\nconst trailingOffset = (attributedString) => {\n    const runs = attributedString.runs || [];\n    return trailingOffset$1((0,_react_pdf_fns__WEBPACK_IMPORTED_MODULE_0__.last)(runs));\n};\n\n/**\n * Drop last char of run\n *\n * @param run - Run\n * @returns Run without last char\n */\nconst dropLast$1 = (run) => {\n    return slice$1(0, run.end - run.start - 1, run);\n};\n\n/**\n * Drop last glyph\n *\n * @param attributedString - Attributed string\n * @returns Attributed string with new glyph\n */\nconst dropLast = (attributedString) => {\n    const string = (0,_react_pdf_fns__WEBPACK_IMPORTED_MODULE_0__.dropLast)(attributedString.string);\n    const runs = (0,_react_pdf_fns__WEBPACK_IMPORTED_MODULE_0__.adjust)(-1, dropLast$1, attributedString.runs);\n    return Object.assign({}, attributedString, { string, runs });\n};\n\nconst ALIGNMENT_FACTORS = { center: 0.5, right: 1 };\n/**\n * Remove new line char at the end of line if present\n *\n * @param line\n * @returns Line\n */\nconst removeNewLine = (line) => {\n    return (0,_react_pdf_fns__WEBPACK_IMPORTED_MODULE_0__.last)(line.string) === '\\n' ? dropLast(line) : line;\n};\nconst getOverflowLeft = (line) => {\n    return leadingOffset(line) + (line.overflowLeft || 0);\n};\nconst getOverflowRight = (line) => {\n    return trailingOffset(line) + (line.overflowRight || 0);\n};\n/**\n * Ignore whitespace at the start and end of a line for alignment\n *\n * @param line\n * @returns Line\n */\nconst adjustOverflow = (line) => {\n    const overflowLeft = getOverflowLeft(line);\n    const overflowRight = getOverflowRight(line);\n    const x = line.box.x - overflowLeft;\n    const width = line.box.width + overflowLeft + overflowRight;\n    const box = Object.assign({}, line.box, { x, width });\n    return Object.assign({}, line, { box, overflowLeft, overflowRight });\n};\n/**\n * Performs line justification by calling appropiate engine\n *\n * @param engines - Engines\n * @param options - Layout options\n * @param align - Text align\n */\nconst justifyLine$1 = (engines, options, align) => {\n    /**\n     * @param line - Line\n     * @returns Line\n     */\n    return (line) => {\n        const lineWidth = advanceWidth(line);\n        const alignFactor = ALIGNMENT_FACTORS[align] || 0;\n        const remainingWidth = Math.max(0, line.box.width - lineWidth);\n        const shouldJustify = align === 'justify' || lineWidth > line.box.width;\n        const x = line.box.x + remainingWidth * alignFactor;\n        const box = Object.assign({}, line.box, { x });\n        const newLine = Object.assign({}, line, { box });\n        return shouldJustify ? engines.justification(options)(newLine) : newLine;\n    };\n};\nconst finalizeLine = (line) => {\n    let lineAscent = 0;\n    let lineDescent = 0;\n    let lineHeight = 0;\n    let lineXAdvance = 0;\n    const runs = line.runs.map((run) => {\n        const height = height$1(run);\n        const ascent = ascent$1(run);\n        const descent$1 = descent(run);\n        const xAdvance = advanceWidth$1(run);\n        lineHeight = Math.max(lineHeight, height);\n        lineAscent = Math.max(lineAscent, ascent);\n        lineDescent = Math.max(lineDescent, descent$1);\n        lineXAdvance += xAdvance;\n        return Object.assign({}, run, { height, ascent, descent: descent$1, xAdvance });\n    });\n    return Object.assign({}, line, {\n        runs,\n        height: lineHeight,\n        ascent: lineAscent,\n        descent: lineDescent,\n        xAdvance: lineXAdvance,\n    });\n};\n/**\n * Finalize line by performing line justification\n * and text decoration (using appropiate engines)\n *\n * @param engines - Engines\n * @param options - Layout options\n */\nconst finalizeBlock = (engines, options) => {\n    /**\n     * @param line - Line\n     * @param i - Line index\n     * @param lines - Total lines\n     * @returns Line\n     */\n    return (line, index, lines) => {\n        const isLastFragment = index === lines.length - 1;\n        const style = line.runs?.[0]?.attributes || {};\n        const align = isLastFragment ? style.alignLastLine : style.align;\n        return (0,_react_pdf_fns__WEBPACK_IMPORTED_MODULE_0__.compose)(finalizeLine, engines.textDecoration(), justifyLine$1(engines, options, align), adjustOverflow, removeNewLine)(line);\n    };\n};\n/**\n * Finalize line block by performing line justification\n * and text decoration (using appropiate engines)\n *\n * @param engines - Engines\n * @param options - Layout options\n */\nconst finalizeFragments = (engines, options) => {\n    /**\n     * @param paragraphs - Paragraphs\n     * @returns Paragraphs\n     */\n    return (paragraphs) => {\n        const blockFinalizer = finalizeBlock(engines, options);\n        return paragraphs.map((paragraph) => paragraph.map(blockFinalizer));\n    };\n};\n\nconst ATTACHMENT_CODE = 0xfffc; // 65532\nconst isReplaceGlyph = (glyph) => glyph.codePoints.includes(ATTACHMENT_CODE);\n/**\n * Resolve attachments of run\n *\n * @param run\n * @returns Run\n */\nconst resolveRunAttachments = (run) => {\n    if (!run.positions)\n        return run;\n    const glyphs = run.glyphs || [];\n    const attachment = run.attributes?.attachment;\n    if (!attachment)\n        return run;\n    const positions = run.positions.map((position, i) => {\n        const glyph = glyphs[i];\n        if (attachment.width && isReplaceGlyph(glyph)) {\n            return Object.assign({}, position, { xAdvance: attachment.width });\n        }\n        return Object.assign({}, position);\n    });\n    return Object.assign({}, run, { positions });\n};\n/**\n * Resolve attachments for multiple paragraphs\n */\nconst resolveAttachments = () => {\n    /**\n     * @param attributedString - Attributed string\n     * @returns Attributed string\n     */\n    return (attributedString) => {\n        const runs = attributedString.runs.map(resolveRunAttachments);\n        const res = Object.assign({}, attributedString, { runs });\n        return res;\n    };\n};\n\n/**\n * @param attributes - Attributes\n * @returns Attributes with defaults\n */\nconst applyAttributes = (a) => {\n    return {\n        align: a.align || (a.direction === 'rtl' ? 'right' : 'left'),\n        alignLastLine: a.alignLastLine || (a.align === 'justify' ? 'left' : a.align || 'left'),\n        attachment: a.attachment || null,\n        backgroundColor: a.backgroundColor || null,\n        bullet: a.bullet || null,\n        characterSpacing: a.characterSpacing || 0,\n        color: a.color || 'black',\n        direction: a.direction || 'ltr',\n        features: a.features || [],\n        fill: a.fill !== false,\n        font: a.font || [],\n        fontSize: a.fontSize || 12,\n        hangingPunctuation: a.hangingPunctuation || false,\n        hyphenationFactor: a.hyphenationFactor || 0,\n        indent: a.indent || 0,\n        justificationFactor: a.justificationFactor || 1,\n        lineHeight: a.lineHeight || null,\n        lineSpacing: a.lineSpacing || 0,\n        link: a.link || null,\n        marginLeft: a.marginLeft || a.margin || 0,\n        marginRight: a.marginRight || a.margin || 0,\n        opacity: a.opacity,\n        paddingTop: a.paddingTop || a.padding || 0,\n        paragraphSpacing: a.paragraphSpacing || 0,\n        script: a.script || null,\n        shrinkFactor: a.shrinkFactor || 0,\n        strike: a.strike || false,\n        strikeColor: a.strikeColor || a.color || 'black',\n        strikeStyle: a.strikeStyle || 'solid',\n        stroke: a.stroke || false,\n        underline: a.underline || false,\n        underlineColor: a.underlineColor || a.color || 'black',\n        underlineStyle: a.underlineStyle || 'solid',\n        verticalAlign: a.verticalAlign || null,\n        wordSpacing: a.wordSpacing || 0,\n        yOffset: a.yOffset || 0,\n    };\n};\n/**\n * Apply default style to run\n *\n * @param run - Run\n * @returns Run with default styles\n */\nconst applyRunStyles = (run) => {\n    const attributes = applyAttributes(run.attributes);\n    return Object.assign({}, run, { attributes });\n};\n/**\n * Apply default attributes for an attributed string\n */\nconst applyDefaultStyles = () => {\n    return (attributedString) => {\n        const string = attributedString.string || '';\n        const runs = (attributedString.runs || []).map(applyRunStyles);\n        return { string, runs };\n    };\n};\n\n/**\n * Apply scaling and yOffset for verticalAlign 'sub' and 'super'.\n */\nconst verticalAlignment = () => {\n    /**\n     * @param attributedString - Attributed string\n     * @returns Attributed string\n     */\n    return (attributedString) => {\n        attributedString.runs.forEach((run) => {\n            const { attributes } = run;\n            const { verticalAlign } = attributes;\n            if (verticalAlign === 'sub') {\n                attributes.yOffset = -0.2;\n            }\n            else if (verticalAlign === 'super') {\n                attributes.yOffset = 0.4;\n            }\n        });\n        return attributedString;\n    };\n};\n\nconst bidi$1 = bidi_js__WEBPACK_IMPORTED_MODULE_1__();\n/**\n * @param runs\n * @returns Bidi levels\n */\nconst getBidiLevels = (runs) => {\n    return runs.reduce((acc, run) => {\n        const length = run.end - run.start;\n        const levels = (0,_react_pdf_fns__WEBPACK_IMPORTED_MODULE_0__.repeat)(run.attributes.bidiLevel, length);\n        return acc.concat(levels);\n    }, []);\n};\n/**\n * Perform bidi mirroring\n */\nconst mirrorString = () => {\n    /**\n     * @param attributedString - Attributed string\n     * @returns Attributed string\n     */\n    return (attributedString) => {\n        const levels = getBidiLevels(attributedString.runs);\n        let updatedString = '';\n        attributedString.string.split('').forEach((char, index) => {\n            const isRTL = levels[index] % 2 === 1;\n            const mirroredChar = isRTL\n                ? bidi$1.getMirroredCharacter(attributedString.string.charAt(index))\n                : null;\n            updatedString += mirroredChar || char;\n        });\n        const result = {\n            ...attributedString,\n            string: updatedString,\n        };\n        return result;\n    };\n};\n\n/**\n * A LayoutEngine is the main object that performs text layout.\n * It accepts an AttributedString and a Container object\n * to layout text into, and uses several helper objects to perform\n * various layout tasks. These objects can be overridden to customize\n * layout behavior.\n */\nconst layoutEngine = (engines) => {\n    return (attributedString, container, options = {}) => {\n        const processParagraph = (0,_react_pdf_fns__WEBPACK_IMPORTED_MODULE_0__.compose)(resolveYOffset(), resolveAttachments(), verticalAlignment(), wrapWords(engines, options), generateGlyphs(), mirrorString(), preprocessRuns(engines));\n        const processParagraphs = (paragraphs) => paragraphs.map(processParagraph);\n        return (0,_react_pdf_fns__WEBPACK_IMPORTED_MODULE_0__.compose)(finalizeFragments(engines, options), bidiReordering(), typesetter(engines, options, container), processParagraphs, splitParagraphs(), applyDefaultStyles())(attributedString);\n    };\n};\n\nconst bidi = bidi_js__WEBPACK_IMPORTED_MODULE_1__();\nconst bidiEngine = () => {\n    /**\n     * @param attributedString - Attributed string\n     * @returns Attributed string\n     */\n    return (attributedString) => {\n        const { string } = attributedString;\n        const direction = attributedString.runs[0]?.attributes.direction;\n        const { levels } = bidi.getEmbeddingLevels(string, direction);\n        let lastLevel = null;\n        let lastIndex = 0;\n        let index = 0;\n        const runs = [];\n        for (let i = 0; i < levels.length; i += 1) {\n            const level = levels[i];\n            if (level !== lastLevel) {\n                if (lastLevel !== null) {\n                    runs.push({\n                        start: lastIndex,\n                        end: index,\n                        attributes: { bidiLevel: lastLevel },\n                    });\n                }\n                lastIndex = index;\n                lastLevel = level;\n            }\n            index += 1;\n        }\n        if (lastIndex < string.length) {\n            runs.push({\n                start: lastIndex,\n                end: string.length,\n                attributes: { bidiLevel: lastLevel },\n            });\n        }\n        const result = { string, runs };\n        return result;\n    };\n};\n\nconst INFINITY = 10000;\nconst getNextBreakpoint = (subnodes, widths, lineNumber) => {\n    let position = null;\n    let minimumBadness = Infinity;\n    const sum = { width: 0, stretch: 0, shrink: 0 };\n    const lineLength = widths[Math.min(lineNumber, widths.length - 1)];\n    const calculateRatio = (node) => {\n        const stretch = 'stretch' in node ? node.stretch : null;\n        if (sum.width < lineLength) {\n            if (!stretch)\n                return INFINITY;\n            return sum.stretch - stretch > 0\n                ? (lineLength - sum.width) / sum.stretch\n                : INFINITY;\n        }\n        const shrink = 'shrink' in node ? node.shrink : null;\n        if (sum.width > lineLength) {\n            if (!shrink)\n                return INFINITY;\n            return sum.shrink - shrink > 0\n                ? (lineLength - sum.width) / sum.shrink\n                : INFINITY;\n        }\n        return 0;\n    };\n    for (let i = 0; i < subnodes.length; i += 1) {\n        const node = subnodes[i];\n        if (node.type === 'box') {\n            sum.width += node.width;\n        }\n        if (node.type === 'glue') {\n            sum.width += node.width;\n            sum.stretch += node.stretch;\n            sum.shrink += node.shrink;\n        }\n        if (sum.width - sum.shrink > lineLength) {\n            if (position === null) {\n                let j = i === 0 ? i + 1 : i;\n                while (j < subnodes.length &&\n                    (subnodes[j].type === 'glue' || subnodes[j].type === 'penalty')) {\n                    j++;\n                }\n                position = j - 1;\n            }\n            break;\n        }\n        if (node.type === 'penalty' || node.type === 'glue') {\n            const ratio = calculateRatio(node);\n            const penalty = node.type === 'penalty' ? node.penalty : 0;\n            const badness = 100 * Math.abs(ratio) ** 3 + penalty;\n            if (minimumBadness >= badness) {\n                position = i;\n                minimumBadness = badness;\n            }\n        }\n    }\n    return sum.width - sum.shrink > lineLength ? position : null;\n};\nconst applyBestFit = (nodes, widths) => {\n    let count = 0;\n    let lineNumber = 0;\n    let subnodes = nodes;\n    const breakpoints = [0];\n    while (subnodes.length > 0) {\n        const breakpoint = getNextBreakpoint(subnodes, widths, lineNumber);\n        if (breakpoint !== null) {\n            count += breakpoint;\n            breakpoints.push(count);\n            subnodes = subnodes.slice(breakpoint + 1, subnodes.length);\n            count++;\n            lineNumber++;\n        }\n        else {\n            subnodes = [];\n        }\n    }\n    return breakpoints;\n};\n\n/* eslint-disable max-classes-per-file */\nclass LinkedListNode {\n    data;\n    prev;\n    next;\n    constructor(data) {\n        this.data = data;\n        this.prev = null;\n        this.next = null;\n    }\n}\nclass LinkedList {\n    static Node = LinkedListNode;\n    head;\n    tail;\n    listSize;\n    listLength;\n    constructor() {\n        this.head = null;\n        this.tail = null;\n        this.listSize = 0;\n        this.listLength = 0;\n    }\n    isLinked(node) {\n        return !((node &&\n            node.prev === null &&\n            node.next === null &&\n            this.tail !== node &&\n            this.head !== node) ||\n            this.isEmpty());\n    }\n    size() {\n        return this.listSize;\n    }\n    isEmpty() {\n        return this.listSize === 0;\n    }\n    first() {\n        return this.head;\n    }\n    last() {\n        return this.last;\n    }\n    forEach(callback) {\n        let node = this.head;\n        while (node !== null) {\n            callback(node);\n            node = node.next;\n        }\n    }\n    at(i) {\n        let node = this.head;\n        let index = 0;\n        if (i >= this.listLength || i < 0) {\n            return null;\n        }\n        while (node !== null) {\n            if (i === index) {\n                return node;\n            }\n            node = node.next;\n            index += 1;\n        }\n        return null;\n    }\n    insertAfter(node, newNode) {\n        if (!this.isLinked(node))\n            return this;\n        newNode.prev = node;\n        newNode.next = node.next;\n        if (node.next === null) {\n            this.tail = newNode;\n        }\n        else {\n            node.next.prev = newNode;\n        }\n        node.next = newNode;\n        this.listSize += 1;\n        return this;\n    }\n    insertBefore(node, newNode) {\n        if (!this.isLinked(node))\n            return this;\n        newNode.prev = node.prev;\n        newNode.next = node;\n        if (node.prev === null) {\n            this.head = newNode;\n        }\n        else {\n            node.prev.next = newNode;\n        }\n        node.prev = newNode;\n        this.listSize += 1;\n        return this;\n    }\n    push(node) {\n        if (this.head === null) {\n            this.unshift(node);\n        }\n        else {\n            this.insertAfter(this.tail, node);\n        }\n        return this;\n    }\n    unshift(node) {\n        if (this.head === null) {\n            this.head = node;\n            this.tail = node;\n            node.prev = null;\n            node.next = null;\n            this.listSize += 1;\n        }\n        else {\n            this.insertBefore(this.head, node);\n        }\n        return this;\n    }\n    remove(node) {\n        if (!this.isLinked(node))\n            return this;\n        if (node.prev === null) {\n            this.head = node.next;\n        }\n        else {\n            node.prev.next = node.next;\n        }\n        if (node.next === null) {\n            this.tail = node.prev;\n        }\n        else {\n            node.next.prev = node.prev;\n        }\n        this.listSize -= 1;\n        return this;\n    }\n}\n\n/**\n * Licensed under the new BSD License.\n * Copyright 2009-2010, Bram Stein\n * All rights reserved.\n */\nfunction breakpoint(position, demerits, line, fitnessClass, totals, previous) {\n    return {\n        position,\n        demerits,\n        line,\n        fitnessClass,\n        totals: totals || {\n            width: 0,\n            stretch: 0,\n            shrink: 0,\n        },\n        previous,\n    };\n}\nfunction computeCost(nodes, lineLengths, sum, end, active, currentLine) {\n    let width = sum.width - active.totals.width;\n    let stretch = 0;\n    let shrink = 0;\n    // If the current line index is within the list of linelengths, use it, otherwise use\n    // the last line length of the list.\n    const lineLength = currentLine < lineLengths.length\n        ? lineLengths[currentLine - 1]\n        : lineLengths[lineLengths.length - 1];\n    if (nodes[end].type === 'penalty') {\n        width += nodes[end].width;\n    }\n    // Calculate the stretch ratio\n    if (width < lineLength) {\n        stretch = sum.stretch - active.totals.stretch;\n        if (stretch > 0) {\n            return (lineLength - width) / stretch;\n        }\n        return linebreak.infinity;\n    }\n    // Calculate the shrink ratio\n    if (width > lineLength) {\n        shrink = sum.shrink - active.totals.shrink;\n        if (shrink > 0) {\n            return (lineLength - width) / shrink;\n        }\n        return linebreak.infinity;\n    }\n    // perfect match\n    return 0;\n}\n// Add width, stretch and shrink values from the current\n// break point up to the next box or forced penalty.\nfunction computeSum(nodes, sum, breakPointIndex) {\n    const result = {\n        width: sum.width,\n        stretch: sum.stretch,\n        shrink: sum.shrink,\n    };\n    for (let i = breakPointIndex; i < nodes.length; i += 1) {\n        const node = nodes[i];\n        if (node.type === 'glue') {\n            result.width += node.width;\n            result.stretch += node.stretch;\n            result.shrink += node.shrink;\n        }\n        else if (node.type === 'box' ||\n            (node.type === 'penalty' &&\n                node.penalty === -linebreak.infinity &&\n                i > breakPointIndex)) {\n            break;\n        }\n    }\n    return result;\n}\nfunction findBestBreakpoints(activeNodes) {\n    const breakpoints = [];\n    if (activeNodes.size() === 0)\n        return [];\n    let tmp = { data: { demerits: Infinity } };\n    // Find the best active node (the one with the least total demerits.)\n    activeNodes.forEach((node) => {\n        if (node.data.demerits < tmp.data.demerits) {\n            tmp = node;\n        }\n    });\n    while (tmp !== null) {\n        breakpoints.push(tmp.data.position);\n        tmp = tmp.data.previous;\n    }\n    return breakpoints.reverse();\n}\n/**\n * @param nodes\n * @param availableWidths\n * @param tolerance\n * @preserve Knuth and Plass line breaking algorithm in JavaScript\n */\nconst linebreak = (nodes, availableWidths, tolerance) => {\n    // Demerits are used as a way to penalize bad line breaks\n    //  - line: applied to each line, depending on how much spaces need to stretch or shrink\n    //  - flagged: applied when consecutive lines end in hyphenation\n    //  - fitness: algorithm groups lines into fitness classes based on how loose or tight the spacing is.\n    //             if a paragraph has consecutive lines from different fitness classes,\n    //             a fitness demerit is applied to maintain visual consistency.\n    const options = {\n        demerits: { line: 10, flagged: 100, fitness: 3000 },\n        tolerance: tolerance || 3,\n    };\n    const activeNodes = new LinkedList();\n    const sum = { width: 0, stretch: 0, shrink: 0 };\n    const lineLengths = availableWidths;\n    // Add an active node for the start of the paragraph.\n    activeNodes.push(new LinkedList.Node(breakpoint(0, 0, 0, 0, undefined, null)));\n    // The main loop of the algorithm\n    function mainLoop(node, index, nodes) {\n        let active = activeNodes.first();\n        // The inner loop iterates through all the active nodes with line < currentLine and then\n        // breaks out to insert the new active node candidates before looking at the next active\n        // nodes for the next lines. The result of this is that the active node list is always\n        // sorted by line number.\n        while (active !== null) {\n            let currentLine = 0;\n            // Candidates fo each fitness class\n            const candidates = [\n                { active: undefined, demerits: Infinity },\n                { active: undefined, demerits: Infinity },\n                { active: undefined, demerits: Infinity },\n                { active: undefined, demerits: Infinity },\n            ];\n            // Iterate through the linked list of active nodes to find new potential active nodes and deactivate current active nodes.\n            while (active !== null) {\n                currentLine = active.data.line + 1;\n                const ratio = computeCost(nodes, lineLengths, sum, index, active.data, currentLine);\n                // Deactive nodes when the distance between the current active node and the\n                // current node becomes too large (i.e. it exceeds the stretch limit and the stretch\n                // ratio becomes negative) or when the current node is a forced break (i.e. the end\n                // of the paragraph when we want to remove all active nodes, but possibly have a final\n                // candidate active node---if the paragraph can be set using the given tolerance value.)\n                if (ratio < -1 ||\n                    (node.type === 'penalty' && node.penalty === -linebreak.infinity)) {\n                    activeNodes.remove(active);\n                }\n                // If the ratio is within the valid range of -1 <= ratio <= tolerance calculate the\n                // total demerits and record a candidate active node.\n                if (ratio >= -1 && ratio <= options.tolerance) {\n                    const badness = 100 * Math.pow(Math.abs(ratio), 3);\n                    let demerits = 0;\n                    // Positive penalty\n                    if (node.type === 'penalty' && node.penalty >= 0) {\n                        demerits =\n                            Math.pow(options.demerits.line + badness, 2) +\n                                Math.pow(node.penalty, 2);\n                        // Negative penalty but not a forced break\n                    }\n                    else if (node.type === 'penalty' &&\n                        node.penalty !== -linebreak.infinity) {\n                        demerits =\n                            Math.pow(options.demerits.line + badness, 2) -\n                                Math.pow(node.penalty, 2);\n                        // All other cases\n                    }\n                    else {\n                        demerits = Math.pow(options.demerits.line + badness, 2);\n                    }\n                    if (node.type === 'penalty' &&\n                        nodes[active.data.position].type === 'penalty') {\n                        demerits +=\n                            options.demerits.flagged *\n                                node.flagged *\n                                // @ts-expect-error node is penalty here\n                                nodes[active.data.position].flagged;\n                    }\n                    // Calculate the fitness class for this candidate active node.\n                    let currentClass;\n                    if (ratio < -0.5) {\n                        currentClass = 0;\n                    }\n                    else if (ratio <= 0.5) {\n                        currentClass = 1;\n                    }\n                    else if (ratio <= 1) {\n                        currentClass = 2;\n                    }\n                    else {\n                        currentClass = 3;\n                    }\n                    // Add a fitness penalty to the demerits if the fitness classes of two adjacent lines differ too much.\n                    if (Math.abs(currentClass - active.data.fitnessClass) > 1) {\n                        demerits += options.demerits.fitness;\n                    }\n                    // Add the total demerits of the active node to get the total demerits of this candidate node.\n                    demerits += active.data.demerits;\n                    // Only store the best candidate for each fitness class\n                    if (demerits < candidates[currentClass].demerits) {\n                        candidates[currentClass] = { active, demerits };\n                    }\n                }\n                active = active.next;\n                // Stop iterating through active nodes to insert new candidate active nodes in the active list\n                // before moving on to the active nodes for the next line.\n                // TODO: The Knuth and Plass paper suggests a conditional for currentLine < j0. This means paragraphs\n                // with identical line lengths will not be sorted by line number. Find out if that is a desirable outcome.\n                // For now I left this out, as it only adds minimal overhead to the algorithm and keeping the active node\n                // list sorted has a higher priority.\n                if (active !== null && active.data.line >= currentLine) {\n                    break;\n                }\n            }\n            const tmpSum = computeSum(nodes, sum, index);\n            for (let fitnessClass = 0; fitnessClass < candidates.length; fitnessClass += 1) {\n                const candidate = candidates[fitnessClass];\n                if (candidate.demerits === Infinity)\n                    continue;\n                const newNode = new LinkedList.Node(breakpoint(index, candidate.demerits, candidate.active.data.line + 1, fitnessClass, tmpSum, candidate.active));\n                if (active !== null) {\n                    activeNodes.insertBefore(active, newNode);\n                }\n                else {\n                    activeNodes.push(newNode);\n                }\n            }\n        }\n    }\n    nodes.forEach((node, index, nodes) => {\n        if (node.type === 'box') {\n            sum.width += node.width;\n            return;\n        }\n        if (node.type === 'glue') {\n            const precedesBox = index > 0 && nodes[index - 1].type === 'box';\n            if (precedesBox)\n                mainLoop(node, index, nodes);\n            sum.width += node.width;\n            sum.stretch += node.stretch;\n            sum.shrink += node.shrink;\n            return;\n        }\n        if (node.type === 'penalty' && node.penalty !== linebreak.infinity) {\n            mainLoop(node, index, nodes);\n        }\n    });\n    return findBestBreakpoints(activeNodes);\n};\nlinebreak.infinity = 10000;\nlinebreak.glue = (width, start, end, stretch, shrink) => ({\n    type: 'glue',\n    start,\n    end,\n    width,\n    stretch,\n    shrink,\n});\nlinebreak.box = (width, start, end, hyphenated = false) => ({\n    type: 'box',\n    width,\n    start,\n    end,\n    hyphenated,\n});\nlinebreak.penalty = (width, penalty, flagged) => ({\n    type: 'penalty',\n    width,\n    penalty,\n    flagged,\n});\n\n/**\n * Add scalar to run\n *\n * @param index - Scalar\n * @param run - Run\n * @returns Added run\n */\nconst add = (index, run) => {\n    const start = run.start + index;\n    const end = run.end + index;\n    return Object.assign({}, run, { start, end });\n};\n\n/**\n * Get run length\n *\n * @param run - Run\n * @returns Length\n */\nconst length = (run) => {\n    return run.end - run.start;\n};\n\n/**\n * Concats two runs into one\n *\n * @param runA - First run\n * @param runB - Second run\n * @returns Concatenated run\n */\nconst concat = (runA, runB) => {\n    const end = runA.end + length(runB);\n    const glyphs = (runA.glyphs || []).concat(runB.glyphs || []);\n    const positions = (runA.positions || []).concat(runB.positions || []);\n    const attributes = Object.assign({}, runA.attributes, runB.attributes);\n    const runAIndices = runA.glyphIndices || [];\n    const runALastIndex = (0,_react_pdf_fns__WEBPACK_IMPORTED_MODULE_0__.last)(runAIndices) || 0;\n    const runBIndices = (runB.glyphIndices || []).map((i) => i + runALastIndex + 1);\n    const glyphIndices = normalize(runAIndices.concat(runBIndices));\n    return Object.assign({}, runA, {\n        end,\n        glyphs,\n        positions,\n        attributes,\n        glyphIndices,\n    });\n};\n\n/**\n * Insert glyph to run in the given index\n *\n * @param index - Index\n * @param glyph - Glyph\n * @param run - Run\n * @returns Run with glyph\n */\nconst insertGlyph$1 = (index, glyph, run) => {\n    if (!glyph)\n        return run;\n    // Split resolves ligature splitting in case new glyph breaks some\n    const leadingRun = slice$1(0, index, run);\n    const trailingRun = slice$1(index, Infinity, run);\n    return concat(append$1(glyph, leadingRun), trailingRun);\n};\n/**\n * Insert either glyph or code point to run in the given index\n *\n * @param index - Index\n * @param value - Glyph or codePoint\n * @param run - Run\n * @returns Run with glyph\n */\nconst insert = (index, value, run) => {\n    const font = getFont(run);\n    const glyph = isNumber(value) ? fromCodePoint(value, font) : value;\n    return insertGlyph$1(index, glyph, run);\n};\n\n/**\n * Get run index at char index\n *\n * @param index - Char index\n * @param attributedString - Attributed string\n * @returns Run index\n */\nconst runIndexAt = (index, attributedString) => {\n    return runIndexAt$1(index, attributedString.runs);\n};\n\n/**\n * Insert glyph into attributed string\n *\n * @param index - Index\n * @param glyph - Glyph or code point\n * @param attributedString - Attributed string\n * @returns Attributed string with new glyph\n */\nconst insertGlyph = (index, glyph, attributedString) => {\n    const runIndex = runIndexAt(index, attributedString);\n    // Add glyph to the end if run index invalid\n    if (runIndex === -1)\n        return append(glyph, attributedString);\n    const codePoints = [glyph] ;\n    const string = attributedString.string.slice(0, index) +\n        stringFromCodePoints(codePoints) +\n        attributedString.string.slice(index);\n    const runs = attributedString.runs.map((run, i) => {\n        if (i === runIndex)\n            return insert(index - run.start, glyph, run);\n        if (i > runIndex)\n            return add(codePoints.length, run);\n        return run;\n    });\n    return Object.assign({}, attributedString, { string, runs });\n};\n\n/**\n * Advance width between two string indices\n *\n * @param start - Glyph index\n * @param end - Glyph index\n * @param run - Run\n * @returns Advanced width run\n */\nconst advanceWidthBetween$1 = (start, end, run) => {\n    const runStart = run.start || 0;\n    const glyphStartIndex = Math.max(0, glyphIndexAt(start - runStart, run));\n    const glyphEndIndex = Math.max(0, glyphIndexAt(end - runStart, run));\n    const positions = (run.positions || []).slice(glyphStartIndex, glyphEndIndex);\n    return advanceWidth$2(positions);\n};\n\n/**\n * Advance width between start and end\n * Does not consider ligature splitting for the moment.\n * Check performance impact on supporting this\n *\n * @param start - Start offset\n * @param end - End offset\n * @param attributedString\n * @returns Advance width\n */\nconst advanceWidthBetween = (start, end, attributedString) => {\n    const runs = filter(start, end, attributedString.runs);\n    return runs.reduce((acc, run) => acc + advanceWidthBetween$1(start, end, run), 0);\n};\n\nconst HYPHEN = 0x002d;\nconst TOLERANCE_STEPS = 5;\nconst TOLERANCE_LIMIT = 50;\nconst opts = {\n    width: 3,\n    stretch: 6,\n    shrink: 9,\n};\n/**\n * Slice attributed string to many lines\n *\n * @param attributedString - Attributed string\n * @param nodes\n * @param breaks\n * @returns Attributed strings\n */\nconst breakLines = (attributedString, nodes, breaks) => {\n    let start = 0;\n    let end = null;\n    const lines = breaks.reduce((acc, breakPoint) => {\n        const node = nodes[breakPoint];\n        const prevNode = nodes[breakPoint - 1];\n        // Last breakpoint corresponds to K&P mandatory final glue\n        if (breakPoint === nodes.length - 1)\n            return acc;\n        let line;\n        if (node.type === 'penalty') {\n            // @ts-expect-error penalty node will always preceed box or glue node\n            end = prevNode.end;\n            line = slice(start, end, attributedString);\n            line = insertGlyph(line.string.length, HYPHEN, line);\n        }\n        else {\n            end = node.end;\n            line = slice(start, end, attributedString);\n        }\n        start = end;\n        return [...acc, line];\n    }, []);\n    // Last line\n    lines.push(slice(start, attributedString.string.length, attributedString));\n    return lines;\n};\n/**\n * Return Knuth & Plass nodes based on line and previously calculated syllables\n *\n * @param attributedString - Attributed string\n * @param attributes - Attributes\n * @param options - Layout options\n * @returns ?\n */\nconst getNodes = (attributedString, { align }, options) => {\n    let start = 0;\n    const hyphenWidth = 5;\n    const { syllables } = attributedString;\n    const hyphenPenalty = options.hyphenationPenalty || (align === 'justify' ? 100 : 600);\n    const result = syllables.reduce((acc, s, index) => {\n        const width = advanceWidthBetween(start, start + s.length, attributedString);\n        if (s.trim() === '') {\n            const stretch = (width * opts.width) / opts.stretch;\n            const shrink = (width * opts.width) / opts.shrink;\n            const end = start + s.length;\n            // Add glue node. Glue nodes are used to fill the space between words.\n            acc.push(linebreak.glue(width, start, end, stretch, shrink));\n        }\n        else {\n            const hyphenated = syllables[index + 1] !== ' ';\n            const end = start + s.length;\n            // Add box node. Box nodes are used to represent words.\n            acc.push(linebreak.box(width, start, end, hyphenated));\n            if (syllables[index + 1] && hyphenated) {\n                // Add penalty node. Penalty nodes are used to represent hyphenation points.\n                acc.push(linebreak.penalty(hyphenWidth, hyphenPenalty, 1));\n            }\n        }\n        start += s.length;\n        return acc;\n    }, []);\n    // Add mandatory final glue\n    result.push(linebreak.glue(0, start, start, linebreak.infinity, 0));\n    result.push(linebreak.penalty(0, -linebreak.infinity, 1));\n    return result;\n};\n/**\n * @param attributedString - Attributed string\n * @returns Attributes\n */\nconst getAttributes = (attributedString) => {\n    return attributedString.runs?.[0]?.attributes || {};\n};\n/**\n * Performs Knuth & Plass line breaking algorithm\n * Fallbacks to best fit algorithm if latter not successful\n *\n * @param options - Layout options\n */\nconst linebreaker = (options) => {\n    /**\n     * @param attributedString - Attributed string\n     * @param availableWidths - Available widths\n     * @returns Attributed string\n     */\n    return (attributedString, availableWidths) => {\n        let tolerance = options.tolerance || 4;\n        const attributes = getAttributes(attributedString);\n        const nodes = getNodes(attributedString, attributes, options);\n        let breaks = linebreak(nodes, availableWidths, tolerance);\n        // Try again with a higher tolerance if the line breaking failed.\n        while (breaks.length === 0 && tolerance < TOLERANCE_LIMIT) {\n            tolerance += TOLERANCE_STEPS;\n            breaks = linebreak(nodes, availableWidths, tolerance);\n        }\n        if (breaks.length === 0 || (breaks.length === 1 && breaks[0] === 0)) {\n            breaks = applyBestFit(nodes, availableWidths);\n        }\n        return breakLines(attributedString, nodes, breaks.slice(1));\n    };\n};\n\nvar Direction;\n(function (Direction) {\n    Direction[Direction[\"GROW\"] = 0] = \"GROW\";\n    Direction[Direction[\"SHRINK\"] = 1] = \"SHRINK\";\n})(Direction || (Direction = {}));\nconst WHITESPACE_PRIORITY = 1;\nconst LETTER_PRIORITY = 2;\nconst EXPAND_WHITESPACE_FACTOR = {\n    before: 0.5,\n    after: 0.5,\n    priority: WHITESPACE_PRIORITY,\n    unconstrained: false,\n};\nconst EXPAND_CHAR_FACTOR = {\n    before: 0.14453125, // 37/256\n    after: 0.14453125,\n    priority: LETTER_PRIORITY,\n    unconstrained: false,\n};\nconst SHRINK_WHITESPACE_FACTOR = {\n    before: -0.04296875, // -11/256\n    after: -0.04296875,\n    priority: WHITESPACE_PRIORITY,\n    unconstrained: false,\n};\nconst SHRINK_CHAR_FACTOR = {\n    before: -0.04296875,\n    after: -0.04296875,\n    priority: LETTER_PRIORITY,\n    unconstrained: false,\n};\nconst getCharFactor = (direction, options) => {\n    const expandCharFactor = options.expandCharFactor || {};\n    const shrinkCharFactor = options.shrinkCharFactor || {};\n    return direction === Direction.GROW\n        ? Object.assign({}, EXPAND_CHAR_FACTOR, expandCharFactor)\n        : Object.assign({}, SHRINK_CHAR_FACTOR, shrinkCharFactor);\n};\nconst getWhitespaceFactor = (direction, options) => {\n    const expandWhitespaceFactor = options.expandWhitespaceFactor || {};\n    const shrinkWhitespaceFactor = options.shrinkWhitespaceFactor || {};\n    return direction === Direction.GROW\n        ? Object.assign({}, EXPAND_WHITESPACE_FACTOR, expandWhitespaceFactor)\n        : Object.assign({}, SHRINK_WHITESPACE_FACTOR, shrinkWhitespaceFactor);\n};\nconst factor = (direction, options) => (glyphs) => {\n    const charFactor = getCharFactor(direction, options);\n    const whitespaceFactor = getWhitespaceFactor(direction, options);\n    const factors = [];\n    for (let index = 0; index < glyphs.length; index += 1) {\n        let f;\n        const glyph = glyphs[index];\n        if (isWhiteSpace(glyph)) {\n            f = Object.assign({}, whitespaceFactor);\n            if (index === glyphs.length - 1) {\n                f.before = 0;\n                if (index > 0) {\n                    factors[index - 1].after = 0;\n                }\n            }\n        }\n        else if (glyph.isMark && index > 0) {\n            f = Object.assign({}, factors[index - 1]);\n            f.before = 0;\n            factors[index - 1].after = 0;\n        }\n        else {\n            f = Object.assign({}, charFactor);\n        }\n        factors.push(f);\n    }\n    return factors;\n};\nconst getFactors = (gap, line, options) => {\n    const direction = gap > 0 ? Direction.GROW : Direction.SHRINK;\n    const getFactor = factor(direction, options);\n    const factors = line.runs.reduce((acc, run) => {\n        return acc.concat(getFactor(run.glyphs));\n    }, []);\n    factors[0].before = 0;\n    factors[factors.length - 1].after = 0;\n    return factors;\n};\n\nconst KASHIDA_PRIORITY = 0;\nconst NULL_PRIORITY = 3;\nconst getDistances = (gap, factors) => {\n    let total = 0;\n    const priorities = [];\n    const unconstrained = [];\n    for (let priority = KASHIDA_PRIORITY; priority <= NULL_PRIORITY; priority += 1) {\n        priorities[priority] = unconstrained[priority] = 0;\n    }\n    // sum the factors at each priority\n    for (let j = 0; j < factors.length; j += 1) {\n        const f = factors[j];\n        const sum = f.before + f.after;\n        total += sum;\n        priorities[f.priority] += sum;\n        if (f.unconstrained) {\n            unconstrained[f.priority] += sum;\n        }\n    }\n    // choose the priorities that need to be applied\n    let highestPriority = -1;\n    let highestPrioritySum = 0;\n    let remainingGap = gap;\n    let priority;\n    for (priority = KASHIDA_PRIORITY; priority <= NULL_PRIORITY; priority += 1) {\n        const prioritySum = priorities[priority];\n        if (prioritySum !== 0) {\n            if (highestPriority === -1) {\n                highestPriority = priority;\n                highestPrioritySum = prioritySum;\n            }\n            // if this priority covers the remaining gap, we're done\n            if (Math.abs(remainingGap) <= Math.abs(prioritySum)) {\n                priorities[priority] = remainingGap / prioritySum;\n                unconstrained[priority] = 0;\n                remainingGap = 0;\n                break;\n            }\n            // mark that we need to use 100% of the adjustment from\n            // this priority, and subtract the space that it consumes\n            priorities[priority] = 1;\n            remainingGap -= prioritySum;\n            // if this priority has unconstrained glyphs, let them consume the remaining space\n            if (unconstrained[priority] !== 0) {\n                unconstrained[priority] = remainingGap / unconstrained[priority];\n                remainingGap = 0;\n                break;\n            }\n        }\n    }\n    // zero out remaining priorities (if any)\n    for (let p = priority + 1; p <= NULL_PRIORITY; p += 1) {\n        priorities[p] = 0;\n        unconstrained[p] = 0;\n    }\n    // if there is still space left over, assign it to the highest priority that we saw.\n    // this violates their factors, but it only happens in extreme cases\n    if (remainingGap > 0 && highestPriority > -1) {\n        priorities[highestPriority] =\n            (highestPrioritySum + (gap - total)) / highestPrioritySum;\n    }\n    // create and return an array of distances to add to each glyph's advance\n    const distances = [];\n    for (let index = 0; index < factors.length; index += 1) {\n        // the distance to add to this glyph is the sum of the space to add\n        // after this glyph, and the space to add before the next glyph\n        const f = factors[index];\n        const next = factors[index + 1];\n        let dist = f.after * priorities[f.priority];\n        if (next) {\n            dist += next.before * priorities[next.priority];\n        }\n        // if this glyph is unconstrained, add the unconstrained distance as well\n        if (f.unconstrained) {\n            dist += f.after * unconstrained[f.priority];\n            if (next) {\n                dist += next.before * unconstrained[next.priority];\n            }\n        }\n        distances.push(dist);\n    }\n    return distances;\n};\n\n/**\n * Adjust run positions by given distances\n *\n * @param distances\n * @param line\n * @returns Line\n */\nconst justifyLine = (distances, line) => {\n    let index = 0;\n    for (const run of line.runs) {\n        for (const position of run.positions) {\n            position.xAdvance += distances[index++];\n        }\n    }\n    return line;\n};\n/**\n * A JustificationEngine is used by a Typesetter to perform line fragment\n * justification. This implementation is based on a description of Apple's\n * justification algorithm from a PDF in the Apple Font Tools package.\n *\n * @param options - Layout options\n */\nconst justification = (options) => {\n    /**\n     * @param line\n     * @returns Line\n     */\n    return (line) => {\n        const gap = line.box.width - advanceWidth(line);\n        if (gap === 0)\n            return line; // Exact fit\n        const factors = getFactors(gap, line, options);\n        const distances = getDistances(gap, factors);\n        return justifyLine(distances, line);\n    };\n};\n\n/**\n * Returns attributed string ascent\n *\n * @param attributedString - Attributed string\n * @returns Ascent\n */\nconst ascent = (attributedString) => {\n    const reducer = (acc, run) => Math.max(acc, ascent$1(run));\n    return attributedString.runs.reduce(reducer, 0);\n};\n\n// The base font size used for calculating underline thickness.\nconst BASE_FONT_SIZE = 12;\n/**\n * A TextDecorationEngine is used by a Typesetter to generate\n * DecorationLines for a line fragment, including underlines\n * and strikes.\n */\nconst textDecoration = () => (line) => {\n    let x = line.overflowLeft || 0;\n    const overflowRight = line.overflowRight || 0;\n    const maxX = advanceWidth(line) - overflowRight;\n    line.decorationLines = [];\n    for (let i = 0; i < line.runs.length; i += 1) {\n        const run = line.runs[i];\n        const width = Math.min(maxX - x, advanceWidth$1(run));\n        const thickness = Math.max(0.5, Math.floor(run.attributes.fontSize / BASE_FONT_SIZE));\n        if (run.attributes.underline) {\n            const rect = {\n                x,\n                y: ascent(line) + thickness * 2,\n                width,\n                height: thickness,\n            };\n            const decorationLine = {\n                rect,\n                opacity: run.attributes.opacity,\n                color: run.attributes.underlineColor || 'black',\n                style: run.attributes.underlineStyle || 'solid',\n            };\n            line.decorationLines.push(decorationLine);\n        }\n        if (run.attributes.strike) {\n            const y = ascent(line) - ascent$1(run) / 3;\n            const rect = { x, y, width, height: thickness };\n            const decorationLine = {\n                rect,\n                opacity: run.attributes.opacity,\n                color: run.attributes.strikeColor || 'black',\n                style: run.attributes.strikeStyle || 'solid',\n            };\n            line.decorationLines.push(decorationLine);\n        }\n        x += width;\n    }\n    return line;\n};\n\nconst ignoredScripts = ['Common', 'Inherited', 'Unknown'];\n/**\n * Resolves unicode script in runs, grouping equal runs together\n */\nconst scriptItemizer = () => {\n    /**\n     * @param attributedString - Attributed string\n     * @returns Attributed string\n     */\n    return (attributedString) => {\n        const { string } = attributedString;\n        let lastScript = 'Unknown';\n        let lastIndex = 0;\n        let index = 0;\n        const runs = [];\n        if (!string)\n            return empty();\n        for (let i = 0; i < string.length; i += 1) {\n            const char = string[i];\n            const codePoint = char.codePointAt(0);\n            const script = unicode_properties__WEBPACK_IMPORTED_MODULE_2__[\"default\"].getScript(codePoint);\n            if (script !== lastScript && !ignoredScripts.includes(script)) {\n                if (lastScript !== 'Unknown') {\n                    runs.push({\n                        start: lastIndex,\n                        end: index,\n                        attributes: { script: lastScript },\n                    });\n                }\n                lastIndex = index;\n                lastScript = script;\n            }\n            index += char.length;\n        }\n        if (lastIndex < string.length) {\n            runs.push({\n                start: lastIndex,\n                end: string.length,\n                attributes: { script: lastScript },\n            });\n        }\n        const result = { string, runs: runs };\n        return result;\n    };\n};\n\nconst SOFT_HYPHEN = '\\u00ad';\nconst hyphenator = hyphen__WEBPACK_IMPORTED_MODULE_3__(hyphen_patterns_en_us_js__WEBPACK_IMPORTED_MODULE_4__);\n/**\n * @param word\n * @returns Word parts\n */\nconst splitHyphen = (word) => {\n    return word.split(SOFT_HYPHEN);\n};\nconst cache = {};\n/**\n * @param word\n * @returns Word parts\n */\nconst getParts = (word) => {\n    const base = word.includes(SOFT_HYPHEN) ? word : hyphenator(word);\n    return splitHyphen(base);\n};\nconst wordHyphenation = () => {\n    /**\n     * @param word - Word\n     * @returns Word parts\n     */\n    return (word) => {\n        const cacheKey = `_${word}`;\n        if ((0,_react_pdf_fns__WEBPACK_IMPORTED_MODULE_0__.isNil)(word))\n            return [];\n        if (cache[cacheKey])\n            return cache[cacheKey];\n        cache[cacheKey] = getParts(word);\n        return cache[cacheKey];\n    };\n};\n\nconst IGNORED_CODE_POINTS = [173];\nconst getFontSize = (run) => run.attributes.fontSize || 12;\nconst pickFontFromFontStack = (codePoint, fontStack, lastFont) => {\n    const fontStackWithFallback = [...fontStack, lastFont];\n    for (let i = 0; i < fontStackWithFallback.length; i += 1) {\n        const font = fontStackWithFallback[i];\n        if (!IGNORED_CODE_POINTS.includes(codePoint) &&\n            font &&\n            font.hasGlyphForCodePoint &&\n            font.hasGlyphForCodePoint(codePoint)) {\n            return font;\n        }\n    }\n    return fontStack.at(-1);\n};\nconst fontSubstitution = () => ({ string, runs }) => {\n    let lastFont = null;\n    let lastFontSize = null;\n    let lastIndex = 0;\n    let index = 0;\n    const res = [];\n    for (let i = 0; i < runs.length; i += 1) {\n        const run = runs[i];\n        if (string.length === 0) {\n            res.push({\n                start: 0,\n                end: 0,\n                attributes: { font: run.attributes.font },\n            });\n            break;\n        }\n        const chars = string.slice(run.start, run.end);\n        for (let j = 0; j < chars.length; j += 1) {\n            const char = chars[j];\n            const codePoint = char.codePointAt(0);\n            // If the default font does not have a glyph and the fallback font does, we use it\n            const font = pickFontFromFontStack(codePoint, run.attributes.font, lastFont);\n            const fontSize = getFontSize(run);\n            // If anything that would impact res has changed, update it\n            if (font !== lastFont ||\n                fontSize !== lastFontSize ||\n                font.unitsPerEm !== lastFont.unitsPerEm) {\n                if (lastFont) {\n                    res.push({\n                        start: lastIndex,\n                        end: index,\n                        attributes: {\n                            font: [lastFont],\n                            scale: lastFontSize / lastFont.unitsPerEm,\n                        },\n                    });\n                }\n                lastFont = font;\n                lastFontSize = fontSize;\n                lastIndex = index;\n            }\n            index += char.length;\n        }\n    }\n    if (lastIndex < string.length) {\n        const fontSize = getFontSize((0,_react_pdf_fns__WEBPACK_IMPORTED_MODULE_0__.last)(runs));\n        res.push({\n            start: lastIndex,\n            end: string.length,\n            attributes: {\n                font: [lastFont],\n                scale: fontSize / lastFont.unitsPerEm,\n            },\n        });\n    }\n    return { string, runs: res };\n};\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQHJlYWN0LXBkZit0ZXh0a2l0QDYuMC4wL25vZGVfbW9kdWxlcy9AcmVhY3QtcGRmL3RleHRraXQvbGliL3RleHRraXQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBdUc7QUFDckU7QUFDTztBQUNiO0FBQ21COztBQUUvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRCxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0wsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsY0FBYztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixrQ0FBa0M7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGtCQUFrQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLGdCQUFnQjtBQUM3QztBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixVQUFVLFFBQVE7QUFDaEQsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHFEQUFLO0FBQ2hCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLFNBQVMsWUFBWTtBQUNoRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixzQkFBc0IsMEJBQTBCO0FBQzNFOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isb0RBQUk7QUFDMUIsa0JBQWtCLHFEQUFLO0FBQ3ZCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsU0FBUywyQkFBMkI7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCwyQkFBMkIsU0FBUyxzQ0FBc0M7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FB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LGFBQWE7QUFDYjtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixxQkFBcUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxrQkFBa0I7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsdUNBQXVDO0FBQzNEO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHVDQUF1QztBQUN6RCxrQkFBa0IsdUNBQXVDO0FBQ3pELGtCQUFrQix1Q0FBdUM7QUFDekQsa0JBQWtCLHVDQUF1QztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQ7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxrQ0FBa0M7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixTQUFTLFlBQVk7QUFDaEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQSwwQkFBMEIsb0RBQUk7QUFDOUI7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCwyQkFBMkIsc0JBQXNCLGNBQWM7QUFDL0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsT0FBTztBQUM3QztBQUNBO0FBQ0EsWUFBWSxZQUFZO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyw4QkFBOEI7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHVCQUF1QjtBQUMvQztBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsMkJBQTJCO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixvQkFBb0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsMkJBQTJCO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0Isb0JBQW9CO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isd0JBQXdCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHNCQUFzQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixtQkFBbUI7QUFDM0M7QUFDQTtBQUNBLDJCQUEyQixvRUFBaUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxvQkFBb0I7QUFDMUQscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLG9CQUFvQjtBQUNsRCxhQUFhO0FBQ2I7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CLG1DQUFNLENBQUMscURBQU87QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsS0FBSztBQUNsQyxZQUFZLHFEQUFLO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtDQUFrQztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxjQUFjO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsaUJBQWlCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsMkJBQTJCO0FBQ3pELGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isa0JBQWtCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsb0RBQUk7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBLGFBQWE7QUFDYjs7QUFFcUsiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9kaXNlYXNlLXByZWRpY3Rpb24tZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvLnBucG0vQHJlYWN0LXBkZit0ZXh0a2l0QDYuMC4wL25vZGVfbW9kdWxlcy9AcmVhY3QtcGRmL3RleHRraXQvbGliL3RleHRraXQuanM/YThlMCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBpc05pbCwgbGFzdCwgcmVwZWF0LCByZXZlcnNlLCBkcm9wTGFzdCBhcyBkcm9wTGFzdCQyLCBhZGp1c3QsIGNvbXBvc2UgfSBmcm9tICdAcmVhY3QtcGRmL2Zucyc7XG5pbXBvcnQgYmlkaUZhY3RvcnkgZnJvbSAnYmlkaS1qcyc7XG5pbXBvcnQgdW5pY29kZSBmcm9tICd1bmljb2RlLXByb3BlcnRpZXMnO1xuaW1wb3J0IGh5cGhlbiBmcm9tICdoeXBoZW4nO1xuaW1wb3J0IHBhdHRlcm4gZnJvbSAnaHlwaGVuL3BhdHRlcm5zL2VuLXVzLmpzJztcblxuLyoqXG4gKiBDcmVhdGUgYXR0cmlidXRlZCBzdHJpbmcgZnJvbSB0ZXh0IGZyYWdtZW50c1xuICpcbiAqIEBwYXJhbSBmcmFnbWVudHMgLSBGcmFnbWVudHNcbiAqIEByZXR1cm5zIEF0dHJpYnV0ZWQgc3RyaW5nXG4gKi9cbmNvbnN0IGZyb21GcmFnbWVudHMgPSAoZnJhZ21lbnRzKSA9PiB7XG4gICAgbGV0IG9mZnNldCA9IDA7XG4gICAgbGV0IHN0cmluZyA9ICcnO1xuICAgIGNvbnN0IHJ1bnMgPSBbXTtcbiAgICBmcmFnbWVudHMuZm9yRWFjaCgoZnJhZ21lbnQpID0+IHtcbiAgICAgICAgc3RyaW5nICs9IGZyYWdtZW50LnN0cmluZztcbiAgICAgICAgcnVucy5wdXNoKHtcbiAgICAgICAgICAgIC4uLmZyYWdtZW50LFxuICAgICAgICAgICAgc3RhcnQ6IG9mZnNldCxcbiAgICAgICAgICAgIGVuZDogb2Zmc2V0ICsgZnJhZ21lbnQuc3RyaW5nLmxlbmd0aCxcbiAgICAgICAgICAgIGF0dHJpYnV0ZXM6IGZyYWdtZW50LmF0dHJpYnV0ZXMgfHwge30sXG4gICAgICAgIH0pO1xuICAgICAgICBvZmZzZXQgKz0gZnJhZ21lbnQuc3RyaW5nLmxlbmd0aDtcbiAgICB9KTtcbiAgICByZXR1cm4geyBzdHJpbmcsIHJ1bnMgfTtcbn07XG5cbi8qKlxuICogRGVmYXVsdCB3b3JkIGh5cGhlbmF0aW9uIGVuZ2luZSB1c2VkIHdoZW4gbm8gb25lIHByb3ZpZGVkLlxuICogRG9lcyBub3QgcGVyZm9ybSB3b3JkIGh5cGhlbmF0aW9uIGF0IGFsbFxuICpcbiAqIEBwYXJhbSB3b3JkXG4gKiBAcmV0dXJucyBTYW1lIHdvcmRcbiAqL1xuY29uc3QgZGVmYXVsdEh5cGhlbmF0aW9uRW5naW5lID0gKHdvcmQpID0+IFt3b3JkXTtcbi8qKlxuICogV3JhcCB3b3JkcyBvZiBhdHRyaWJ1dGUgc3RyaW5nXG4gKlxuICogQHBhcmFtIGVuZ2luZXMgbGF5b3V0IGVuZ2luZXNcbiAqIEBwYXJhbSBvcHRpb25zIGxheW91dCBvcHRpb25zXG4gKi9cbmNvbnN0IHdyYXBXb3JkcyA9IChlbmdpbmVzID0ge30sIG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSBhdHRyaWJ1dGVkU3RyaW5nIC0gQXR0cmlidXRlZCBzdHJpbmdcbiAgICAgKiBAcmV0dXJucyBBdHRyaWJ1dGVkIHN0cmluZyBpbmNsdWRpbmcgc3lsbGFibGVzXG4gICAgICovXG4gICAgcmV0dXJuIChhdHRyaWJ1dGVkU3RyaW5nKSA9PiB7XG4gICAgICAgIGNvbnN0IHN5bGxhYmxlcyA9IFtdO1xuICAgICAgICBjb25zdCBmcmFnbWVudHMgPSBbXTtcbiAgICAgICAgY29uc3QgaHlwaGVuYXRlV29yZCA9IG9wdGlvbnMuaHlwaGVuYXRpb25DYWxsYmFjayB8fFxuICAgICAgICAgICAgZW5naW5lcy53b3JkSHlwaGVuYXRpb24/LigpIHx8XG4gICAgICAgICAgICBkZWZhdWx0SHlwaGVuYXRpb25FbmdpbmU7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXR0cmlidXRlZFN0cmluZy5ydW5zLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICBsZXQgc3RyaW5nID0gJyc7XG4gICAgICAgICAgICBjb25zdCBydW4gPSBhdHRyaWJ1dGVkU3RyaW5nLnJ1bnNbaV07XG4gICAgICAgICAgICBjb25zdCB3b3JkcyA9IGF0dHJpYnV0ZWRTdHJpbmcuc3RyaW5nXG4gICAgICAgICAgICAgICAgLnNsaWNlKHJ1bi5zdGFydCwgcnVuLmVuZClcbiAgICAgICAgICAgICAgICAuc3BsaXQoLyhbIF0rKS9nKVxuICAgICAgICAgICAgICAgIC5maWx0ZXIoQm9vbGVhbik7XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHdvcmRzLmxlbmd0aDsgaiArPSAxKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgd29yZCA9IHdvcmRzW2pdO1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhcnRzID0gaHlwaGVuYXRlV29yZCh3b3JkKTtcbiAgICAgICAgICAgICAgICBzeWxsYWJsZXMucHVzaCguLi5wYXJ0cyk7XG4gICAgICAgICAgICAgICAgc3RyaW5nICs9IHBhcnRzLmpvaW4oJycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnJhZ21lbnRzLnB1c2goeyAuLi5ydW4sIHN0cmluZyB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXN1bHQgPSB7IC4uLmZyb21GcmFnbWVudHMoZnJhZ21lbnRzKSwgc3lsbGFibGVzIH07XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbn07XG5cbi8qKlxuICogQ2xvbmUgcmVjdFxuICpcbiAqIEBwYXJhbSByZWN0IC0gUmVjdFxuICogQHJldHVybnMgQ2xvbmVkIHJlY3RcbiAqL1xuY29uc3QgY29weSA9IChyZWN0KSA9PiB7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIHJlY3QpO1xufTtcblxuLyoqXG4gKiBQYXJ0aXRpb24gcmVjdCBpbiB0d28gaW4gdGhlIHZlcnRpY2FsIGRpcmVjdGlvblxuICpcbiAqIEBwYXJhbSByZWN0IC0gUmVjdFxuICogQHBhcmFtIGhlaWdodCAtIEhlaWdodFxuICogQHJldHVybnMgUGFydGl0aW9uZWQgcmVjdHNcbiAqL1xuY29uc3QgcGFydGl0aW9uID0gKHJlY3QsIGhlaWdodCkgPT4ge1xuICAgIGNvbnN0IGEgPSBPYmplY3QuYXNzaWduKHt9LCByZWN0LCB7IGhlaWdodCB9KTtcbiAgICBjb25zdCBiID0gT2JqZWN0LmFzc2lnbih7fSwgcmVjdCwge1xuICAgICAgICB5OiByZWN0LnkgKyBoZWlnaHQsXG4gICAgICAgIGhlaWdodDogcmVjdC5oZWlnaHQgLSBoZWlnaHQsXG4gICAgfSk7XG4gICAgcmV0dXJuIFthLCBiXTtcbn07XG5cbi8qKlxuICogQ3JvcCB1cHBlciBzZWN0aW9uIG9mIHJlY3RcbiAqXG4gKiBAcGFyYW0gaGVpZ2h0IC0gSGVpZ2h0XG4gKiBAcGFyYW0gcmVjdCAtIFJlY3RcbiAqIEByZXR1cm5zIENyb3BwZWQgcmVjdFxuICovXG5jb25zdCBjcm9wID0gKGhlaWdodCwgcmVjdCkgPT4ge1xuICAgIGNvbnN0IFssIHJlc3VsdF0gPSBwYXJ0aXRpb24ocmVjdCwgaGVpZ2h0KTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBHZXQgcGFyYWdyYXBoIGJsb2NrIGhlaWdodFxuICpcbiAqIEBwYXJhbSBwYXJhZ3JhcGggLSBQYXJhZ3JhcGhcbiAqIEByZXR1cm5zIFBhcmFncmFwaCBibG9jayBoZWlnaHRcbiAqL1xuY29uc3QgaGVpZ2h0JDIgPSAocGFyYWdyYXBoKSA9PiB7XG4gICAgcmV0dXJuIHBhcmFncmFwaC5yZWR1Y2UoKGFjYywgYmxvY2spID0+IGFjYyArIGJsb2NrLmJveC5oZWlnaHQsIDApO1xufTtcblxuLyoqXG4gKiBDYWxjdWxhdGUgcnVuIHNjYWxlXG4gKlxuICogQHBhcmFtIHJ1biAtIFJ1blxuICogQHJldHVybnMgU2NhbGVcbiAqL1xuY29uc3QgY2FsY3VsYXRlU2NhbGUgPSAocnVuKSA9PiB7XG4gICAgY29uc3QgYXR0cmlidXRlcyA9IHJ1bi5hdHRyaWJ1dGVzIHx8IHt9O1xuICAgIGNvbnN0IGZvbnRTaXplID0gYXR0cmlidXRlcy5mb250U2l6ZSB8fCAxMjtcbiAgICBjb25zdCBmb250ID0gYXR0cmlidXRlcy5mb250O1xuICAgIGNvbnN0IHVuaXRzUGVyRW0gPSB0eXBlb2YgZm9udCA9PT0gJ3N0cmluZycgPyBudWxsIDogZm9udD8uWzBdPy51bml0c1BlckVtO1xuICAgIHJldHVybiB1bml0c1BlckVtID8gZm9udFNpemUgLyB1bml0c1BlckVtIDogMDtcbn07XG4vKipcbiAqIEdldCBydW4gc2NhbGVcbiAqXG4gKiBAcGFyYW0gIHJ1blxuICogQHJldHVybnMgU2NhbGVcbiAqL1xuY29uc3Qgc2NhbGUgPSAocnVuKSA9PiB7XG4gICAgcmV0dXJuIHJ1bi5hdHRyaWJ1dGVzPy5zY2FsZSB8fCBjYWxjdWxhdGVTY2FsZShydW4pO1xufTtcblxuLyoqXG4gKiBHZXQgbGlnYXR1cmUgb2Zmc2V0IGJ5IGluZGV4XG4gKlxuICogRXguIGZmaSBsaWdhdHVyZVxuICpcbiAqICAgZ2x5cGhzOiAgICAgICAgIGwgIG8gIGYgIGYgIGkgIG1cbiAqICAgZ2x5cGhJbmRpY2VzOiAgIDAgIDEgIDIgIDIgIDIgIDNcbiAqICAgb2Zmc2V0OiAgICAgICAgIDAgIDAgIDAgIDEgIDIgIDBcbiAqXG4gKiBAcGFyYW0gaW5kZXhcbiAqIEBwYXJhbSBydW4gLSBSdW5cbiAqIEByZXR1cm5zIExpZ2F0dXJlIG9mZnNldFxuICovXG5jb25zdCBvZmZzZXQgPSAoaW5kZXgsIHJ1bikgPT4ge1xuICAgIGlmICghcnVuKVxuICAgICAgICByZXR1cm4gMDtcbiAgICBjb25zdCBnbHlwaEluZGljZXMgPSBydW4uZ2x5cGhJbmRpY2VzIHx8IFtdO1xuICAgIGNvbnN0IHZhbHVlID0gZ2x5cGhJbmRpY2VzW2luZGV4XTtcbiAgICByZXR1cm4gZ2x5cGhJbmRpY2VzLnNsaWNlKDAsIGluZGV4KS5maWx0ZXIoKGkpID0+IGkgPT09IHZhbHVlKS5sZW5ndGg7XG59O1xuXG4vKipcbiAqIEdldCBydW4gZm9udFxuICpcbiAqIEBwYXJhbSBydW4gLSBSdW5cbiAqIEByZXR1cm5zIEZvbnRcbiAqL1xuY29uc3QgZ2V0Rm9udCA9IChydW4pID0+IHtcbiAgICByZXR1cm4gcnVuLmF0dHJpYnV0ZXM/LmZvbnQ/LlswXSB8fCBudWxsO1xufTtcblxuLyoqXG4gKiBTbGljZSBnbHlwaCBiZXR3ZWVuIGNvZGVQb2ludHMgcmFuZ2VcbiAqIFV0aWwgZm9yIGJyZWFraW5nIGxpZ2F0dXJlc1xuICpcbiAqIEBwYXJhbSBzdGFydCAtIFN0YXJ0IGNvZGUgcG9pbnQgaW5kZXhcbiAqIEBwYXJhbSBlbmQgLSBFbmQgY29kZSBwb2ludCBpbmRleFxuICogQHBhcmFtIGZvbnQgLSBGb250IHRvIGdlbmVyYXRlIG5ldyBnbHlwaFxuICogQHBhcmFtIGdseXBoIC0gR2x5cGggdG8gYmUgc2xpY2VkXG4gKiBAcmV0dXJucyBTbGljZWQgZ2x5cGggcGFydHNcbiAqL1xuY29uc3Qgc2xpY2UkMiA9IChzdGFydCwgZW5kLCBmb250LCBnbHlwaCkgPT4ge1xuICAgIGlmICghZ2x5cGgpXG4gICAgICAgIHJldHVybiBbXTtcbiAgICBpZiAoc3RhcnQgPT09IGVuZClcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIGlmIChzdGFydCA9PT0gMCAmJiBlbmQgPT09IGdseXBoLmNvZGVQb2ludHMubGVuZ3RoKVxuICAgICAgICByZXR1cm4gW2dseXBoXTtcbiAgICBjb25zdCBjb2RlUG9pbnRzID0gZ2x5cGguY29kZVBvaW50cy5zbGljZShzdGFydCwgZW5kKTtcbiAgICBjb25zdCBzdHJpbmcgPSBTdHJpbmcuZnJvbUNvZGVQb2ludCguLi5jb2RlUG9pbnRzKTtcbiAgICAvLyBwYXNzaW5nIExUUiBUbyBmb3JjZSBmb250a2l0IHRvIG5vdCByZXZlcnNlIHRoZSBzdHJpbmdcbiAgICByZXR1cm4gZm9udFxuICAgICAgICA/IGZvbnQubGF5b3V0KHN0cmluZywgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgJ2x0cicpLmdseXBoc1xuICAgICAgICA6IFtnbHlwaF07XG59O1xuXG4vKipcbiAqIFJldHVybiBnbHlwaCBpbmRleCBhdCBzdHJpbmcgaW5kZXgsIGlmIGdseXBoIGluZGljZXMgcHJlc2VudC5cbiAqIE90aGVyd2lzZSByZXR1cm4gc3RyaW5nIGluZGV4XG4gKlxuICogQHBhcmFtIGluZGV4IC0gSW5kZXhcbiAqIEBwYXJhbSBydW4gLSBSdW5cbiAqIEByZXR1cm5zIEdseXBoIGluZGV4XG4gKi9cbmNvbnN0IGdseXBoSW5kZXhBdCA9IChpbmRleCwgcnVuKSA9PiB7XG4gICAgY29uc3QgcmVzdWx0ID0gcnVuPy5nbHlwaEluZGljZXM/LltpbmRleF07XG4gICAgcmV0dXJuIGlzTmlsKHJlc3VsdCkgPyBpbmRleCA6IHJlc3VsdDtcbn07XG5cbi8qKlxuICogUmV0dXJucyBuZXcgYXJyYXkgc3RhcnRpbmcgd2l0aCB6ZXJvLCBhbmQga2VlcGluZyBzYW1lIHJlbGF0aW9uIGJldHdlZW4gY29uc2VjdXRpdmUgdmFsdWVzXG4gKlxuICogQHBhcmFtIGFycmF5IC0gTGlzdFxuICogQHJldHVybnMgTm9ybWFsaXplZCBhcnJheVxuICovXG5jb25zdCBub3JtYWxpemUgPSAoYXJyYXkpID0+IHtcbiAgICBjb25zdCBoZWFkID0gYXJyYXlbMF07XG4gICAgcmV0dXJuIGFycmF5Lm1hcCgodmFsdWUpID0+IHZhbHVlIC0gaGVhZCk7XG59O1xuXG4vKipcbiAqIFNsaWNlIHJ1biBiZXR3ZWVuIGdseXBoIGluZGljZXMgcmFuZ2VcbiAqXG4gKiBAcGFyYW0gc3RhcnQgLSBHbHlwaCBpbmRleFxuICogQHBhcmFtIGVuZCAtIEdseXBoIGluZGV4XG4gKiBAcGFyYW0gcnVuIC0gUnVuXG4gKiBAcmV0dXJucyBTbGljZWQgcnVuXG4gKi9cbmNvbnN0IHNsaWNlJDEgPSAoc3RhcnQsIGVuZCwgcnVuKSA9PiB7XG4gICAgY29uc3QgcnVuU2NhbGUgPSBzY2FsZShydW4pO1xuICAgIGNvbnN0IGZvbnQgPSBnZXRGb250KHJ1bik7XG4gICAgLy8gR2V0IGdseXBoIHN0YXJ0IGFuZCBlbmQgaW5kaWNlc1xuICAgIGNvbnN0IHN0YXJ0SW5kZXggPSBnbHlwaEluZGV4QXQoc3RhcnQsIHJ1bik7XG4gICAgY29uc3QgZW5kSW5kZXggPSBnbHlwaEluZGV4QXQoZW5kLCBydW4pO1xuICAgIC8vIEdldCBzdGFydCBhbmQgZW5kIGdseXBoXG4gICAgY29uc3Qgc3RhcnRHbHlwaCA9IHJ1bi5nbHlwaHM/LltzdGFydEluZGV4XTtcbiAgICBjb25zdCBlbmRHbHlwaCA9IHJ1bi5nbHlwaHM/LltlbmRJbmRleF07XG4gICAgLy8gR2V0IHN0YXJ0IGxpZ2F0dXJlIGNodW5rcyAoaWYgYW55KVxuICAgIGNvbnN0IHN0YXJ0T2Zmc2V0ID0gb2Zmc2V0KHN0YXJ0LCBydW4pO1xuICAgIGNvbnN0IHN0YXJ0R2x5cGhzID0gc3RhcnRPZmZzZXQgPiAwID8gc2xpY2UkMihzdGFydE9mZnNldCwgSW5maW5pdHksIGZvbnQsIHN0YXJ0R2x5cGgpIDogW107XG4gICAgLy8gR2V0IGVuZCBsaWdhdHVyZSBjaHVua3MgKGlmIGFueSlcbiAgICBjb25zdCBlbmRPZmZzZXQgPSBvZmZzZXQoZW5kLCBydW4pO1xuICAgIGNvbnN0IGVuZEdseXBocyA9IHNsaWNlJDIoMCwgZW5kT2Zmc2V0LCBmb250LCBlbmRHbHlwaCk7XG4gICAgLy8gQ29tcHV0ZSBuZXcgZ2x5cGhzXG4gICAgY29uc3Qgc2xpY2VTdGFydCA9IHN0YXJ0SW5kZXggKyBNYXRoLm1pbigxLCBzdGFydE9mZnNldCk7XG4gICAgY29uc3QgZ2x5cGhzID0gKHJ1bi5nbHlwaHMgfHwgW10pLnNsaWNlKHNsaWNlU3RhcnQsIGVuZEluZGV4KTtcbiAgICAvLyBDb21wdXRlIG5ldyBwb3NpdGlvbnNcbiAgICBjb25zdCBnbHlwaFBvc2l0aW9uID0gKGcpID0+ICh7XG4gICAgICAgIHhBZHZhbmNlOiBnLmFkdmFuY2VXaWR0aCAqIHJ1blNjYWxlLFxuICAgICAgICB5QWR2YW5jZTogMCxcbiAgICAgICAgeE9mZnNldDogMCxcbiAgICAgICAgeU9mZnNldDogMCxcbiAgICB9KTtcbiAgICBjb25zdCBzdGFydFBvc2l0aW9ucyA9IHN0YXJ0R2x5cGhzLm1hcChnbHlwaFBvc2l0aW9uKTtcbiAgICBjb25zdCBwb3NpdGlvbnMgPSAocnVuLnBvc2l0aW9ucyB8fCBbXSkuc2xpY2Uoc2xpY2VTdGFydCwgZW5kSW5kZXgpO1xuICAgIGNvbnN0IGVuZFBvc2l0aW9ucyA9IGVuZEdseXBocy5tYXAoZ2x5cGhQb3NpdGlvbik7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIHJ1biwge1xuICAgICAgICBzdGFydDogcnVuLnN0YXJ0ICsgc3RhcnQsXG4gICAgICAgIGVuZDogTWF0aC5taW4ocnVuLmVuZCwgcnVuLnN0YXJ0ICsgZW5kKSxcbiAgICAgICAgZ2x5cGhJbmRpY2VzOiBub3JtYWxpemUoKHJ1bi5nbHlwaEluZGljZXMgfHwgW10pLnNsaWNlKHN0YXJ0LCBlbmQpKSxcbiAgICAgICAgZ2x5cGhzOiBbc3RhcnRHbHlwaHMsIGdseXBocywgZW5kR2x5cGhzXS5mbGF0KCksXG4gICAgICAgIHBvc2l0aW9uczogW3N0YXJ0UG9zaXRpb25zLCBwb3NpdGlvbnMsIGVuZFBvc2l0aW9uc10uZmxhdCgpLFxuICAgIH0pO1xufTtcblxuLyoqXG4gKiBHZXQgcnVuIGluZGV4IHRoYXQgY29udGFpbnMgcGFzc2VkIGluZGV4XG4gKlxuICogQHBhcmFtIGluZGV4IC0gSW5kZXhcbiAqIEBwYXJhbSBydW5zIC0gUnVuc1xuICogQHJldHVybnMgUnVuIGluZGV4XG4gKi9cbmNvbnN0IHJ1bkluZGV4QXQkMSA9IChpbmRleCwgcnVucykgPT4ge1xuICAgIGlmICghcnVucylcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIHJldHVybiBydW5zLmZpbmRJbmRleCgocnVuKSA9PiBydW4uc3RhcnQgPD0gaW5kZXggJiYgaW5kZXggPCBydW4uZW5kKTtcbn07XG5cbi8qKlxuICogRmlsdGVyIHJ1bnMgY29udGFpbmVkIGJldHdlZW4gc3RhcnQgYW5kIGVuZFxuICpcbiAqIEBwYXJhbSBzdGFydFxuICogQHBhcmFtIGVuZFxuICogQHBhcmFtIHJ1bnNcbiAqIEByZXR1cm5zIEZpbHRlcmVkIHJ1bnNcbiAqL1xuY29uc3QgZmlsdGVyID0gKHN0YXJ0LCBlbmQsIHJ1bnMpID0+IHtcbiAgICBjb25zdCBzdGFydEluZGV4ID0gcnVuSW5kZXhBdCQxKHN0YXJ0LCBydW5zKTtcbiAgICBjb25zdCBlbmRJbmRleCA9IE1hdGgubWF4KHJ1bkluZGV4QXQkMShlbmQgLSAxLCBydW5zKSwgc3RhcnRJbmRleCk7XG4gICAgcmV0dXJuIHJ1bnMuc2xpY2Uoc3RhcnRJbmRleCwgZW5kSW5kZXggKyAxKTtcbn07XG5cbi8qKlxuICogU3VidHJhY3Qgc2NhbGFyIHRvIHJ1blxuICpcbiAqIEBwYXJhbSBpbmRleCAtIFNjYWxhclxuICogQHBhcmFtIHJ1biAtIFJ1blxuICogQHJldHVybnMgU3VidHJhY3RlZCBydW5cbiAqL1xuY29uc3Qgc3VidHJhY3QgPSAoaW5kZXgsIHJ1bikgPT4ge1xuICAgIGNvbnN0IHN0YXJ0ID0gcnVuLnN0YXJ0IC0gaW5kZXg7XG4gICAgY29uc3QgZW5kID0gcnVuLmVuZCAtIGluZGV4O1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBydW4sIHsgc3RhcnQsIGVuZCB9KTtcbn07XG5cbi8qKlxuICogU2xpY2UgYXJyYXkgb2YgcnVuc1xuICpcbiAqIEBwYXJhbSBzdGFydCAtIE9mZnNldFxuICogQHBhcmFtIGVuZCAtIE9mZnNldFxuICogQHBhcmFtIHJ1bnNcbiAqIEByZXR1cm5zIFNsaWNlZCBydW5zXG4gKi9cbmNvbnN0IHNsaWNlUnVucyA9IChzdGFydCwgZW5kLCBydW5zKSA9PiB7XG4gICAgY29uc3Qgc2xpY2VGaXJzdFJ1biA9IChhKSA9PiBzbGljZSQxKHN0YXJ0IC0gYS5zdGFydCwgZW5kIC0gYS5zdGFydCwgYSk7XG4gICAgY29uc3Qgc2xpY2VMYXN0UnVuID0gKGEpID0+IHNsaWNlJDEoMCwgZW5kIC0gYS5zdGFydCwgYSk7XG4gICAgcmV0dXJuIHJ1bnMubWFwKChydW4sIGkpID0+IHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHJ1bjtcbiAgICAgICAgY29uc3QgaXNGaXJzdCA9IGkgPT09IDA7XG4gICAgICAgIGNvbnN0IGlzTGFzdCA9ICFpc0ZpcnN0ICYmIGkgPT09IHJ1bnMubGVuZ3RoIC0gMTtcbiAgICAgICAgaWYgKGlzRmlyc3QpXG4gICAgICAgICAgICByZXN1bHQgPSBzbGljZUZpcnN0UnVuKHJ1bik7XG4gICAgICAgIGlmIChpc0xhc3QpXG4gICAgICAgICAgICByZXN1bHQgPSBzbGljZUxhc3RSdW4ocnVuKTtcbiAgICAgICAgcmV0dXJuIHN1YnRyYWN0KHN0YXJ0LCByZXN1bHQpO1xuICAgIH0pO1xufTtcbi8qKlxuICogU2xpY2UgYXR0cmlidXRlZCBzdHJpbmcgYmV0d2VlbiB0d28gaW5kaWNlc1xuICpcbiAqIEBwYXJhbSBzdGFydCAtIE9mZnNldFxuICogQHBhcmFtIGVuZCAtIE9mZnNldFxuICogQHBhcmFtIGF0dHJpYnV0ZWRTdHJpbmcgLSBBdHRyaWJ1dGVkIHN0cmluZ1xuICogQHJldHVybnMgQXR0cmlidXRlZCBzdHJpbmdcbiAqL1xuY29uc3Qgc2xpY2UgPSAoc3RhcnQsIGVuZCwgYXR0cmlidXRlZFN0cmluZykgPT4ge1xuICAgIGlmIChhdHRyaWJ1dGVkU3RyaW5nLnN0cmluZy5sZW5ndGggPT09IDApXG4gICAgICAgIHJldHVybiBhdHRyaWJ1dGVkU3RyaW5nO1xuICAgIGNvbnN0IHN0cmluZyA9IGF0dHJpYnV0ZWRTdHJpbmcuc3RyaW5nLnNsaWNlKHN0YXJ0LCBlbmQpO1xuICAgIGNvbnN0IGZpbHRlcmVkUnVucyA9IGZpbHRlcihzdGFydCwgZW5kLCBhdHRyaWJ1dGVkU3RyaW5nLnJ1bnMpO1xuICAgIGNvbnN0IHNsaWNlZFJ1bnMgPSBzbGljZVJ1bnMoc3RhcnQsIGVuZCwgZmlsdGVyZWRSdW5zKTtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgYXR0cmlidXRlZFN0cmluZywgeyBzdHJpbmcsIHJ1bnM6IHNsaWNlZFJ1bnMgfSk7XG59O1xuXG5jb25zdCBmaW5kQ2hhckluZGV4ID0gKHN0cmluZykgPT4ge1xuICAgIHJldHVybiBzdHJpbmcuc2VhcmNoKC9cXFMvZyk7XG59O1xuY29uc3QgZmluZExhc3RDaGFySW5kZXggPSAoc3RyaW5nKSA9PiB7XG4gICAgY29uc3QgbWF0Y2ggPSBzdHJpbmcubWF0Y2goL1xcUy9nKTtcbiAgICByZXR1cm4gbWF0Y2ggPyBzdHJpbmcubGFzdEluZGV4T2YobWF0Y2hbbWF0Y2gubGVuZ3RoIC0gMV0pIDogLTE7XG59O1xuLyoqXG4gKiBSZW1vdmVzIChzdHJpcHMpIHdoaXRlc3BhY2UgZnJvbSBib3RoIGVuZHMgb2YgdGhlIGF0dHJpYnV0dGVkIHN0cmluZy5cbiAqXG4gKiBAcGFyYW0gYXR0cmlidXRlZFN0cmluZyAtIEF0dHJpYnV0ZWQgc3RyaW5nXG4gKiBAcmV0dXJucyBBdHRyaWJ1dGVkIHN0cmluZ1xuICovXG5jb25zdCB0cmltID0gKGF0dHJpYnV0ZWRTdHJpbmcpID0+IHtcbiAgICBjb25zdCBzdGFydCA9IGZpbmRDaGFySW5kZXgoYXR0cmlidXRlZFN0cmluZy5zdHJpbmcpO1xuICAgIGNvbnN0IGVuZCA9IGZpbmRMYXN0Q2hhckluZGV4KGF0dHJpYnV0ZWRTdHJpbmcuc3RyaW5nKTtcbiAgICByZXR1cm4gc2xpY2Uoc3RhcnQsIGVuZCArIDEsIGF0dHJpYnV0ZWRTdHJpbmcpO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIGVtcHR5IHJ1blxuICpcbiAqIEByZXR1cm5zIEVtcHR5IHJ1blxuICovXG5jb25zdCBlbXB0eSQxID0gKCkgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICAgIHN0YXJ0OiAwLFxuICAgICAgICBlbmQ6IDAsXG4gICAgICAgIGdseXBoSW5kaWNlczogW10sXG4gICAgICAgIGdseXBoczogW10sXG4gICAgICAgIHBvc2l0aW9uczogW10sXG4gICAgICAgIGF0dHJpYnV0ZXM6IHt9LFxuICAgIH07XG59O1xuXG4vKipcbiAqIENoZWNrIGlmIHZhbHVlIGlzIGEgbnVtYmVyXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVmFsdWUgdG8gY2hlY2tcbiAqIEByZXR1cm5zIFdoZXRoZXIgdmFsdWUgaXMgYSBudW1iZXJcbiAqL1xuY29uc3QgaXNOdW1iZXIgPSAodmFsdWUpID0+IHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJztcbn07XG5cbi8qKlxuICogQXBwZW5kIGdseXBoIGluZGljZXMgd2l0aCBnaXZlbiBsZW5ndGhcbiAqXG4gKiBFeC4gYXBwZW5kSW5kaWNlcygzLCBbMCwgMSwgMiwgMl0pID0+IFswLCAxLCAyLCAyLCAzLCAzLCAzXVxuICpcbiAqIEBwYXJhbSBsZW5ndGggLSBMZW5ndGhcbiAqIEBwYXJhbSBpbmRpY2VzIC0gR2x5cGggaW5kaWNlc1xuICogQHJldHVybnMgRXh0ZW5kZWQgZ2x5cGggaW5kaWNlc1xuICovXG5jb25zdCBhcHBlbmRJbmRpY2VzID0gKGxlbmd0aCwgaW5kaWNlcykgPT4ge1xuICAgIGNvbnN0IGxhc3RJbmRleCA9IGxhc3QoaW5kaWNlcyk7XG4gICAgY29uc3QgdmFsdWUgPSBpc05pbChsYXN0SW5kZXgpID8gMCA6IGxhc3RJbmRleCArIDE7XG4gICAgY29uc3QgbmV3SW5kaWNlcyA9IEFycmF5KGxlbmd0aCkuZmlsbCh2YWx1ZSk7XG4gICAgcmV0dXJuIGluZGljZXMuY29uY2F0KG5ld0luZGljZXMpO1xufTtcblxuLyoqXG4gKiBHZXQgZ2x5cGggZm9yIGEgZ2l2ZW4gY29kZSBwb2ludFxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIENvZGVQb2ludFxuICogQHBhcmFtIGZvbnQgLSBGb250XG4gKiBAcmV0dXJucyBHbHlwaFxuICogKi9cbmNvbnN0IGZyb21Db2RlUG9pbnQgPSAodmFsdWUsIGZvbnQpID0+IHtcbiAgICBpZiAodHlwZW9mIGZvbnQgPT09ICdzdHJpbmcnKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICByZXR1cm4gZm9udCAmJiB2YWx1ZSA/IGZvbnQuZ2x5cGhGb3JDb2RlUG9pbnQodmFsdWUpIDogbnVsbDtcbn07XG5cbi8qKlxuICogQXBwZW5kIGdseXBoIHRvIHJ1blxuICpcbiAqIEBwYXJhbSBnbHlwaCAtIEdseXBoXG4gKiBAcGFyYW0gcnVuIC0gUnVuXG4gKiBAcmV0dXJucyBSdW4gd2l0aCBnbHlwaFxuICovXG5jb25zdCBhcHBlbmRHbHlwaCA9IChnbHlwaCwgcnVuKSA9PiB7XG4gICAgY29uc3QgZ2x5cGhMZW5ndGggPSBnbHlwaC5jb2RlUG9pbnRzPy5sZW5ndGggfHwgMDtcbiAgICBjb25zdCBlbmQgPSBydW4uZW5kICsgZ2x5cGhMZW5ndGg7XG4gICAgY29uc3QgZ2x5cGhzID0gcnVuLmdseXBocy5jb25jYXQoZ2x5cGgpO1xuICAgIGNvbnN0IGdseXBoSW5kaWNlcyA9IGFwcGVuZEluZGljZXMoZ2x5cGhMZW5ndGgsIHJ1bi5nbHlwaEluZGljZXMpO1xuICAgIGlmICghcnVuLnBvc2l0aW9ucylcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIHJ1biwgeyBlbmQsIGdseXBocywgZ2x5cGhJbmRpY2VzIH0pO1xuICAgIGNvbnN0IHBvc2l0aW9ucyA9IHJ1bi5wb3NpdGlvbnMuY29uY2F0KHtcbiAgICAgICAgeEFkdmFuY2U6IGdseXBoLmFkdmFuY2VXaWR0aCAqIHNjYWxlKHJ1biksXG4gICAgICAgIHlBZHZhbmNlOiAwLFxuICAgICAgICB4T2Zmc2V0OiAwLFxuICAgICAgICB5T2Zmc2V0OiAwLFxuICAgIH0pO1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBydW4sIHsgZW5kLCBnbHlwaHMsIGdseXBoSW5kaWNlcywgcG9zaXRpb25zIH0pO1xufTtcbi8qKlxuICogQXBwZW5kIGdseXBoIG9yIGNvZGUgcG9pbnQgdG8gcnVuXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gR2x5cGggb3IgY29kZVBvaW50XG4gKiBAcGFyYW0gcnVuIC0gUnVuXG4gKiBAcmV0dXJucyBSdW4gd2l0aCBnbHlwaFxuICovXG5jb25zdCBhcHBlbmQkMSA9ICh2YWx1ZSwgcnVuKSA9PiB7XG4gICAgaWYgKCF2YWx1ZSlcbiAgICAgICAgcmV0dXJuIHJ1bjtcbiAgICBjb25zdCBmb250ID0gZ2V0Rm9udChydW4pO1xuICAgIGNvbnN0IGdseXBoID0gaXNOdW1iZXIodmFsdWUpID8gZnJvbUNvZGVQb2ludCh2YWx1ZSwgZm9udCkgOiB2YWx1ZTtcbiAgICByZXR1cm4gYXBwZW5kR2x5cGgoZ2x5cGgsIHJ1bik7XG59O1xuXG4vKipcbiAqIEdldCBzdHJpbmcgZnJvbSBhcnJheSBvZiBjb2RlIHBvaW50c1xuICpcbiAqIEBwYXJhbSBjb2RlUG9pbnRzIC0gUG9pbnRzXG4gKiBAcmV0dXJucyBTdHJpbmdcbiAqL1xuY29uc3Qgc3RyaW5nRnJvbUNvZGVQb2ludHMgPSAoY29kZVBvaW50cykgPT4ge1xuICAgIHJldHVybiBTdHJpbmcuZnJvbUNvZGVQb2ludCguLi4oY29kZVBvaW50cyB8fCBbXSkpO1xufTtcblxuLyoqXG4gKiBBcHBlbmQgZ2x5cGggaW50byBsYXN0IHJ1biBvZiBhdHRyaWJ1dGVkIHN0cmluZ1xuICpcbiAqIEBwYXJhbSBnbHlwaCAtIEdseXBoIG9yIGNvZGUgcG9pbnRcbiAqIEBwYXJhbSBhdHRyaWJ1dGVkU3RyaW5nIC0gQXR0cmlidXRlZCBzdHJpbmdcbiAqIEByZXR1cm5zIEF0dHJpYnV0ZWQgc3RyaW5nIHdpdGggbmV3IGdseXBoXG4gKi9cbmNvbnN0IGFwcGVuZCA9IChnbHlwaCwgYXR0cmlidXRlZFN0cmluZykgPT4ge1xuICAgIGNvbnN0IGNvZGVQb2ludHMgPSB0eXBlb2YgZ2x5cGggPT09ICdudW1iZXInID8gW2dseXBoXSA6IGdseXBoPy5jb2RlUG9pbnRzO1xuICAgIGNvbnN0IGNvZGVQb2ludHNTdHJpbmcgPSBzdHJpbmdGcm9tQ29kZVBvaW50cyhjb2RlUG9pbnRzIHx8IFtdKTtcbiAgICBjb25zdCBzdHJpbmcgPSBhdHRyaWJ1dGVkU3RyaW5nLnN0cmluZyArIGNvZGVQb2ludHNTdHJpbmc7XG4gICAgY29uc3QgZmlyc3RSdW5zID0gYXR0cmlidXRlZFN0cmluZy5ydW5zLnNsaWNlKDAsIC0xKTtcbiAgICBjb25zdCBsYXN0UnVuID0gbGFzdChhdHRyaWJ1dGVkU3RyaW5nLnJ1bnMpIHx8IGVtcHR5JDEoKTtcbiAgICBjb25zdCBydW5zID0gZmlyc3RSdW5zLmNvbmNhdChhcHBlbmQkMShnbHlwaCwgbGFzdFJ1bikpO1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBhdHRyaWJ1dGVkU3RyaW5nLCB7IHN0cmluZywgcnVucyB9KTtcbn07XG5cbmNvbnN0IEVMTElQU0lTX1VOSUNPREUgPSA4MjMwO1xuY29uc3QgRUxMSVBTSVNfU1RSSU5HID0gU3RyaW5nLmZyb21DaGFyQ29kZShFTExJUFNJU19VTklDT0RFKTtcbi8qKlxuICogR2V0IGVsbGlwc2lzIGNvZGVwb2ludC4gVGhpcyBtYXkgYmUgZGlmZmVyZW50IGluIHN0YW5kYXJkIGFuZCBlbWJlZGRlZCBmb250c1xuICpcbiAqIEBwYXJhbSBmb250XG4gKiBAcmV0dXJucyBFbGxpcHNpcyBjb2RlcG9pbnRcbiAqL1xuY29uc3QgZ2V0RWxsaXBzaXNDb2RlUG9pbnQgPSAoZm9udCkgPT4ge1xuICAgIGlmICghZm9udC5lbmNvZGUpXG4gICAgICAgIHJldHVybiBFTExJUFNJU19VTklDT0RFO1xuICAgIGNvbnN0IFtjb2RlUG9pbnRzXSA9IGZvbnQuZW5jb2RlKEVMTElQU0lTX1NUUklORyk7XG4gICAgcmV0dXJuIHBhcnNlSW50KGNvZGVQb2ludHNbMF0sIDE2KTtcbn07XG4vKipcbiAqIFRydWNhbnRlIGJsb2NrIHdpdGggZWxsaXBzaXNcbiAqXG4gKiBAcGFyYW0gcGFyYWdyYXBoIC0gUGFyYWdyYXBoXG4gKiBAcmV0dXJucyBTbGljZWQgcGFyYWdyYXBoXG4gKi9cbmNvbnN0IHRydW5jYXRlID0gKHBhcmFncmFwaCkgPT4ge1xuICAgIGNvbnN0IHJ1bnMgPSBsYXN0KHBhcmFncmFwaCk/LnJ1bnMgfHwgW107XG4gICAgY29uc3QgZm9udCA9IGxhc3QocnVucyk/LmF0dHJpYnV0ZXM/LmZvbnRbMF07XG4gICAgaWYgKGZvbnQpIHtcbiAgICAgICAgY29uc3QgaW5kZXggPSBwYXJhZ3JhcGgubGVuZ3RoIC0gMTtcbiAgICAgICAgY29uc3QgY29kZVBvaW50ID0gZ2V0RWxsaXBzaXNDb2RlUG9pbnQoZm9udCk7XG4gICAgICAgIGNvbnN0IGdseXBoID0gZm9udC5nbHlwaEZvckNvZGVQb2ludChjb2RlUG9pbnQpO1xuICAgICAgICBjb25zdCBsYXN0QmxvY2sgPSBhcHBlbmQoZ2x5cGgsIHRyaW0ocGFyYWdyYXBoW2luZGV4XSkpO1xuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihbXSwgcGFyYWdyYXBoLCB7IFtpbmRleF06IGxhc3RCbG9jayB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHBhcmFncmFwaDtcbn07XG5cbi8qKlxuICogT21pdCBhdHRyaWJ1dGUgZnJvbSBydW5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBBdHRyaWJ1dGUga2V5XG4gKiBAcGFyYW0gcnVuIC0gUnVuXG4gKiBAcmV0dXJucyBSdW4gd2l0aG91dCBvbW1pdGVkIGF0dHJpYnV0ZVxuICovXG5jb25zdCBvbWl0ID0gKHZhbHVlLCBydW4pID0+IHtcbiAgICBjb25zdCBhdHRyaWJ1dGVzID0gT2JqZWN0LmFzc2lnbih7fSwgcnVuLmF0dHJpYnV0ZXMpO1xuICAgIGRlbGV0ZSBhdHRyaWJ1dGVzW3ZhbHVlXTtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgcnVuLCB7IGF0dHJpYnV0ZXMgfSk7XG59O1xuXG4vKipcbiAqIEdldCBydW4gYXNjZW50XG4gKlxuICogQHBhcmFtIHJ1biAtIFJ1blxuICogQHJldHVybnMgQXNjZW50XG4gKi9cbmNvbnN0IGFzY2VudCQxID0gKHJ1bikgPT4ge1xuICAgIGNvbnN0IHsgZm9udCwgYXR0YWNobWVudCB9ID0gcnVuLmF0dHJpYnV0ZXM7XG4gICAgY29uc3QgYXR0YWNobWVudEhlaWdodCA9IGF0dGFjaG1lbnQ/LmhlaWdodCB8fCAwO1xuICAgIGNvbnN0IGZvbnRBc2NlbnQgPSB0eXBlb2YgZm9udCA9PT0gJ3N0cmluZycgPyAwIDogZm9udD8uWzBdPy5hc2NlbnQgfHwgMDtcbiAgICByZXR1cm4gTWF0aC5tYXgoYXR0YWNobWVudEhlaWdodCwgZm9udEFzY2VudCAqIHNjYWxlKHJ1bikpO1xufTtcblxuLyoqXG4gKiBHZXQgcnVuIGRlc2NlbnRcbiAqXG4gKiBAcGFyYW0gcnVuIC0gUnVuXG4gKiBAcmV0dXJucyBEZXNjZW50XG4gKi9cbmNvbnN0IGRlc2NlbnQgPSAocnVuKSA9PiB7XG4gICAgY29uc3QgZm9udCA9IHJ1bi5hdHRyaWJ1dGVzPy5mb250O1xuICAgIGNvbnN0IGZvbnREZXNjZW50ID0gdHlwZW9mIGZvbnQgPT09ICdzdHJpbmcnID8gMCA6IGZvbnQ/LlswXT8uZGVzY2VudCB8fCAwO1xuICAgIHJldHVybiBzY2FsZShydW4pICogZm9udERlc2NlbnQ7XG59O1xuXG4vKipcbiAqIEdldCBydW4gbGluZUdhcFxuICpcbiAqIEBwYXJhbSBydW4gLSBSdW5cbiAqIEByZXR1cm5zIExpbmVHYXBcbiAqL1xuY29uc3QgbGluZUdhcCA9IChydW4pID0+IHtcbiAgICBjb25zdCBmb250ID0gcnVuLmF0dHJpYnV0ZXM/LmZvbnQ7XG4gICAgY29uc3QgbGluZUdhcCA9IHR5cGVvZiBmb250ID09PSAnc3RyaW5nJyA/IDAgOiBmb250Py5bMF0/LmxpbmVHYXAgfHwgMDtcbiAgICByZXR1cm4gbGluZUdhcCAqIHNjYWxlKHJ1bik7XG59O1xuXG4vKipcbiAqIEdldCBydW4gaGVpZ2h0XG4gKlxuICogQHBhcmFtIHJ1biAtIFJ1blxuICogQHJldHVybnMgSGVpZ2h0XG4gKi9cbmNvbnN0IGhlaWdodCQxID0gKHJ1bikgPT4ge1xuICAgIGNvbnN0IGxpbmVIZWlnaHQgPSBydW4uYXR0cmlidXRlcz8ubGluZUhlaWdodDtcbiAgICByZXR1cm4gbGluZUhlaWdodCB8fCBsaW5lR2FwKHJ1bikgKyBhc2NlbnQkMShydW4pIC0gZGVzY2VudChydW4pO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIGF0dHJpYnV0ZWQgc3RyaW5nIGhlaWdodFxuICpcbiAqIEBwYXJhbSBhdHRyaWJ1dGVkU3RyaW5nIC0gQXR0cmlidXRlZCBzdHJpbmdcbiAqIEByZXR1cm5zIEhlaWdodFxuICovXG5jb25zdCBoZWlnaHQgPSAoYXR0cmlidXRlZFN0cmluZykgPT4ge1xuICAgIGNvbnN0IHJlZHVjZXIgPSAoYWNjLCBydW4pID0+IE1hdGgubWF4KGFjYywgaGVpZ2h0JDEocnVuKSk7XG4gICAgcmV0dXJuIGF0dHJpYnV0ZWRTdHJpbmcucnVucy5yZWR1Y2UocmVkdWNlciwgMCk7XG59O1xuXG4vKipcbiAqIENoZWNrcyBpZiB0d28gcmVjdHMgaW50ZXJzZWN0IGVhY2ggb3RoZXJcbiAqXG4gKiBAcGFyYW0gYSAtIFJlY3QgQVxuICogQHBhcmFtIGIgLSBSZWN0IEJcbiAqIEByZXR1cm5zIFdoZXRoZXIgcmVjdHMgaW50ZXJzZWN0XG4gKi9cbmNvbnN0IGludGVyc2VjdHMgPSAoYSwgYikgPT4ge1xuICAgIGNvbnN0IHggPSBNYXRoLm1heChhLngsIGIueCk7XG4gICAgY29uc3QgbnVtMSA9IE1hdGgubWluKGEueCArIGEud2lkdGgsIGIueCArIGIud2lkdGgpO1xuICAgIGNvbnN0IHkgPSBNYXRoLm1heChhLnksIGIueSk7XG4gICAgY29uc3QgbnVtMiA9IE1hdGgubWluKGEueSArIGEuaGVpZ2h0LCBiLnkgKyBiLmhlaWdodCk7XG4gICAgcmV0dXJuIG51bTEgPj0geCAmJiBudW0yID49IHk7XG59O1xuXG5jb25zdCBnZXRMaW5lRnJhZ21lbnQgPSAobGluZVJlY3QsIGV4Y2x1ZGVSZWN0KSA9PiB7XG4gICAgaWYgKCFpbnRlcnNlY3RzKGV4Y2x1ZGVSZWN0LCBsaW5lUmVjdCkpXG4gICAgICAgIHJldHVybiBbbGluZVJlY3RdO1xuICAgIGNvbnN0IGVTdGFydCA9IGV4Y2x1ZGVSZWN0Lng7XG4gICAgY29uc3QgZUVuZCA9IGV4Y2x1ZGVSZWN0LnggKyBleGNsdWRlUmVjdC53aWR0aDtcbiAgICBjb25zdCBsU3RhcnQgPSBsaW5lUmVjdC54O1xuICAgIGNvbnN0IGxFbmQgPSBsaW5lUmVjdC54ICsgbGluZVJlY3Qud2lkdGg7XG4gICAgY29uc3QgYSA9IE9iamVjdC5hc3NpZ24oe30sIGxpbmVSZWN0LCB7IHdpZHRoOiBlU3RhcnQgLSBsU3RhcnQgfSk7XG4gICAgY29uc3QgYiA9IE9iamVjdC5hc3NpZ24oe30sIGxpbmVSZWN0LCB7IHg6IGVFbmQsIHdpZHRoOiBsRW5kIC0gZUVuZCB9KTtcbiAgICByZXR1cm4gW2EsIGJdLmZpbHRlcigocikgPT4gci53aWR0aCA+IDApO1xufTtcbmNvbnN0IGdldExpbmVGcmFnbWVudHMgPSAocmVjdCwgZXhjbHVkZVJlY3RzKSA9PiB7XG4gICAgbGV0IGZyYWdtZW50cyA9IFtyZWN0XTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGV4Y2x1ZGVSZWN0cy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBjb25zdCBleGNsdWRlUmVjdCA9IGV4Y2x1ZGVSZWN0c1tpXTtcbiAgICAgICAgZnJhZ21lbnRzID0gZnJhZ21lbnRzLnJlZHVjZSgoYWNjLCBmcmFnbWVudCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcGllY2VzID0gZ2V0TGluZUZyYWdtZW50KGZyYWdtZW50LCBleGNsdWRlUmVjdCk7XG4gICAgICAgICAgICByZXR1cm4gYWNjLmNvbmNhdChwaWVjZXMpO1xuICAgICAgICB9LCBbXSk7XG4gICAgfVxuICAgIHJldHVybiBmcmFnbWVudHM7XG59O1xuY29uc3QgZ2VuZXJhdGVMaW5lUmVjdHMgPSAoY29udGFpbmVyLCBoZWlnaHQpID0+IHtcbiAgICBjb25zdCB7IGV4Y2x1ZGVSZWN0cywgLi4ucmVjdCB9ID0gY29udGFpbmVyO1xuICAgIGlmICghZXhjbHVkZVJlY3RzKVxuICAgICAgICByZXR1cm4gW3JlY3RdO1xuICAgIGNvbnN0IGxpbmVSZWN0cyA9IFtdO1xuICAgIGNvbnN0IG1heFkgPSBNYXRoLm1heCguLi5leGNsdWRlUmVjdHMubWFwKChyKSA9PiByLnkgKyByLmhlaWdodCkpO1xuICAgIGxldCBjdXJyZW50UmVjdCA9IHJlY3Q7XG4gICAgd2hpbGUgKGN1cnJlbnRSZWN0LnkgPCBtYXhZKSB7XG4gICAgICAgIGNvbnN0IFtsaW5lUmVjdCwgcmVzdF0gPSBwYXJ0aXRpb24oY3VycmVudFJlY3QsIGhlaWdodCk7XG4gICAgICAgIGNvbnN0IGxpbmVSZWN0RnJhZ21lbnRzID0gZ2V0TGluZUZyYWdtZW50cyhsaW5lUmVjdCwgZXhjbHVkZVJlY3RzKTtcbiAgICAgICAgY3VycmVudFJlY3QgPSByZXN0O1xuICAgICAgICBsaW5lUmVjdHMucHVzaCguLi5saW5lUmVjdEZyYWdtZW50cyk7XG4gICAgfVxuICAgIHJldHVybiBbLi4ubGluZVJlY3RzLCBjdXJyZW50UmVjdF07XG59O1xuXG5jb25zdCBBVFRBQ0hNRU5UX0NPREUkMSA9ICdcXHVmZmZjJzsgLy8gNjU1MzJcbi8qKlxuICogUmVtb3ZlIGF0dGFjaG1lbnQgYXR0cmlidXRlIGlmIG5vIGNoYXIgcHJlc2VudFxuICpcbiAqIEBwYXJhbSBsaW5lIC0gTGluZVxuICogQHJldHVybnMgTGluZVxuICovXG5jb25zdCBwdXJnZUF0dGFjaG1lbnRzID0gKGxpbmUpID0+IHtcbiAgICBjb25zdCBzaG91bGRQdXJnZSA9ICFsaW5lLnN0cmluZy5pbmNsdWRlcyhBVFRBQ0hNRU5UX0NPREUkMSk7XG4gICAgaWYgKCFzaG91bGRQdXJnZSlcbiAgICAgICAgcmV0dXJuIGxpbmU7XG4gICAgY29uc3QgcnVucyA9IGxpbmUucnVucy5tYXAoKHJ1bikgPT4gb21pdCgnYXR0YWNobWVudCcsIHJ1bikpO1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBsaW5lLCB7IHJ1bnMgfSk7XG59O1xuLyoqXG4gKiBMYXlvdXQgcGFyYWdyYXBocyBpbnNpZGUgcmVjdGFuZ2xlXG4gKlxuICogQHBhcmFtIHJlY3RzIC0gUmVjdHNcbiAqIEBwYXJhbSBsaW5lcyAtIEF0dHJpYnV0ZWQgc3RyaW5nc1xuICogQHBhcmFtIGluZGVudFxuICogQHJldHVybnMgbGF5b3V0IGJsb2Nrc1xuICovXG5jb25zdCBsYXlvdXRMaW5lcyA9IChyZWN0cywgbGluZXMsIGluZGVudCkgPT4ge1xuICAgIGxldCByZWN0ID0gcmVjdHMuc2hpZnQoKTtcbiAgICBsZXQgY3VycmVudFkgPSByZWN0Lnk7XG4gICAgcmV0dXJuIGxpbmVzLm1hcCgobGluZSwgaSkgPT4ge1xuICAgICAgICBjb25zdCBsaW5lSW5kZW50ID0gaSA9PT0gMCA/IGluZGVudCA6IDA7XG4gICAgICAgIGNvbnN0IHN0eWxlID0gbGluZS5ydW5zPy5bMF0/LmF0dHJpYnV0ZXMgfHwge307XG4gICAgICAgIGNvbnN0IGhlaWdodCQxID0gTWF0aC5tYXgoaGVpZ2h0KGxpbmUpLCBzdHlsZS5saW5lSGVpZ2h0KTtcbiAgICAgICAgaWYgKGN1cnJlbnRZICsgaGVpZ2h0JDEgPiByZWN0LnkgKyByZWN0LmhlaWdodCAmJiByZWN0cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICByZWN0ID0gcmVjdHMuc2hpZnQoKTtcbiAgICAgICAgICAgIGN1cnJlbnRZID0gcmVjdC55O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5ld0xpbmUgPSB7XG4gICAgICAgICAgICBzdHJpbmc6IGxpbmUuc3RyaW5nLFxuICAgICAgICAgICAgcnVuczogbGluZS5ydW5zLFxuICAgICAgICAgICAgYm94OiB7XG4gICAgICAgICAgICAgICAgeDogcmVjdC54ICsgbGluZUluZGVudCxcbiAgICAgICAgICAgICAgICB5OiBjdXJyZW50WSxcbiAgICAgICAgICAgICAgICB3aWR0aDogcmVjdC53aWR0aCAtIGxpbmVJbmRlbnQsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBoZWlnaHQkMSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgICAgIGN1cnJlbnRZICs9IGhlaWdodCQxO1xuICAgICAgICByZXR1cm4gcHVyZ2VBdHRhY2htZW50cyhuZXdMaW5lKTtcbiAgICB9KTtcbn07XG4vKipcbiAqIFBlcmZvcm1zIGxpbmUgYnJlYWtpbmcgYW5kIGxheW91dFxuICpcbiAqIEBwYXJhbSBlbmdpbmVzIC0gRW5naW5lc1xuICogQHBhcmFtIG9wdGlvbnMgLSBMYXlvdXQgb3B0aW9uc1xuICovXG5jb25zdCBsYXlvdXRQYXJhZ3JhcGggPSAoZW5naW5lcywgb3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIGNvbnRhaW5lciAtIENvbnRhaW5lclxuICAgICAqIEBwYXJhbSBwYXJhZ3JhcGggLSBBdHRyaWJ1dGVkIHN0cmluZ1xuICAgICAqIEByZXR1cm5zIExheW91dCBibG9ja1xuICAgICAqL1xuICAgIHJldHVybiAoY29udGFpbmVyLCBwYXJhZ3JhcGgpID0+IHtcbiAgICAgICAgY29uc3QgaGVpZ2h0JDEgPSBoZWlnaHQocGFyYWdyYXBoKTtcbiAgICAgICAgY29uc3QgaW5kZW50ID0gcGFyYWdyYXBoLnJ1bnM/LlswXT8uYXR0cmlidXRlcz8uaW5kZW50IHx8IDA7XG4gICAgICAgIGNvbnN0IHJlY3RzID0gZ2VuZXJhdGVMaW5lUmVjdHMoY29udGFpbmVyLCBoZWlnaHQkMSk7XG4gICAgICAgIGNvbnN0IGF2YWlsYWJsZVdpZHRocyA9IHJlY3RzLm1hcCgocikgPT4gci53aWR0aCk7XG4gICAgICAgIGF2YWlsYWJsZVdpZHRocy51bnNoaWZ0KGF2YWlsYWJsZVdpZHRoc1swXSAtIGluZGVudCk7XG4gICAgICAgIGNvbnN0IGxpbmVzID0gZW5naW5lcy5saW5lYnJlYWtlcihvcHRpb25zKShwYXJhZ3JhcGgsIGF2YWlsYWJsZVdpZHRocyk7XG4gICAgICAgIHJldHVybiBsYXlvdXRMaW5lcyhyZWN0cywgbGluZXMsIGluZGVudCk7XG4gICAgfTtcbn07XG5cbi8qKlxuICogU2xpY2UgYmxvY2sgYXQgZ2l2ZW4gaGVpZ2h0XG4gKlxuICogQHBhcmFtIGhlaWdodCAtIEhlaWdodFxuICogQHBhcmFtIHBhcmFncmFwaCAtIFBhcmFncmFwaFxuICogQHJldHVybnMgU2xpY2VkIHBhcmFncmFwaFxuICovXG5jb25zdCBzbGljZUF0SGVpZ2h0ID0gKGhlaWdodCwgcGFyYWdyYXBoKSA9PiB7XG4gICAgY29uc3QgbmV3QmxvY2sgPSBbXTtcbiAgICBsZXQgY291bnRlciA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXJhZ3JhcGgubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgY29uc3QgbGluZSA9IHBhcmFncmFwaFtpXTtcbiAgICAgICAgY291bnRlciArPSBsaW5lLmJveC5oZWlnaHQ7XG4gICAgICAgIGlmIChjb3VudGVyIDwgaGVpZ2h0KSB7XG4gICAgICAgICAgICBuZXdCbG9jay5wdXNoKGxpbmUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5ld0Jsb2NrO1xufTtcblxuLyoqXG4gKiBMYXlvdXQgcGFyYWdyYXBocyBpbnNpZGUgY29udGFpbmVyIHVudGlsIGl0IGRvZXMgbm90XG4gKiBmaXQgYW55bW9yZSwgcGVyZm9ybWluZyBsaW5lIHdyYXBwaW5nIGluIHRoZSBwcm9jZXNzLlxuICpcbiAqIEBwYXJhbSAgZW5naW5lcyAtIEVuZ2luZXNcbiAqIEBwYXJhbSAgb3B0aW9ucyAtIExheW91dCBvcHRpb25zXG4gKiBAcGFyYW0gY29udGFpbmVyIC0gQ29udGFpbmVyXG4gKi9cbmNvbnN0IHR5cGVzZXR0ZXIgPSAoZW5naW5lcywgb3B0aW9ucywgY29udGFpbmVyKSA9PiB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIGF0dHJpYnV0ZWRTdHJpbmdzIC0gQXR0cmlidXRlZCBzdHJpbmdzIChwYXJhZ3JhcGhzKVxuICAgICAqIEByZXR1cm5zIFBhcmFncmFwaCBibG9ja3NcbiAgICAgKi9cbiAgICByZXR1cm4gKGF0dHJpYnV0ZWRTdHJpbmdzKSA9PiB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgICAgICBjb25zdCBwYXJhZ3JhcGhzID0gWy4uLmF0dHJpYnV0ZWRTdHJpbmdzXTtcbiAgICAgICAgY29uc3QgbGF5b3V0ID0gbGF5b3V0UGFyYWdyYXBoKGVuZ2luZXMsIG9wdGlvbnMpO1xuICAgICAgICBjb25zdCBtYXhMaW5lcyA9IGlzTmlsKGNvbnRhaW5lci5tYXhMaW5lcykgPyBJbmZpbml0eSA6IGNvbnRhaW5lci5tYXhMaW5lcztcbiAgICAgICAgY29uc3QgdHJ1bmNhdGVFbGxpcHNpcyA9IGNvbnRhaW5lci50cnVuY2F0ZU1vZGUgPT09ICdlbGxpcHNpcyc7XG4gICAgICAgIGxldCBsaW5lc0NvdW50ID0gbWF4TGluZXM7XG4gICAgICAgIGxldCBwYXJhZ3JhcGhSZWN0ID0gY29weShjb250YWluZXIpO1xuICAgICAgICBsZXQgbmV4dFBhcmFncmFwaCA9IHBhcmFncmFwaHMuc2hpZnQoKTtcbiAgICAgICAgd2hpbGUgKGxpbmVzQ291bnQgPiAwICYmIG5leHRQYXJhZ3JhcGgpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhcmFncmFwaCA9IGxheW91dChwYXJhZ3JhcGhSZWN0LCBuZXh0UGFyYWdyYXBoKTtcbiAgICAgICAgICAgIGNvbnN0IHNsaWNlZEJsb2NrID0gcGFyYWdyYXBoLnNsaWNlKDAsIGxpbmVzQ291bnQpO1xuICAgICAgICAgICAgY29uc3QgbGluZXNIZWlnaHQgPSBoZWlnaHQkMihzbGljZWRCbG9jayk7XG4gICAgICAgICAgICBjb25zdCBzaG91bGRUcnVuY2F0ZSA9IHRydW5jYXRlRWxsaXBzaXMgJiYgcGFyYWdyYXBoLmxlbmd0aCAhPT0gc2xpY2VkQmxvY2subGVuZ3RoO1xuICAgICAgICAgICAgbGluZXNDb3VudCAtPSBzbGljZWRCbG9jay5sZW5ndGg7XG4gICAgICAgICAgICBpZiAocGFyYWdyYXBoUmVjdC5oZWlnaHQgPj0gbGluZXNIZWlnaHQpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChzaG91bGRUcnVuY2F0ZSA/IHRydW5jYXRlKHNsaWNlZEJsb2NrKSA6IHNsaWNlZEJsb2NrKTtcbiAgICAgICAgICAgICAgICBwYXJhZ3JhcGhSZWN0ID0gY3JvcChsaW5lc0hlaWdodCwgcGFyYWdyYXBoUmVjdCk7XG4gICAgICAgICAgICAgICAgbmV4dFBhcmFncmFwaCA9IHBhcmFncmFwaHMuc2hpZnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHRydW5jYXRlKHNsaWNlQXRIZWlnaHQocGFyYWdyYXBoUmVjdC5oZWlnaHQsIHNsaWNlZEJsb2NrKSkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbn07XG5cbi8qKlxuICogR2V0IGF0dHJpYnV0ZWQgc3RyaW5nIHN0YXJ0IHZhbHVlXG4gKlxuICogQHBhcmFtIGF0dHJpYnV0ZWRTdHJpbmcgLSBBdHRyaWJ1dGVkIHN0cmluZ1xuICogQHJldHVybnMgU3RhcnRcbiAqL1xuY29uc3Qgc3RhcnQgPSAoYXR0cmlidXRlZFN0cmluZykgPT4ge1xuICAgIGNvbnN0IHsgcnVucyB9ID0gYXR0cmlidXRlZFN0cmluZztcbiAgICByZXR1cm4gcnVucy5sZW5ndGggPT09IDAgPyAwIDogcnVuc1swXS5zdGFydDtcbn07XG5cbi8qKlxuICogR2V0IGF0dHJpYnV0ZWQgc3RyaW5nIGVuZCB2YWx1ZVxuICpcbiAqIEBwYXJhbSBhdHRyaWJ1dGVkU3RyaW5nIC0gQXR0cmlidXRlZCBzdHJpbmdcbiAqIEByZXR1cm5zIEVuZFxuICovXG5jb25zdCBlbmQgPSAoYXR0cmlidXRlZFN0cmluZykgPT4ge1xuICAgIGNvbnN0IHsgcnVucyB9ID0gYXR0cmlidXRlZFN0cmluZztcbiAgICByZXR1cm4gcnVucy5sZW5ndGggPT09IDAgPyAwIDogbGFzdChydW5zKS5lbmQ7XG59O1xuXG4vKipcbiAqIEdldCBhdHRyaWJ1dGVkIHN0cmluZyBsZW5ndGhcbiAqXG4gKiBAcGFyYW0gYXR0cmlidXRlZFN0cmluZyAtIEF0dHJpYnV0ZWQgc3RyaW5nXG4gKiBAcmV0dXJucyBFbmRcbiAqL1xuY29uc3QgbGVuZ3RoJDEgPSAoYXR0cmlidXRlZFN0cmluZykgPT4ge1xuICAgIHJldHVybiBlbmQoYXR0cmlidXRlZFN0cmluZykgLSBzdGFydChhdHRyaWJ1dGVkU3RyaW5nKTtcbn07XG5cbmNvbnN0IGJpZGkkMiA9IGJpZGlGYWN0b3J5KCk7XG5jb25zdCBnZXRCaWRpTGV2ZWxzJDEgPSAocnVucykgPT4ge1xuICAgIHJldHVybiBydW5zLnJlZHVjZSgoYWNjLCBydW4pID0+IHtcbiAgICAgICAgY29uc3QgbGVuZ3RoID0gcnVuLmVuZCAtIHJ1bi5zdGFydDtcbiAgICAgICAgY29uc3QgbGV2ZWxzID0gcmVwZWF0KHJ1bi5hdHRyaWJ1dGVzLmJpZGlMZXZlbCwgbGVuZ3RoKTtcbiAgICAgICAgcmV0dXJuIGFjYy5jb25jYXQobGV2ZWxzKTtcbiAgICB9LCBbXSk7XG59O1xuY29uc3QgZ2V0UmVvcmRlcmVkSW5kaWNlcyA9IChzdHJpbmcsIHNlZ21lbnRzKSA9PiB7XG4gICAgLy8gRmlsbCBhbiBhcnJheSB3aXRoIGluZGljZXNcbiAgICBjb25zdCBpbmRpY2VzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHJpbmcubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgaW5kaWNlc1tpXSA9IGk7XG4gICAgfVxuICAgIC8vIFJldmVyc2UgZWFjaCBzZWdtZW50IGluIG9yZGVyXG4gICAgc2VnbWVudHMuZm9yRWFjaCgoW3N0YXJ0LCBlbmRdKSA9PiB7XG4gICAgICAgIGNvbnN0IHNsaWNlID0gaW5kaWNlcy5zbGljZShzdGFydCwgZW5kICsgMSk7XG4gICAgICAgIGZvciAobGV0IGkgPSBzbGljZS5sZW5ndGggLSAxOyBpID49IDA7IGkgLT0gMSkge1xuICAgICAgICAgICAgaW5kaWNlc1tlbmQgLSBpXSA9IHNsaWNlW2ldO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGluZGljZXM7XG59O1xuY29uc3QgZ2V0SXRlbUF0SW5kZXggPSAocnVucywgb2JqZWN0TmFtZSwgaW5kZXgpID0+IHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJ1bnMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgY29uc3QgcnVuID0gcnVuc1tpXTtcbiAgICAgICAgY29uc3QgdXBkYXRlZEluZGV4ID0gcnVuLmdseXBoSW5kaWNlc1tpbmRleCAtIHJ1bi5zdGFydF07XG4gICAgICAgIGlmIChpbmRleCA+PSBydW4uc3RhcnQgJiYgaW5kZXggPCBydW4uZW5kKSB7XG4gICAgICAgICAgICByZXR1cm4gcnVuW29iamVjdE5hbWVdW3VwZGF0ZWRJbmRleF07XG4gICAgICAgIH1cbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKGBpbmRleCAke2luZGV4fSBvdXQgb2YgcmFuZ2VgKTtcbn07XG5jb25zdCByZW9yZGVyTGluZSA9IChsaW5lKSA9PiB7XG4gICAgY29uc3QgbGV2ZWxzID0gZ2V0QmlkaUxldmVscyQxKGxpbmUucnVucyk7XG4gICAgY29uc3QgZGlyZWN0aW9uID0gbGluZS5ydW5zWzBdPy5hdHRyaWJ1dGVzLmRpcmVjdGlvbjtcbiAgICBjb25zdCBsZXZlbCA9IGRpcmVjdGlvbiA9PT0gJ3J0bCcgPyAxIDogMDtcbiAgICBjb25zdCBlbmQgPSBsZW5ndGgkMShsaW5lKSAtIDE7XG4gICAgY29uc3QgcGFyYWdyYXBocyA9IFt7IHN0YXJ0OiAwLCBlbmQsIGxldmVsIH1dO1xuICAgIGNvbnN0IGVtYmVkZGluZ0xldmVscyA9IHsgcGFyYWdyYXBocywgbGV2ZWxzIH07XG4gICAgY29uc3Qgc2VnbWVudHMgPSBiaWRpJDIuZ2V0UmVvcmRlclNlZ21lbnRzKGxpbmUuc3RyaW5nLCBlbWJlZGRpbmdMZXZlbHMpO1xuICAgIC8vIE5vIG5lZWQgZm9yIGJpZGkgcmVvcmRlcmluZ1xuICAgIGlmIChzZWdtZW50cy5sZW5ndGggPT09IDApXG4gICAgICAgIHJldHVybiBsaW5lO1xuICAgIGNvbnN0IGluZGljZXMgPSBnZXRSZW9yZGVyZWRJbmRpY2VzKGxpbmUuc3RyaW5nLCBzZWdtZW50cyk7XG4gICAgY29uc3QgdXBkYXRlZFN0cmluZyA9IGJpZGkkMi5nZXRSZW9yZGVyZWRTdHJpbmcobGluZS5zdHJpbmcsIGVtYmVkZGluZ0xldmVscyk7XG4gICAgY29uc3QgdXBkYXRlZFJ1bnMgPSBsaW5lLnJ1bnMubWFwKChydW4pID0+IHtcbiAgICAgICAgY29uc3Qgc2VsZWN0ZWRJbmRpY2VzID0gaW5kaWNlcy5zbGljZShydW4uc3RhcnQsIHJ1bi5lbmQpO1xuICAgICAgICBjb25zdCB1cGRhdGVkR2x5cGhzID0gW107XG4gICAgICAgIGNvbnN0IHVwZGF0ZWRQb3NpdGlvbnMgPSBbXTtcbiAgICAgICAgY29uc3QgYWRkZWRHbHlwaHMgPSBuZXcgU2V0KCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2VsZWN0ZWRJbmRpY2VzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IHNlbGVjdGVkSW5kaWNlc1tpXTtcbiAgICAgICAgICAgIGNvbnN0IGdseXBoID0gZ2V0SXRlbUF0SW5kZXgobGluZS5ydW5zLCAnZ2x5cGhzJywgaW5kZXgpO1xuICAgICAgICAgICAgaWYgKGFkZGVkR2x5cGhzLmhhcyhnbHlwaC5pZCkpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB1cGRhdGVkR2x5cGhzLnB1c2goZ2x5cGgpO1xuICAgICAgICAgICAgdXBkYXRlZFBvc2l0aW9ucy5wdXNoKGdldEl0ZW1BdEluZGV4KGxpbmUucnVucywgJ3Bvc2l0aW9ucycsIGluZGV4KSk7XG4gICAgICAgICAgICBpZiAoZ2x5cGguaXNMaWdhdHVyZSkge1xuICAgICAgICAgICAgICAgIGFkZGVkR2x5cGhzLmFkZChnbHlwaC5pZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLnJ1bixcbiAgICAgICAgICAgIGdseXBoczogdXBkYXRlZEdseXBocyxcbiAgICAgICAgICAgIHBvc2l0aW9uczogdXBkYXRlZFBvc2l0aW9ucyxcbiAgICAgICAgfTtcbiAgICB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgICBib3g6IGxpbmUuYm94LFxuICAgICAgICBydW5zOiB1cGRhdGVkUnVucyxcbiAgICAgICAgc3RyaW5nOiB1cGRhdGVkU3RyaW5nLFxuICAgIH07XG59O1xuY29uc3QgcmVvcmRlclBhcmFncmFwaCA9IChwYXJhZ3JhcGgpID0+IHBhcmFncmFwaC5tYXAocmVvcmRlckxpbmUpO1xuLyoqXG4gKiBQZXJmb3JtIGJpZGkgcmVvcmRlcmluZ1xuICpcbiAqIEByZXR1cm5zIFJlb3JkZXJlZCBwYXJhZ3JhcGhzXG4gKi9cbmNvbnN0IGJpZGlSZW9yZGVyaW5nID0gKCkgPT4ge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSBwYXJhZ3JhcGhzIC0gUGFyYWdyYXBoc1xuICAgICAqIEByZXR1cm5zIFJlb3JkZXJlZCBwYXJhZ3JhcGhzXG4gICAgICovXG4gICAgcmV0dXJuIChwYXJhZ3JhcGhzKSA9PiBwYXJhZ3JhcGhzLm1hcChyZW9yZGVyUGFyYWdyYXBoKTtcbn07XG5cbmNvbnN0IERVTU1ZX0NPREVQT0lOVCA9IDEyMztcbi8qKlxuICogUmVzb2x2ZSBzdHJpbmcgaW5kaWNlcyBiYXNlZCBvbiBnbHlwaHMgY29kZSBwb2ludHNcbiAqXG4gKiBAcGFyYW0gZ2x5cGhzXG4gKiBAcmV0dXJucyBHbHlwaCBpbmRpY2VzXG4gKi9cbmNvbnN0IHJlc29sdmUgPSAoZ2x5cGhzID0gW10pID0+IHtcbiAgICByZXR1cm4gZ2x5cGhzLnJlZHVjZSgoYWNjLCBnbHlwaCkgPT4ge1xuICAgICAgICBjb25zdCBjb2RlUG9pbnRzID0gZ2x5cGg/LmNvZGVQb2ludHMgfHwgW0RVTU1ZX0NPREVQT0lOVF07XG4gICAgICAgIGlmIChhY2MubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgcmV0dXJuIGNvZGVQb2ludHMubWFwKCgpID0+IDApO1xuICAgICAgICBjb25zdCBsYXN0ID0gYWNjW2FjYy5sZW5ndGggLSAxXTtcbiAgICAgICAgY29uc3QgbmV4dCA9IGNvZGVQb2ludHMubWFwKCgpID0+IGxhc3QgKyAxKTtcbiAgICAgICAgcmV0dXJuIFsuLi5hY2MsIC4uLm5leHRdO1xuICAgIH0sIFtdKTtcbn07XG5cbmNvbnN0IGdldENoYXJhY3RlclNwYWNpbmcgPSAocnVuKSA9PiB7XG4gICAgcmV0dXJuIHJ1bi5hdHRyaWJ1dGVzPy5jaGFyYWN0ZXJTcGFjaW5nIHx8IDA7XG59O1xuLyoqXG4gKiBTY2FsZSBydW4gcG9zaXRpb25zXG4gKlxuICogQHBhcmFtICBydW5cbiAqIEBwYXJhbSAgcG9zaXRpb25zXG4gKiBAcmV0dXJucyBTY2FsZWQgcG9zaXRpb25zXG4gKi9cbmNvbnN0IHNjYWxlUG9zaXRpb25zID0gKHJ1biwgcG9zaXRpb25zKSA9PiB7XG4gICAgY29uc3QgcnVuU2NhbGUgPSBzY2FsZShydW4pO1xuICAgIGNvbnN0IGNoYXJhY3RlclNwYWNpbmcgPSBnZXRDaGFyYWN0ZXJTcGFjaW5nKHJ1bik7XG4gICAgcmV0dXJuIHBvc2l0aW9ucy5tYXAoKHBvc2l0aW9uLCBpKSA9PiB7XG4gICAgICAgIGNvbnN0IGlzTGFzdCA9IGkgPT09IHBvc2l0aW9ucy5sZW5ndGg7XG4gICAgICAgIGNvbnN0IHhTcGFjaW5nID0gaXNMYXN0ID8gMCA6IGNoYXJhY3RlclNwYWNpbmc7XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBwb3NpdGlvbiwge1xuICAgICAgICAgICAgeEFkdmFuY2U6IHBvc2l0aW9uLnhBZHZhbmNlICogcnVuU2NhbGUgKyB4U3BhY2luZyxcbiAgICAgICAgICAgIHlBZHZhbmNlOiBwb3NpdGlvbi55QWR2YW5jZSAqIHJ1blNjYWxlLFxuICAgICAgICAgICAgeE9mZnNldDogcG9zaXRpb24ueE9mZnNldCAqIHJ1blNjYWxlLFxuICAgICAgICAgICAgeU9mZnNldDogcG9zaXRpb24ueU9mZnNldCAqIHJ1blNjYWxlLFxuICAgICAgICB9KTtcbiAgICB9KTtcbn07XG4vKipcbiAqIENyZWF0ZSBnbHlwaCBydW5cbiAqXG4gKiBAcGFyYW0gc3RyaW5nIHN0cmluZ1xuICovXG5jb25zdCBsYXlvdXRSdW4gPSAoc3RyaW5nKSA9PiB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHJ1biAtIFJ1blxuICAgICAqIEByZXR1cm5zIEdseXBoIHJ1blxuICAgICAqL1xuICAgIHJldHVybiAocnVuKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgc3RhcnQsIGVuZCwgYXR0cmlidXRlcyA9IHt9IH0gPSBydW47XG4gICAgICAgIGNvbnN0IHsgZm9udCB9ID0gYXR0cmlidXRlcztcbiAgICAgICAgaWYgKCFmb250KVxuICAgICAgICAgICAgcmV0dXJuIHsgLi4ucnVuLCBnbHlwaHM6IFtdLCBnbHlwaEluZGljZXM6IFtdLCBwb3NpdGlvbnM6IFtdIH07XG4gICAgICAgIGNvbnN0IHJ1blN0cmluZyA9IHN0cmluZy5zbGljZShzdGFydCwgZW5kKTtcbiAgICAgICAgaWYgKHR5cGVvZiBmb250ID09PSAnc3RyaW5nJylcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBmb250Jyk7XG4gICAgICAgIC8vIHBhc3NpbmcgTFRSIFRvIGZvcmNlIGZvbnRraXQgdG8gbm90IHJldmVyc2UgdGhlIHN0cmluZ1xuICAgICAgICBjb25zdCBnbHlwaFJ1biA9IGZvbnRbMF0ubGF5b3V0KHJ1blN0cmluZywgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgJ2x0cicpO1xuICAgICAgICBjb25zdCBwb3NpdGlvbnMgPSBzY2FsZVBvc2l0aW9ucyhydW4sIGdseXBoUnVuLnBvc2l0aW9ucyk7XG4gICAgICAgIGNvbnN0IGdseXBoSW5kaWNlcyA9IHJlc29sdmUoZ2x5cGhSdW4uZ2x5cGhzKTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0ge1xuICAgICAgICAgICAgLi4ucnVuLFxuICAgICAgICAgICAgcG9zaXRpb25zLFxuICAgICAgICAgICAgZ2x5cGhJbmRpY2VzLFxuICAgICAgICAgICAgZ2x5cGhzOiBnbHlwaFJ1bi5nbHlwaHMsXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbn07XG4vKipcbiAqIEdlbmVyYXRlIGdseXBocyBmb3Igc2luZ2xlIGF0dHJpYnV0ZWQgc3RyaW5nXG4gKi9cbmNvbnN0IGdlbmVyYXRlR2x5cGhzID0gKCkgPT4ge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSBhdHRyaWJ1dGVkU3RyaW5nIC0gQXR0cmlidXRlZCBzdHJpbmdcbiAgICAgKiBAcmV0dXJucyBBdHRyaWJ1dGVkIHN0cmluZyB3aXRoIGdseXBoc1xuICAgICAqL1xuICAgIHJldHVybiAoYXR0cmlidXRlZFN0cmluZykgPT4ge1xuICAgICAgICBjb25zdCBydW5zID0gYXR0cmlidXRlZFN0cmluZy5ydW5zLm1hcChsYXlvdXRSdW4oYXR0cmlidXRlZFN0cmluZy5zdHJpbmcpKTtcbiAgICAgICAgY29uc3QgcmVzID0gT2JqZWN0LmFzc2lnbih7fSwgYXR0cmlidXRlZFN0cmluZywgeyBydW5zIH0pO1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH07XG59O1xuXG4vKipcbiAqIFJlc29sdmVzIHlPZmZzZXQgZm9yIHJ1blxuICpcbiAqIEBwYXJhbSBydW4gLSBSdW5cbiAqIEByZXR1cm5zIFJ1blxuICovXG5jb25zdCByZXNvbHZlUnVuWU9mZnNldCA9IChydW4pID0+IHtcbiAgICBpZiAoIXJ1bi5wb3NpdGlvbnMpXG4gICAgICAgIHJldHVybiBydW47XG4gICAgY29uc3QgdW5pdHNQZXJFbSA9IHJ1bi5hdHRyaWJ1dGVzPy5mb250Py5bMF0/LnVuaXRzUGVyRW0gfHwgMDtcbiAgICBjb25zdCB5T2Zmc2V0ID0gKHJ1bi5hdHRyaWJ1dGVzPy55T2Zmc2V0IHx8IDApICogdW5pdHNQZXJFbTtcbiAgICBjb25zdCBwb3NpdGlvbnMgPSBydW4ucG9zaXRpb25zLm1hcCgocCkgPT4gT2JqZWN0LmFzc2lnbih7fSwgcCwgeyB5T2Zmc2V0IH0pKTtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgcnVuLCB7IHBvc2l0aW9ucyB9KTtcbn07XG4vKipcbiAqIFJlc29sdmVzIHlPZmZzZXQgZm9yIG11bHRpcGxlIHBhcmFncmFwaHNcbiAqL1xuY29uc3QgcmVzb2x2ZVlPZmZzZXQgPSAoKSA9PiB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIGF0dHJpYnV0ZWRTdHJpbmcgLSBBdHRyaWJ1dGVkIHN0cmluZ1xuICAgICAqIEByZXR1cm5zIEF0dHJpYnV0ZWQgc3RyaW5nXG4gICAgICovXG4gICAgcmV0dXJuIChhdHRyaWJ1dGVkU3RyaW5nKSA9PiB7XG4gICAgICAgIGNvbnN0IHJ1bnMgPSBhdHRyaWJ1dGVkU3RyaW5nLnJ1bnMubWFwKHJlc29sdmVSdW5ZT2Zmc2V0KTtcbiAgICAgICAgY29uc3QgcmVzID0gT2JqZWN0LmFzc2lnbih7fSwgYXR0cmlidXRlZFN0cmluZywgeyBydW5zIH0pO1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH07XG59O1xuXG4vKipcbiAqIFNvcnQgcnVucyBpbiBhc2NlbmRpbmcgb3JkZXJcbiAqXG4gKiBAcGFyYW0gcnVuc1xuICogQHJldHVybnMgU29ydGVkIHJ1bnNcbiAqL1xuY29uc3Qgc29ydCA9IChydW5zKSA9PiB7XG4gICAgcmV0dXJuIHJ1bnMuc29ydCgoYSwgYikgPT4gYS5zdGFydCAtIGIuc3RhcnQgfHwgYS5lbmQgLSBiLmVuZCk7XG59O1xuXG4vKipcbiAqIElzIHJ1biBlbXB0eSAoc3RhcnQgPT09IGVuZClcbiAqXG4gKiBAcGFyYW0gcnVuIC0gUnVuXG4gKiBAcmV0dXJucyBJcyBydW4gZW1wdHlcbiAqL1xuY29uc3QgaXNFbXB0eSA9IChydW4pID0+IHtcbiAgICByZXR1cm4gcnVuLnN0YXJ0ID09PSBydW4uZW5kO1xufTtcblxuLyoqXG4gKiBTb3J0IHBvaW50cyBpbiBhc2NlbmRpbmcgb3JkZXJcbiAqIEBwYXJhbSBhIC0gRmlyc3QgcG9pbnRcbiAqIEBwYXJhbSBiIC0gU2Vjb25kIHBvaW50XG4gKiBAcmV0dXJucyBTb3J0IG9yZGVyXG4gKi9cbmNvbnN0IHNvcnRQb2ludHMgPSAoYSwgYikgPT4ge1xuICAgIHJldHVybiBhWzFdIC0gYlsxXSB8fCBhWzNdIC0gYlszXTtcbn07XG4vKipcbiAqIEBwYXJhbSBydW5zXG4gKiBAcmV0dXJucyBQb2ludHNcbiAqL1xuY29uc3QgZ2VuZXJhdGVQb2ludHMgPSAocnVucykgPT4ge1xuICAgIGNvbnN0IHJlc3VsdCA9IHJ1bnMucmVkdWNlKChhY2MsIHJ1biwgaSkgPT4ge1xuICAgICAgICByZXR1cm4gYWNjLmNvbmNhdChbXG4gICAgICAgICAgICBbJ3N0YXJ0JywgcnVuLnN0YXJ0LCBydW4uYXR0cmlidXRlcywgaV0sXG4gICAgICAgICAgICBbJ2VuZCcsIHJ1bi5lbmQsIHJ1bi5hdHRyaWJ1dGVzLCBpXSxcbiAgICAgICAgXSk7XG4gICAgfSwgW10pO1xuICAgIHJldHVybiByZXN1bHQuc29ydChzb3J0UG9pbnRzKTtcbn07XG4vKipcbiAqIEBwYXJhbSBydW5zXG4gKiBAcmV0dXJucyBNZXJnZWQgcnVuc1xuICovXG5jb25zdCBtZXJnZVJ1bnMgPSAocnVucykgPT4ge1xuICAgIHJldHVybiBydW5zLnJlZHVjZSgoYWNjLCBydW4pID0+IHtcbiAgICAgICAgY29uc3QgYXR0cmlidXRlcyA9IE9iamVjdC5hc3NpZ24oe30sIGFjYy5hdHRyaWJ1dGVzLCBydW4uYXR0cmlidXRlcyk7XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBydW4sIHsgYXR0cmlidXRlcyB9KTtcbiAgICB9LCB7fSk7XG59O1xuLyoqXG4gKiBAcGFyYW0gcnVuc1xuICogQHJldHVybnMgR3JvdXBlZCBydW5zXG4gKi9cbmNvbnN0IGdyb3VwRW1wdHlSdW5zID0gKHJ1bnMpID0+IHtcbiAgICBjb25zdCBncm91cHMgPSBydW5zLnJlZHVjZSgoYWNjLCBydW4pID0+IHtcbiAgICAgICAgaWYgKCFhY2NbcnVuLnN0YXJ0XSlcbiAgICAgICAgICAgIGFjY1tydW4uc3RhcnRdID0gW107XG4gICAgICAgIGFjY1tydW4uc3RhcnRdLnB1c2gocnVuKTtcbiAgICAgICAgcmV0dXJuIGFjYztcbiAgICB9LCBbXSk7XG4gICAgcmV0dXJuIE9iamVjdC52YWx1ZXMoZ3JvdXBzKTtcbn07XG4vKipcbiAqIEBwYXJhbSBydW5zXG4gKiBAcmV0dXJucyBGbGF0dGVuZWQgcnVuc1xuICovXG5jb25zdCBmbGF0dGVuRW1wdHlSdW5zID0gKHJ1bnMpID0+IHtcbiAgICByZXR1cm4gZ3JvdXBFbXB0eVJ1bnMocnVucykubWFwKG1lcmdlUnVucyk7XG59O1xuLyoqXG4gKiBAcGFyYW0gcnVuc1xuICogQHJldHVybnMgRmxhdHRlbmVkIHJ1bnNcbiAqL1xuY29uc3QgZmxhdHRlblJlZ3VsYXJSdW5zID0gKHJ1bnMpID0+IHtcbiAgICBjb25zdCByZXMgPSBbXTtcbiAgICBjb25zdCBwb2ludHMgPSBnZW5lcmF0ZVBvaW50cyhydW5zKTtcbiAgICBsZXQgc3RhcnQgPSAtMTtcbiAgICBsZXQgYXR0cnMgPSB7fTtcbiAgICBjb25zdCBzdGFjayA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcG9pbnRzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGNvbnN0IFt0eXBlLCBvZmZzZXQsIGF0dHJpYnV0ZXNdID0gcG9pbnRzW2ldO1xuICAgICAgICBpZiAoc3RhcnQgIT09IC0xICYmIHN0YXJ0IDwgb2Zmc2V0KSB7XG4gICAgICAgICAgICByZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgc3RhcnQsXG4gICAgICAgICAgICAgICAgZW5kOiBvZmZzZXQsXG4gICAgICAgICAgICAgICAgYXR0cmlidXRlczogYXR0cnMsXG4gICAgICAgICAgICAgICAgZ2x5cGhJbmRpY2VzOiBbXSxcbiAgICAgICAgICAgICAgICBnbHlwaHM6IFtdLFxuICAgICAgICAgICAgICAgIHBvc2l0aW9uczogW10sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZSA9PT0gJ3N0YXJ0Jykge1xuICAgICAgICAgICAgc3RhY2sucHVzaChhdHRyaWJ1dGVzKTtcbiAgICAgICAgICAgIGF0dHJzID0gT2JqZWN0LmFzc2lnbih7fSwgYXR0cnMsIGF0dHJpYnV0ZXMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYXR0cnMgPSB7fTtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgc3RhY2subGVuZ3RoOyBqICs9IDEpIHtcbiAgICAgICAgICAgICAgICBpZiAoc3RhY2tbal0gPT09IGF0dHJpYnV0ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhY2suc3BsaWNlKGotLSwgMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBhdHRycyA9IE9iamVjdC5hc3NpZ24oe30sIGF0dHJzLCBzdGFja1tqXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN0YXJ0ID0gb2Zmc2V0O1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufTtcbi8qKlxuICogRmxhdHRlbiBtYW55IHJ1bnNcbiAqXG4gKiBAcGFyYW0gcnVuc1xuICogQHJldHVybnMgRmxhdHRlbmVkIHJ1bnNcbiAqL1xuY29uc3QgZmxhdHRlbiA9IChydW5zID0gW10pID0+IHtcbiAgICBjb25zdCBlbXB0eVJ1bnMgPSBmbGF0dGVuRW1wdHlSdW5zKHJ1bnMuZmlsdGVyKChydW4pID0+IGlzRW1wdHkocnVuKSkpO1xuICAgIGNvbnN0IHJlZ3VsYXJSdW5zID0gZmxhdHRlblJlZ3VsYXJSdW5zKHJ1bnMuZmlsdGVyKChydW4pID0+ICFpc0VtcHR5KHJ1bikpKTtcbiAgICByZXR1cm4gc29ydChlbXB0eVJ1bnMuY29uY2F0KHJlZ3VsYXJSdW5zKSk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgZW1wdHkgYXR0cmlidXRlZCBzdHJpbmdcbiAqXG4gKiBAcmV0dXJucyBFbXB0eSBhdHRyaWJ1dGVkIHN0cmluZ1xuICovXG5jb25zdCBlbXB0eSA9ICgpID0+ICh7IHN0cmluZzogJycsIHJ1bnM6IFtdIH0pO1xuXG4vKipcbiAqXG4gKiBAcGFyYW0gYXR0cmlidXRlZFN0cmluZ1xuICogQHJldHVybnMgQXR0cmlidXRlZCBzdHJpbmcgd2l0aG91dCBmb250XG4gKi9cbmNvbnN0IG9taXRGb250ID0gKGF0dHJpYnV0ZWRTdHJpbmcpID0+IHtcbiAgICBjb25zdCBydW5zID0gYXR0cmlidXRlZFN0cmluZy5ydW5zLm1hcCgocnVuKSA9PiBvbWl0KCdmb250JywgcnVuKSk7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIGF0dHJpYnV0ZWRTdHJpbmcsIHsgcnVucyB9KTtcbn07XG4vKipcbiAqIFBlcmZvcm1zIGZvbnQgc3Vic3RpdHV0aW9uIGFuZCBzY3JpcHQgaXRlbWl6YXRpb24gb24gYXR0cmlidXRlZCBzdHJpbmdcbiAqXG4gKiBAcGFyYW0gZW5naW5lcyAtIGVuZ2luZXNcbiAqL1xuY29uc3QgcHJlcHJvY2Vzc1J1bnMgPSAoZW5naW5lcykgPT4ge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSBhdHRyaWJ1dGVkU3RyaW5nIC0gQXR0cmlidXRlZCBzdHJpbmdcbiAgICAgKiBAcmV0dXJucyBQcm9jZXNzZWQgYXR0cmlidXRlZCBzdHJpbmdcbiAgICAgKi9cbiAgICByZXR1cm4gKGF0dHJpYnV0ZWRTdHJpbmcpID0+IHtcbiAgICAgICAgaWYgKGlzTmlsKGF0dHJpYnV0ZWRTdHJpbmcpKVxuICAgICAgICAgICAgcmV0dXJuIGVtcHR5KCk7XG4gICAgICAgIGNvbnN0IHsgc3RyaW5nIH0gPSBhdHRyaWJ1dGVkU3RyaW5nO1xuICAgICAgICBjb25zdCB7IGZvbnRTdWJzdGl0dXRpb24sIHNjcmlwdEl0ZW1pemVyLCBiaWRpIH0gPSBlbmdpbmVzO1xuICAgICAgICBjb25zdCB7IHJ1bnM6IG9taXR0ZWRGb250UnVucyB9ID0gb21pdEZvbnQoYXR0cmlidXRlZFN0cmluZyk7XG4gICAgICAgIGNvbnN0IHsgcnVuczogaXRlbWl6YXRpb25SdW5zIH0gPSBzY3JpcHRJdGVtaXplcigpKGF0dHJpYnV0ZWRTdHJpbmcpO1xuICAgICAgICBjb25zdCB7IHJ1bnM6IHN1YnN0aXR1dGVkUnVucyB9ID0gZm9udFN1YnN0aXR1dGlvbigpKGF0dHJpYnV0ZWRTdHJpbmcpO1xuICAgICAgICBjb25zdCB7IHJ1bnM6IGJpZGlSdW5zIH0gPSBiaWRpKCkoYXR0cmlidXRlZFN0cmluZyk7XG4gICAgICAgIGNvbnN0IHJ1bnMgPSBiaWRpUnVuc1xuICAgICAgICAgICAgLmNvbmNhdChzdWJzdGl0dXRlZFJ1bnMpXG4gICAgICAgICAgICAuY29uY2F0KGl0ZW1pemF0aW9uUnVucylcbiAgICAgICAgICAgIC5jb25jYXQob21pdHRlZEZvbnRSdW5zKTtcbiAgICAgICAgcmV0dXJuIHsgc3RyaW5nLCBydW5zOiBmbGF0dGVuKHJ1bnMpIH07XG4gICAgfTtcbn07XG5cbi8qKlxuICogQnJlYWtzIGF0dHJpYnV0ZWQgc3RyaW5nIGludG8gcGFyYWdyYXBoc1xuICovXG5jb25zdCBzcGxpdFBhcmFncmFwaHMgPSAoKSA9PiB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIGF0dHJpYnV0ZWRTdHJpbmcgLSBBdHRyaWJ1dGVkIHN0cmluZ1xuICAgICAqIEByZXR1cm5zIFBhcmFncmFwaHMgYXR0cmlidXRlZCBzdHJpbmdzXG4gICAgICovXG4gICAgcmV0dXJuIChhdHRyaWJ1dGVkU3RyaW5nKSA9PiB7XG4gICAgICAgIGNvbnN0IHBhcmFncmFwaHMgPSBbXTtcbiAgICAgICAgbGV0IHN0YXJ0ID0gMDtcbiAgICAgICAgbGV0IGJyZWFrUG9pbnQgPSBhdHRyaWJ1dGVkU3RyaW5nLnN0cmluZy5pbmRleE9mKCdcXG4nKSArIDE7XG4gICAgICAgIHdoaWxlIChicmVha1BvaW50ID4gMCkge1xuICAgICAgICAgICAgcGFyYWdyYXBocy5wdXNoKHNsaWNlKHN0YXJ0LCBicmVha1BvaW50LCBhdHRyaWJ1dGVkU3RyaW5nKSk7XG4gICAgICAgICAgICBzdGFydCA9IGJyZWFrUG9pbnQ7XG4gICAgICAgICAgICBicmVha1BvaW50ID0gYXR0cmlidXRlZFN0cmluZy5zdHJpbmcuaW5kZXhPZignXFxuJywgYnJlYWtQb2ludCkgKyAxO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGFydCA9PT0gMCkge1xuICAgICAgICAgICAgcGFyYWdyYXBocy5wdXNoKGF0dHJpYnV0ZWRTdHJpbmcpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHN0YXJ0IDwgYXR0cmlidXRlZFN0cmluZy5zdHJpbmcubGVuZ3RoKSB7XG4gICAgICAgICAgICBwYXJhZ3JhcGhzLnB1c2goc2xpY2Uoc3RhcnQsIGxlbmd0aCQxKGF0dHJpYnV0ZWRTdHJpbmcpLCBhdHRyaWJ1dGVkU3RyaW5nKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhcmFncmFwaHM7XG4gICAgfTtcbn07XG5cbi8qKlxuICogUmV0dXJuIHBvc2l0aW9ucyBhZHZhbmNlIHdpZHRoXG4gKlxuICogQHBhcmFtIHBvc2l0aW9ucyAtIFBvc2l0aW9uc1xuICogQHJldHVybnMge251bWJlcn0gYWR2YW5jZSB3aWR0aFxuICovXG5jb25zdCBhZHZhbmNlV2lkdGgkMiA9IChwb3NpdGlvbnMpID0+IHtcbiAgICByZXR1cm4gcG9zaXRpb25zLnJlZHVjZSgoYWNjLCBwb3MpID0+IGFjYyArIChwb3MueEFkdmFuY2UgfHwgMCksIDApO1xufTtcblxuLyoqXG4gKiBSZXR1cm4gcnVuIGFkdmFuY2Ugd2lkdGhcbiAqXG4gKiBAcGFyYW0gcnVuIC0gUnVuXG4gKiBAcmV0dXJucyBBZHZhbmNlIHdpZHRoXG4gKi9cbmNvbnN0IGFkdmFuY2VXaWR0aCQxID0gKHJ1bikgPT4ge1xuICAgIHJldHVybiBhZHZhbmNlV2lkdGgkMihydW4ucG9zaXRpb25zIHx8IFtdKTtcbn07XG5cbi8qKlxuICogUmV0dXJucyBhdHRyaWJ1dGVkIHN0cmluZyBhZHZhbmNld2lkdGhcbiAqXG4gKiBAcGFyYW0gYXR0cmlidXRlZFN0cmluZyAtIEF0dHJpYnV0ZWQgc3RyaW5nXG4gKiBAcmV0dXJucyBBZHZhbmNlIHdpZHRoXG4gKi9cbmNvbnN0IGFkdmFuY2VXaWR0aCA9IChhdHRyaWJ1dGVkU3RyaW5nKSA9PiB7XG4gICAgY29uc3QgcmVkdWNlciA9IChhY2MsIHJ1bikgPT4gYWNjICsgYWR2YW5jZVdpZHRoJDEocnVuKTtcbiAgICByZXR1cm4gYXR0cmlidXRlZFN0cmluZy5ydW5zLnJlZHVjZShyZWR1Y2VyLCAwKTtcbn07XG5cbmNvbnN0IFdISVRFX1NQQUNFU19DT0RFID0gMzI7XG4vKipcbiAqIENoZWNrIGlmIGdseXBoIGlzIHdoaXRlIHNwYWNlXG4gKlxuICogQHBhcmFtIGdseXBoIC0gR2x5cGhcbiAqIEByZXR1cm5zIFdoZXRoZXIgZ2x5cGggaXMgd2hpdGUgc3BhY2VcbiAqICovXG5jb25zdCBpc1doaXRlU3BhY2UgPSAoZ2x5cGgpID0+IHtcbiAgICBjb25zdCBjb2RlUG9pbnRzID0gZ2x5cGg/LmNvZGVQb2ludHMgfHwgW107XG4gICAgcmV0dXJuIGNvZGVQb2ludHMuaW5jbHVkZXMoV0hJVEVfU1BBQ0VTX0NPREUpO1xufTtcblxuLyoqXG4gKiBHZXQgd2hpdGUgc3BhY2UgbGVhZGluZyBwb3NpdGlvbnNcbiAqXG4gKiBAcGFyYW0gcnVuIC0gUnVuXG4gKiBAcmV0dXJucyBXaGl0ZSBzcGFjZSBsZWFkaW5nIHBvc2l0aW9uc1xuICovXG5jb25zdCBsZWFkaW5nUG9zaXRpb25zID0gKHJ1bikgPT4ge1xuICAgIGNvbnN0IGdseXBocyA9IHJ1bi5nbHlwaHMgfHwgW107XG4gICAgY29uc3QgcG9zaXRpb25zID0gcnVuLnBvc2l0aW9ucyB8fCBbXTtcbiAgICBjb25zdCBsZWFkaW5nV2hpdGVzcGFjZXMgPSBnbHlwaHMuZmluZEluZGV4KChnKSA9PiAhaXNXaGl0ZVNwYWNlKGcpKTtcbiAgICByZXR1cm4gcG9zaXRpb25zLnNsaWNlKDAsIGxlYWRpbmdXaGl0ZXNwYWNlcyk7XG59O1xuLyoqXG4gKiBHZXQgcnVuIGxlYWRpbmcgd2hpdGUgc3BhY2Ugb2Zmc2V0XG4gKlxuICogQHBhcmFtIHJ1biAtIFJ1blxuICogQHJldHVybnMgTGVhZGluZyB3aGl0ZSBzcGFjZSBvZmZzZXRcbiAqL1xuY29uc3QgbGVhZGluZ09mZnNldCQxID0gKHJ1bikgPT4ge1xuICAgIGNvbnN0IHBvc2l0aW9ucyA9IGxlYWRpbmdQb3NpdGlvbnMocnVuKTtcbiAgICByZXR1cm4gcG9zaXRpb25zLnJlZHVjZSgoYWNjLCBwb3MpID0+IGFjYyArIChwb3MueEFkdmFuY2UgfHwgMCksIDApO1xufTtcblxuLyoqXG4gKiBHZXQgYXR0cmlidXRlZCBzdHJpbmcgbGVhZGluZyB3aGl0ZSBzcGFjZSBvZmZzZXRcbiAqXG4gKiBAcGFyYW0gYXR0cmlidXRlZFN0cmluZyAtIEF0dHJpYnV0ZWQgc3RyaW5nXG4gKiBAcmV0dXJucyBMZWFkaW5nIHdoaXRlIHNwYWNlIG9mZnNldFxuICovXG5jb25zdCBsZWFkaW5nT2Zmc2V0ID0gKGF0dHJpYnV0ZWRTdHJpbmcpID0+IHtcbiAgICBjb25zdCBydW5zID0gYXR0cmlidXRlZFN0cmluZy5ydW5zIHx8IFtdO1xuICAgIHJldHVybiBsZWFkaW5nT2Zmc2V0JDEocnVuc1swXSk7XG59O1xuXG4vKipcbiAqIEdldCB3aGl0ZSBzcGFjZSB0cmFpbGluZyBwb3NpdGlvbnNcbiAqXG4gKiBAcGFyYW0gcnVuIHJ1blxuICogQHJldHVybnMgV2hpdGUgc3BhY2UgdHJhaWxpbmcgcG9zaXRpb25zXG4gKi9cbmNvbnN0IHRyYWlsaW5nUG9zaXRpb25zID0gKHJ1bikgPT4ge1xuICAgIGNvbnN0IGdseXBocyA9IHJldmVyc2UocnVuLmdseXBocyB8fCBbXSk7XG4gICAgY29uc3QgcG9zaXRpb25zID0gcmV2ZXJzZShydW4ucG9zaXRpb25zIHx8IFtdKTtcbiAgICBjb25zdCBsZWFkaW5nV2hpdGVzcGFjZXMgPSBnbHlwaHMuZmluZEluZGV4KChnKSA9PiAhaXNXaGl0ZVNwYWNlKGcpKTtcbiAgICByZXR1cm4gcG9zaXRpb25zLnNsaWNlKDAsIGxlYWRpbmdXaGl0ZXNwYWNlcyk7XG59O1xuLyoqXG4gKiBHZXQgcnVuIHRyYWlsaW5nIHdoaXRlIHNwYWNlIG9mZnNldFxuICpcbiAqIEBwYXJhbSBydW4gLSBSdW5cbiAqIEByZXR1cm5zIFRyYWlsaW5nIHdoaXRlIHNwYWNlIG9mZnNldFxuICovXG5jb25zdCB0cmFpbGluZ09mZnNldCQxID0gKHJ1bikgPT4ge1xuICAgIGNvbnN0IHBvc2l0aW9ucyA9IHRyYWlsaW5nUG9zaXRpb25zKHJ1bik7XG4gICAgcmV0dXJuIHBvc2l0aW9ucy5yZWR1Y2UoKGFjYywgcG9zKSA9PiBhY2MgKyAocG9zLnhBZHZhbmNlIHx8IDApLCAwKTtcbn07XG5cbi8qKlxuICogR2V0IGF0dHJpYnV0ZWQgc3RyaW5nIHRyYWlsaW5nIHdoaXRlIHNwYWNlIG9mZnNldFxuICpcbiAqIEBwYXJhbSBhdHRyaWJ1dGVkU3RyaW5nIC0gQXR0cmlidXRlZCBzdHJpbmdcbiAqIEByZXR1cm5zIFRyYWlsaW5nIHdoaXRlIHNwYWNlIG9mZnNldFxuICovXG5jb25zdCB0cmFpbGluZ09mZnNldCA9IChhdHRyaWJ1dGVkU3RyaW5nKSA9PiB7XG4gICAgY29uc3QgcnVucyA9IGF0dHJpYnV0ZWRTdHJpbmcucnVucyB8fCBbXTtcbiAgICByZXR1cm4gdHJhaWxpbmdPZmZzZXQkMShsYXN0KHJ1bnMpKTtcbn07XG5cbi8qKlxuICogRHJvcCBsYXN0IGNoYXIgb2YgcnVuXG4gKlxuICogQHBhcmFtIHJ1biAtIFJ1blxuICogQHJldHVybnMgUnVuIHdpdGhvdXQgbGFzdCBjaGFyXG4gKi9cbmNvbnN0IGRyb3BMYXN0JDEgPSAocnVuKSA9PiB7XG4gICAgcmV0dXJuIHNsaWNlJDEoMCwgcnVuLmVuZCAtIHJ1bi5zdGFydCAtIDEsIHJ1bik7XG59O1xuXG4vKipcbiAqIERyb3AgbGFzdCBnbHlwaFxuICpcbiAqIEBwYXJhbSBhdHRyaWJ1dGVkU3RyaW5nIC0gQXR0cmlidXRlZCBzdHJpbmdcbiAqIEByZXR1cm5zIEF0dHJpYnV0ZWQgc3RyaW5nIHdpdGggbmV3IGdseXBoXG4gKi9cbmNvbnN0IGRyb3BMYXN0ID0gKGF0dHJpYnV0ZWRTdHJpbmcpID0+IHtcbiAgICBjb25zdCBzdHJpbmcgPSBkcm9wTGFzdCQyKGF0dHJpYnV0ZWRTdHJpbmcuc3RyaW5nKTtcbiAgICBjb25zdCBydW5zID0gYWRqdXN0KC0xLCBkcm9wTGFzdCQxLCBhdHRyaWJ1dGVkU3RyaW5nLnJ1bnMpO1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBhdHRyaWJ1dGVkU3RyaW5nLCB7IHN0cmluZywgcnVucyB9KTtcbn07XG5cbmNvbnN0IEFMSUdOTUVOVF9GQUNUT1JTID0geyBjZW50ZXI6IDAuNSwgcmlnaHQ6IDEgfTtcbi8qKlxuICogUmVtb3ZlIG5ldyBsaW5lIGNoYXIgYXQgdGhlIGVuZCBvZiBsaW5lIGlmIHByZXNlbnRcbiAqXG4gKiBAcGFyYW0gbGluZVxuICogQHJldHVybnMgTGluZVxuICovXG5jb25zdCByZW1vdmVOZXdMaW5lID0gKGxpbmUpID0+IHtcbiAgICByZXR1cm4gbGFzdChsaW5lLnN0cmluZykgPT09ICdcXG4nID8gZHJvcExhc3QobGluZSkgOiBsaW5lO1xufTtcbmNvbnN0IGdldE92ZXJmbG93TGVmdCA9IChsaW5lKSA9PiB7XG4gICAgcmV0dXJuIGxlYWRpbmdPZmZzZXQobGluZSkgKyAobGluZS5vdmVyZmxvd0xlZnQgfHwgMCk7XG59O1xuY29uc3QgZ2V0T3ZlcmZsb3dSaWdodCA9IChsaW5lKSA9PiB7XG4gICAgcmV0dXJuIHRyYWlsaW5nT2Zmc2V0KGxpbmUpICsgKGxpbmUub3ZlcmZsb3dSaWdodCB8fCAwKTtcbn07XG4vKipcbiAqIElnbm9yZSB3aGl0ZXNwYWNlIGF0IHRoZSBzdGFydCBhbmQgZW5kIG9mIGEgbGluZSBmb3IgYWxpZ25tZW50XG4gKlxuICogQHBhcmFtIGxpbmVcbiAqIEByZXR1cm5zIExpbmVcbiAqL1xuY29uc3QgYWRqdXN0T3ZlcmZsb3cgPSAobGluZSkgPT4ge1xuICAgIGNvbnN0IG92ZXJmbG93TGVmdCA9IGdldE92ZXJmbG93TGVmdChsaW5lKTtcbiAgICBjb25zdCBvdmVyZmxvd1JpZ2h0ID0gZ2V0T3ZlcmZsb3dSaWdodChsaW5lKTtcbiAgICBjb25zdCB4ID0gbGluZS5ib3gueCAtIG92ZXJmbG93TGVmdDtcbiAgICBjb25zdCB3aWR0aCA9IGxpbmUuYm94LndpZHRoICsgb3ZlcmZsb3dMZWZ0ICsgb3ZlcmZsb3dSaWdodDtcbiAgICBjb25zdCBib3ggPSBPYmplY3QuYXNzaWduKHt9LCBsaW5lLmJveCwgeyB4LCB3aWR0aCB9KTtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgbGluZSwgeyBib3gsIG92ZXJmbG93TGVmdCwgb3ZlcmZsb3dSaWdodCB9KTtcbn07XG4vKipcbiAqIFBlcmZvcm1zIGxpbmUganVzdGlmaWNhdGlvbiBieSBjYWxsaW5nIGFwcHJvcGlhdGUgZW5naW5lXG4gKlxuICogQHBhcmFtIGVuZ2luZXMgLSBFbmdpbmVzXG4gKiBAcGFyYW0gb3B0aW9ucyAtIExheW91dCBvcHRpb25zXG4gKiBAcGFyYW0gYWxpZ24gLSBUZXh0IGFsaWduXG4gKi9cbmNvbnN0IGp1c3RpZnlMaW5lJDEgPSAoZW5naW5lcywgb3B0aW9ucywgYWxpZ24pID0+IHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gbGluZSAtIExpbmVcbiAgICAgKiBAcmV0dXJucyBMaW5lXG4gICAgICovXG4gICAgcmV0dXJuIChsaW5lKSA9PiB7XG4gICAgICAgIGNvbnN0IGxpbmVXaWR0aCA9IGFkdmFuY2VXaWR0aChsaW5lKTtcbiAgICAgICAgY29uc3QgYWxpZ25GYWN0b3IgPSBBTElHTk1FTlRfRkFDVE9SU1thbGlnbl0gfHwgMDtcbiAgICAgICAgY29uc3QgcmVtYWluaW5nV2lkdGggPSBNYXRoLm1heCgwLCBsaW5lLmJveC53aWR0aCAtIGxpbmVXaWR0aCk7XG4gICAgICAgIGNvbnN0IHNob3VsZEp1c3RpZnkgPSBhbGlnbiA9PT0gJ2p1c3RpZnknIHx8IGxpbmVXaWR0aCA+IGxpbmUuYm94LndpZHRoO1xuICAgICAgICBjb25zdCB4ID0gbGluZS5ib3gueCArIHJlbWFpbmluZ1dpZHRoICogYWxpZ25GYWN0b3I7XG4gICAgICAgIGNvbnN0IGJveCA9IE9iamVjdC5hc3NpZ24oe30sIGxpbmUuYm94LCB7IHggfSk7XG4gICAgICAgIGNvbnN0IG5ld0xpbmUgPSBPYmplY3QuYXNzaWduKHt9LCBsaW5lLCB7IGJveCB9KTtcbiAgICAgICAgcmV0dXJuIHNob3VsZEp1c3RpZnkgPyBlbmdpbmVzLmp1c3RpZmljYXRpb24ob3B0aW9ucykobmV3TGluZSkgOiBuZXdMaW5lO1xuICAgIH07XG59O1xuY29uc3QgZmluYWxpemVMaW5lID0gKGxpbmUpID0+IHtcbiAgICBsZXQgbGluZUFzY2VudCA9IDA7XG4gICAgbGV0IGxpbmVEZXNjZW50ID0gMDtcbiAgICBsZXQgbGluZUhlaWdodCA9IDA7XG4gICAgbGV0IGxpbmVYQWR2YW5jZSA9IDA7XG4gICAgY29uc3QgcnVucyA9IGxpbmUucnVucy5tYXAoKHJ1bikgPT4ge1xuICAgICAgICBjb25zdCBoZWlnaHQgPSBoZWlnaHQkMShydW4pO1xuICAgICAgICBjb25zdCBhc2NlbnQgPSBhc2NlbnQkMShydW4pO1xuICAgICAgICBjb25zdCBkZXNjZW50JDEgPSBkZXNjZW50KHJ1bik7XG4gICAgICAgIGNvbnN0IHhBZHZhbmNlID0gYWR2YW5jZVdpZHRoJDEocnVuKTtcbiAgICAgICAgbGluZUhlaWdodCA9IE1hdGgubWF4KGxpbmVIZWlnaHQsIGhlaWdodCk7XG4gICAgICAgIGxpbmVBc2NlbnQgPSBNYXRoLm1heChsaW5lQXNjZW50LCBhc2NlbnQpO1xuICAgICAgICBsaW5lRGVzY2VudCA9IE1hdGgubWF4KGxpbmVEZXNjZW50LCBkZXNjZW50JDEpO1xuICAgICAgICBsaW5lWEFkdmFuY2UgKz0geEFkdmFuY2U7XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBydW4sIHsgaGVpZ2h0LCBhc2NlbnQsIGRlc2NlbnQ6IGRlc2NlbnQkMSwgeEFkdmFuY2UgfSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIGxpbmUsIHtcbiAgICAgICAgcnVucyxcbiAgICAgICAgaGVpZ2h0OiBsaW5lSGVpZ2h0LFxuICAgICAgICBhc2NlbnQ6IGxpbmVBc2NlbnQsXG4gICAgICAgIGRlc2NlbnQ6IGxpbmVEZXNjZW50LFxuICAgICAgICB4QWR2YW5jZTogbGluZVhBZHZhbmNlLFxuICAgIH0pO1xufTtcbi8qKlxuICogRmluYWxpemUgbGluZSBieSBwZXJmb3JtaW5nIGxpbmUganVzdGlmaWNhdGlvblxuICogYW5kIHRleHQgZGVjb3JhdGlvbiAodXNpbmcgYXBwcm9waWF0ZSBlbmdpbmVzKVxuICpcbiAqIEBwYXJhbSBlbmdpbmVzIC0gRW5naW5lc1xuICogQHBhcmFtIG9wdGlvbnMgLSBMYXlvdXQgb3B0aW9uc1xuICovXG5jb25zdCBmaW5hbGl6ZUJsb2NrID0gKGVuZ2luZXMsIG9wdGlvbnMpID0+IHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gbGluZSAtIExpbmVcbiAgICAgKiBAcGFyYW0gaSAtIExpbmUgaW5kZXhcbiAgICAgKiBAcGFyYW0gbGluZXMgLSBUb3RhbCBsaW5lc1xuICAgICAqIEByZXR1cm5zIExpbmVcbiAgICAgKi9cbiAgICByZXR1cm4gKGxpbmUsIGluZGV4LCBsaW5lcykgPT4ge1xuICAgICAgICBjb25zdCBpc0xhc3RGcmFnbWVudCA9IGluZGV4ID09PSBsaW5lcy5sZW5ndGggLSAxO1xuICAgICAgICBjb25zdCBzdHlsZSA9IGxpbmUucnVucz8uWzBdPy5hdHRyaWJ1dGVzIHx8IHt9O1xuICAgICAgICBjb25zdCBhbGlnbiA9IGlzTGFzdEZyYWdtZW50ID8gc3R5bGUuYWxpZ25MYXN0TGluZSA6IHN0eWxlLmFsaWduO1xuICAgICAgICByZXR1cm4gY29tcG9zZShmaW5hbGl6ZUxpbmUsIGVuZ2luZXMudGV4dERlY29yYXRpb24oKSwganVzdGlmeUxpbmUkMShlbmdpbmVzLCBvcHRpb25zLCBhbGlnbiksIGFkanVzdE92ZXJmbG93LCByZW1vdmVOZXdMaW5lKShsaW5lKTtcbiAgICB9O1xufTtcbi8qKlxuICogRmluYWxpemUgbGluZSBibG9jayBieSBwZXJmb3JtaW5nIGxpbmUganVzdGlmaWNhdGlvblxuICogYW5kIHRleHQgZGVjb3JhdGlvbiAodXNpbmcgYXBwcm9waWF0ZSBlbmdpbmVzKVxuICpcbiAqIEBwYXJhbSBlbmdpbmVzIC0gRW5naW5lc1xuICogQHBhcmFtIG9wdGlvbnMgLSBMYXlvdXQgb3B0aW9uc1xuICovXG5jb25zdCBmaW5hbGl6ZUZyYWdtZW50cyA9IChlbmdpbmVzLCBvcHRpb25zKSA9PiB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHBhcmFncmFwaHMgLSBQYXJhZ3JhcGhzXG4gICAgICogQHJldHVybnMgUGFyYWdyYXBoc1xuICAgICAqL1xuICAgIHJldHVybiAocGFyYWdyYXBocykgPT4ge1xuICAgICAgICBjb25zdCBibG9ja0ZpbmFsaXplciA9IGZpbmFsaXplQmxvY2soZW5naW5lcywgb3B0aW9ucyk7XG4gICAgICAgIHJldHVybiBwYXJhZ3JhcGhzLm1hcCgocGFyYWdyYXBoKSA9PiBwYXJhZ3JhcGgubWFwKGJsb2NrRmluYWxpemVyKSk7XG4gICAgfTtcbn07XG5cbmNvbnN0IEFUVEFDSE1FTlRfQ09ERSA9IDB4ZmZmYzsgLy8gNjU1MzJcbmNvbnN0IGlzUmVwbGFjZUdseXBoID0gKGdseXBoKSA9PiBnbHlwaC5jb2RlUG9pbnRzLmluY2x1ZGVzKEFUVEFDSE1FTlRfQ09ERSk7XG4vKipcbiAqIFJlc29sdmUgYXR0YWNobWVudHMgb2YgcnVuXG4gKlxuICogQHBhcmFtIHJ1blxuICogQHJldHVybnMgUnVuXG4gKi9cbmNvbnN0IHJlc29sdmVSdW5BdHRhY2htZW50cyA9IChydW4pID0+IHtcbiAgICBpZiAoIXJ1bi5wb3NpdGlvbnMpXG4gICAgICAgIHJldHVybiBydW47XG4gICAgY29uc3QgZ2x5cGhzID0gcnVuLmdseXBocyB8fCBbXTtcbiAgICBjb25zdCBhdHRhY2htZW50ID0gcnVuLmF0dHJpYnV0ZXM/LmF0dGFjaG1lbnQ7XG4gICAgaWYgKCFhdHRhY2htZW50KVxuICAgICAgICByZXR1cm4gcnVuO1xuICAgIGNvbnN0IHBvc2l0aW9ucyA9IHJ1bi5wb3NpdGlvbnMubWFwKChwb3NpdGlvbiwgaSkgPT4ge1xuICAgICAgICBjb25zdCBnbHlwaCA9IGdseXBoc1tpXTtcbiAgICAgICAgaWYgKGF0dGFjaG1lbnQud2lkdGggJiYgaXNSZXBsYWNlR2x5cGgoZ2x5cGgpKSB7XG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgcG9zaXRpb24sIHsgeEFkdmFuY2U6IGF0dGFjaG1lbnQud2lkdGggfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIHBvc2l0aW9uKTtcbiAgICB9KTtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgcnVuLCB7IHBvc2l0aW9ucyB9KTtcbn07XG4vKipcbiAqIFJlc29sdmUgYXR0YWNobWVudHMgZm9yIG11bHRpcGxlIHBhcmFncmFwaHNcbiAqL1xuY29uc3QgcmVzb2x2ZUF0dGFjaG1lbnRzID0gKCkgPT4ge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSBhdHRyaWJ1dGVkU3RyaW5nIC0gQXR0cmlidXRlZCBzdHJpbmdcbiAgICAgKiBAcmV0dXJucyBBdHRyaWJ1dGVkIHN0cmluZ1xuICAgICAqL1xuICAgIHJldHVybiAoYXR0cmlidXRlZFN0cmluZykgPT4ge1xuICAgICAgICBjb25zdCBydW5zID0gYXR0cmlidXRlZFN0cmluZy5ydW5zLm1hcChyZXNvbHZlUnVuQXR0YWNobWVudHMpO1xuICAgICAgICBjb25zdCByZXMgPSBPYmplY3QuYXNzaWduKHt9LCBhdHRyaWJ1dGVkU3RyaW5nLCB7IHJ1bnMgfSk7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfTtcbn07XG5cbi8qKlxuICogQHBhcmFtIGF0dHJpYnV0ZXMgLSBBdHRyaWJ1dGVzXG4gKiBAcmV0dXJucyBBdHRyaWJ1dGVzIHdpdGggZGVmYXVsdHNcbiAqL1xuY29uc3QgYXBwbHlBdHRyaWJ1dGVzID0gKGEpID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgICBhbGlnbjogYS5hbGlnbiB8fCAoYS5kaXJlY3Rpb24gPT09ICdydGwnID8gJ3JpZ2h0JyA6ICdsZWZ0JyksXG4gICAgICAgIGFsaWduTGFzdExpbmU6IGEuYWxpZ25MYXN0TGluZSB8fCAoYS5hbGlnbiA9PT0gJ2p1c3RpZnknID8gJ2xlZnQnIDogYS5hbGlnbiB8fCAnbGVmdCcpLFxuICAgICAgICBhdHRhY2htZW50OiBhLmF0dGFjaG1lbnQgfHwgbnVsbCxcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiBhLmJhY2tncm91bmRDb2xvciB8fCBudWxsLFxuICAgICAgICBidWxsZXQ6IGEuYnVsbGV0IHx8IG51bGwsXG4gICAgICAgIGNoYXJhY3RlclNwYWNpbmc6IGEuY2hhcmFjdGVyU3BhY2luZyB8fCAwLFxuICAgICAgICBjb2xvcjogYS5jb2xvciB8fCAnYmxhY2snLFxuICAgICAgICBkaXJlY3Rpb246IGEuZGlyZWN0aW9uIHx8ICdsdHInLFxuICAgICAgICBmZWF0dXJlczogYS5mZWF0dXJlcyB8fCBbXSxcbiAgICAgICAgZmlsbDogYS5maWxsICE9PSBmYWxzZSxcbiAgICAgICAgZm9udDogYS5mb250IHx8IFtdLFxuICAgICAgICBmb250U2l6ZTogYS5mb250U2l6ZSB8fCAxMixcbiAgICAgICAgaGFuZ2luZ1B1bmN0dWF0aW9uOiBhLmhhbmdpbmdQdW5jdHVhdGlvbiB8fCBmYWxzZSxcbiAgICAgICAgaHlwaGVuYXRpb25GYWN0b3I6IGEuaHlwaGVuYXRpb25GYWN0b3IgfHwgMCxcbiAgICAgICAgaW5kZW50OiBhLmluZGVudCB8fCAwLFxuICAgICAgICBqdXN0aWZpY2F0aW9uRmFjdG9yOiBhLmp1c3RpZmljYXRpb25GYWN0b3IgfHwgMSxcbiAgICAgICAgbGluZUhlaWdodDogYS5saW5lSGVpZ2h0IHx8IG51bGwsXG4gICAgICAgIGxpbmVTcGFjaW5nOiBhLmxpbmVTcGFjaW5nIHx8IDAsXG4gICAgICAgIGxpbms6IGEubGluayB8fCBudWxsLFxuICAgICAgICBtYXJnaW5MZWZ0OiBhLm1hcmdpbkxlZnQgfHwgYS5tYXJnaW4gfHwgMCxcbiAgICAgICAgbWFyZ2luUmlnaHQ6IGEubWFyZ2luUmlnaHQgfHwgYS5tYXJnaW4gfHwgMCxcbiAgICAgICAgb3BhY2l0eTogYS5vcGFjaXR5LFxuICAgICAgICBwYWRkaW5nVG9wOiBhLnBhZGRpbmdUb3AgfHwgYS5wYWRkaW5nIHx8IDAsXG4gICAgICAgIHBhcmFncmFwaFNwYWNpbmc6IGEucGFyYWdyYXBoU3BhY2luZyB8fCAwLFxuICAgICAgICBzY3JpcHQ6IGEuc2NyaXB0IHx8IG51bGwsXG4gICAgICAgIHNocmlua0ZhY3RvcjogYS5zaHJpbmtGYWN0b3IgfHwgMCxcbiAgICAgICAgc3RyaWtlOiBhLnN0cmlrZSB8fCBmYWxzZSxcbiAgICAgICAgc3RyaWtlQ29sb3I6IGEuc3RyaWtlQ29sb3IgfHwgYS5jb2xvciB8fCAnYmxhY2snLFxuICAgICAgICBzdHJpa2VTdHlsZTogYS5zdHJpa2VTdHlsZSB8fCAnc29saWQnLFxuICAgICAgICBzdHJva2U6IGEuc3Ryb2tlIHx8IGZhbHNlLFxuICAgICAgICB1bmRlcmxpbmU6IGEudW5kZXJsaW5lIHx8IGZhbHNlLFxuICAgICAgICB1bmRlcmxpbmVDb2xvcjogYS51bmRlcmxpbmVDb2xvciB8fCBhLmNvbG9yIHx8ICdibGFjaycsXG4gICAgICAgIHVuZGVybGluZVN0eWxlOiBhLnVuZGVybGluZVN0eWxlIHx8ICdzb2xpZCcsXG4gICAgICAgIHZlcnRpY2FsQWxpZ246IGEudmVydGljYWxBbGlnbiB8fCBudWxsLFxuICAgICAgICB3b3JkU3BhY2luZzogYS53b3JkU3BhY2luZyB8fCAwLFxuICAgICAgICB5T2Zmc2V0OiBhLnlPZmZzZXQgfHwgMCxcbiAgICB9O1xufTtcbi8qKlxuICogQXBwbHkgZGVmYXVsdCBzdHlsZSB0byBydW5cbiAqXG4gKiBAcGFyYW0gcnVuIC0gUnVuXG4gKiBAcmV0dXJucyBSdW4gd2l0aCBkZWZhdWx0IHN0eWxlc1xuICovXG5jb25zdCBhcHBseVJ1blN0eWxlcyA9IChydW4pID0+IHtcbiAgICBjb25zdCBhdHRyaWJ1dGVzID0gYXBwbHlBdHRyaWJ1dGVzKHJ1bi5hdHRyaWJ1dGVzKTtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgcnVuLCB7IGF0dHJpYnV0ZXMgfSk7XG59O1xuLyoqXG4gKiBBcHBseSBkZWZhdWx0IGF0dHJpYnV0ZXMgZm9yIGFuIGF0dHJpYnV0ZWQgc3RyaW5nXG4gKi9cbmNvbnN0IGFwcGx5RGVmYXVsdFN0eWxlcyA9ICgpID0+IHtcbiAgICByZXR1cm4gKGF0dHJpYnV0ZWRTdHJpbmcpID0+IHtcbiAgICAgICAgY29uc3Qgc3RyaW5nID0gYXR0cmlidXRlZFN0cmluZy5zdHJpbmcgfHwgJyc7XG4gICAgICAgIGNvbnN0IHJ1bnMgPSAoYXR0cmlidXRlZFN0cmluZy5ydW5zIHx8IFtdKS5tYXAoYXBwbHlSdW5TdHlsZXMpO1xuICAgICAgICByZXR1cm4geyBzdHJpbmcsIHJ1bnMgfTtcbiAgICB9O1xufTtcblxuLyoqXG4gKiBBcHBseSBzY2FsaW5nIGFuZCB5T2Zmc2V0IGZvciB2ZXJ0aWNhbEFsaWduICdzdWInIGFuZCAnc3VwZXInLlxuICovXG5jb25zdCB2ZXJ0aWNhbEFsaWdubWVudCA9ICgpID0+IHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gYXR0cmlidXRlZFN0cmluZyAtIEF0dHJpYnV0ZWQgc3RyaW5nXG4gICAgICogQHJldHVybnMgQXR0cmlidXRlZCBzdHJpbmdcbiAgICAgKi9cbiAgICByZXR1cm4gKGF0dHJpYnV0ZWRTdHJpbmcpID0+IHtcbiAgICAgICAgYXR0cmlidXRlZFN0cmluZy5ydW5zLmZvckVhY2goKHJ1bikgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBhdHRyaWJ1dGVzIH0gPSBydW47XG4gICAgICAgICAgICBjb25zdCB7IHZlcnRpY2FsQWxpZ24gfSA9IGF0dHJpYnV0ZXM7XG4gICAgICAgICAgICBpZiAodmVydGljYWxBbGlnbiA9PT0gJ3N1YicpIHtcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzLnlPZmZzZXQgPSAtMC4yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodmVydGljYWxBbGlnbiA9PT0gJ3N1cGVyJykge1xuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXMueU9mZnNldCA9IDAuNDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBhdHRyaWJ1dGVkU3RyaW5nO1xuICAgIH07XG59O1xuXG5jb25zdCBiaWRpJDEgPSBiaWRpRmFjdG9yeSgpO1xuLyoqXG4gKiBAcGFyYW0gcnVuc1xuICogQHJldHVybnMgQmlkaSBsZXZlbHNcbiAqL1xuY29uc3QgZ2V0QmlkaUxldmVscyA9IChydW5zKSA9PiB7XG4gICAgcmV0dXJuIHJ1bnMucmVkdWNlKChhY2MsIHJ1bikgPT4ge1xuICAgICAgICBjb25zdCBsZW5ndGggPSBydW4uZW5kIC0gcnVuLnN0YXJ0O1xuICAgICAgICBjb25zdCBsZXZlbHMgPSByZXBlYXQocnVuLmF0dHJpYnV0ZXMuYmlkaUxldmVsLCBsZW5ndGgpO1xuICAgICAgICByZXR1cm4gYWNjLmNvbmNhdChsZXZlbHMpO1xuICAgIH0sIFtdKTtcbn07XG4vKipcbiAqIFBlcmZvcm0gYmlkaSBtaXJyb3JpbmdcbiAqL1xuY29uc3QgbWlycm9yU3RyaW5nID0gKCkgPT4ge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSBhdHRyaWJ1dGVkU3RyaW5nIC0gQXR0cmlidXRlZCBzdHJpbmdcbiAgICAgKiBAcmV0dXJucyBBdHRyaWJ1dGVkIHN0cmluZ1xuICAgICAqL1xuICAgIHJldHVybiAoYXR0cmlidXRlZFN0cmluZykgPT4ge1xuICAgICAgICBjb25zdCBsZXZlbHMgPSBnZXRCaWRpTGV2ZWxzKGF0dHJpYnV0ZWRTdHJpbmcucnVucyk7XG4gICAgICAgIGxldCB1cGRhdGVkU3RyaW5nID0gJyc7XG4gICAgICAgIGF0dHJpYnV0ZWRTdHJpbmcuc3RyaW5nLnNwbGl0KCcnKS5mb3JFYWNoKChjaGFyLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgaXNSVEwgPSBsZXZlbHNbaW5kZXhdICUgMiA9PT0gMTtcbiAgICAgICAgICAgIGNvbnN0IG1pcnJvcmVkQ2hhciA9IGlzUlRMXG4gICAgICAgICAgICAgICAgPyBiaWRpJDEuZ2V0TWlycm9yZWRDaGFyYWN0ZXIoYXR0cmlidXRlZFN0cmluZy5zdHJpbmcuY2hhckF0KGluZGV4KSlcbiAgICAgICAgICAgICAgICA6IG51bGw7XG4gICAgICAgICAgICB1cGRhdGVkU3RyaW5nICs9IG1pcnJvcmVkQ2hhciB8fCBjaGFyO1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0ge1xuICAgICAgICAgICAgLi4uYXR0cmlidXRlZFN0cmluZyxcbiAgICAgICAgICAgIHN0cmluZzogdXBkYXRlZFN0cmluZyxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xufTtcblxuLyoqXG4gKiBBIExheW91dEVuZ2luZSBpcyB0aGUgbWFpbiBvYmplY3QgdGhhdCBwZXJmb3JtcyB0ZXh0IGxheW91dC5cbiAqIEl0IGFjY2VwdHMgYW4gQXR0cmlidXRlZFN0cmluZyBhbmQgYSBDb250YWluZXIgb2JqZWN0XG4gKiB0byBsYXlvdXQgdGV4dCBpbnRvLCBhbmQgdXNlcyBzZXZlcmFsIGhlbHBlciBvYmplY3RzIHRvIHBlcmZvcm1cbiAqIHZhcmlvdXMgbGF5b3V0IHRhc2tzLiBUaGVzZSBvYmplY3RzIGNhbiBiZSBvdmVycmlkZGVuIHRvIGN1c3RvbWl6ZVxuICogbGF5b3V0IGJlaGF2aW9yLlxuICovXG5jb25zdCBsYXlvdXRFbmdpbmUgPSAoZW5naW5lcykgPT4ge1xuICAgIHJldHVybiAoYXR0cmlidXRlZFN0cmluZywgY29udGFpbmVyLCBvcHRpb25zID0ge30pID0+IHtcbiAgICAgICAgY29uc3QgcHJvY2Vzc1BhcmFncmFwaCA9IGNvbXBvc2UocmVzb2x2ZVlPZmZzZXQoKSwgcmVzb2x2ZUF0dGFjaG1lbnRzKCksIHZlcnRpY2FsQWxpZ25tZW50KCksIHdyYXBXb3JkcyhlbmdpbmVzLCBvcHRpb25zKSwgZ2VuZXJhdGVHbHlwaHMoKSwgbWlycm9yU3RyaW5nKCksIHByZXByb2Nlc3NSdW5zKGVuZ2luZXMpKTtcbiAgICAgICAgY29uc3QgcHJvY2Vzc1BhcmFncmFwaHMgPSAocGFyYWdyYXBocykgPT4gcGFyYWdyYXBocy5tYXAocHJvY2Vzc1BhcmFncmFwaCk7XG4gICAgICAgIHJldHVybiBjb21wb3NlKGZpbmFsaXplRnJhZ21lbnRzKGVuZ2luZXMsIG9wdGlvbnMpLCBiaWRpUmVvcmRlcmluZygpLCB0eXBlc2V0dGVyKGVuZ2luZXMsIG9wdGlvbnMsIGNvbnRhaW5lciksIHByb2Nlc3NQYXJhZ3JhcGhzLCBzcGxpdFBhcmFncmFwaHMoKSwgYXBwbHlEZWZhdWx0U3R5bGVzKCkpKGF0dHJpYnV0ZWRTdHJpbmcpO1xuICAgIH07XG59O1xuXG5jb25zdCBiaWRpID0gYmlkaUZhY3RvcnkoKTtcbmNvbnN0IGJpZGlFbmdpbmUgPSAoKSA9PiB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIGF0dHJpYnV0ZWRTdHJpbmcgLSBBdHRyaWJ1dGVkIHN0cmluZ1xuICAgICAqIEByZXR1cm5zIEF0dHJpYnV0ZWQgc3RyaW5nXG4gICAgICovXG4gICAgcmV0dXJuIChhdHRyaWJ1dGVkU3RyaW5nKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgc3RyaW5nIH0gPSBhdHRyaWJ1dGVkU3RyaW5nO1xuICAgICAgICBjb25zdCBkaXJlY3Rpb24gPSBhdHRyaWJ1dGVkU3RyaW5nLnJ1bnNbMF0/LmF0dHJpYnV0ZXMuZGlyZWN0aW9uO1xuICAgICAgICBjb25zdCB7IGxldmVscyB9ID0gYmlkaS5nZXRFbWJlZGRpbmdMZXZlbHMoc3RyaW5nLCBkaXJlY3Rpb24pO1xuICAgICAgICBsZXQgbGFzdExldmVsID0gbnVsbDtcbiAgICAgICAgbGV0IGxhc3RJbmRleCA9IDA7XG4gICAgICAgIGxldCBpbmRleCA9IDA7XG4gICAgICAgIGNvbnN0IHJ1bnMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZXZlbHMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgIGNvbnN0IGxldmVsID0gbGV2ZWxzW2ldO1xuICAgICAgICAgICAgaWYgKGxldmVsICE9PSBsYXN0TGV2ZWwpIHtcbiAgICAgICAgICAgICAgICBpZiAobGFzdExldmVsICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJ1bnMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydDogbGFzdEluZGV4LFxuICAgICAgICAgICAgICAgICAgICAgICAgZW5kOiBpbmRleCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHsgYmlkaUxldmVsOiBsYXN0TGV2ZWwgfSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxhc3RJbmRleCA9IGluZGV4O1xuICAgICAgICAgICAgICAgIGxhc3RMZXZlbCA9IGxldmVsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaW5kZXggKz0gMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGFzdEluZGV4IDwgc3RyaW5nLmxlbmd0aCkge1xuICAgICAgICAgICAgcnVucy5wdXNoKHtcbiAgICAgICAgICAgICAgICBzdGFydDogbGFzdEluZGV4LFxuICAgICAgICAgICAgICAgIGVuZDogc3RyaW5nLmxlbmd0aCxcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiB7IGJpZGlMZXZlbDogbGFzdExldmVsIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXN1bHQgPSB7IHN0cmluZywgcnVucyB9O1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG59O1xuXG5jb25zdCBJTkZJTklUWSA9IDEwMDAwO1xuY29uc3QgZ2V0TmV4dEJyZWFrcG9pbnQgPSAoc3Vibm9kZXMsIHdpZHRocywgbGluZU51bWJlcikgPT4ge1xuICAgIGxldCBwb3NpdGlvbiA9IG51bGw7XG4gICAgbGV0IG1pbmltdW1CYWRuZXNzID0gSW5maW5pdHk7XG4gICAgY29uc3Qgc3VtID0geyB3aWR0aDogMCwgc3RyZXRjaDogMCwgc2hyaW5rOiAwIH07XG4gICAgY29uc3QgbGluZUxlbmd0aCA9IHdpZHRoc1tNYXRoLm1pbihsaW5lTnVtYmVyLCB3aWR0aHMubGVuZ3RoIC0gMSldO1xuICAgIGNvbnN0IGNhbGN1bGF0ZVJhdGlvID0gKG5vZGUpID0+IHtcbiAgICAgICAgY29uc3Qgc3RyZXRjaCA9ICdzdHJldGNoJyBpbiBub2RlID8gbm9kZS5zdHJldGNoIDogbnVsbDtcbiAgICAgICAgaWYgKHN1bS53aWR0aCA8IGxpbmVMZW5ndGgpIHtcbiAgICAgICAgICAgIGlmICghc3RyZXRjaClcbiAgICAgICAgICAgICAgICByZXR1cm4gSU5GSU5JVFk7XG4gICAgICAgICAgICByZXR1cm4gc3VtLnN0cmV0Y2ggLSBzdHJldGNoID4gMFxuICAgICAgICAgICAgICAgID8gKGxpbmVMZW5ndGggLSBzdW0ud2lkdGgpIC8gc3VtLnN0cmV0Y2hcbiAgICAgICAgICAgICAgICA6IElORklOSVRZO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNocmluayA9ICdzaHJpbmsnIGluIG5vZGUgPyBub2RlLnNocmluayA6IG51bGw7XG4gICAgICAgIGlmIChzdW0ud2lkdGggPiBsaW5lTGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoIXNocmluaylcbiAgICAgICAgICAgICAgICByZXR1cm4gSU5GSU5JVFk7XG4gICAgICAgICAgICByZXR1cm4gc3VtLnNocmluayAtIHNocmluayA+IDBcbiAgICAgICAgICAgICAgICA/IChsaW5lTGVuZ3RoIC0gc3VtLndpZHRoKSAvIHN1bS5zaHJpbmtcbiAgICAgICAgICAgICAgICA6IElORklOSVRZO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAwO1xuICAgIH07XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdWJub2Rlcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBjb25zdCBub2RlID0gc3Vibm9kZXNbaV07XG4gICAgICAgIGlmIChub2RlLnR5cGUgPT09ICdib3gnKSB7XG4gICAgICAgICAgICBzdW0ud2lkdGggKz0gbm9kZS53aWR0aDtcbiAgICAgICAgfVxuICAgICAgICBpZiAobm9kZS50eXBlID09PSAnZ2x1ZScpIHtcbiAgICAgICAgICAgIHN1bS53aWR0aCArPSBub2RlLndpZHRoO1xuICAgICAgICAgICAgc3VtLnN0cmV0Y2ggKz0gbm9kZS5zdHJldGNoO1xuICAgICAgICAgICAgc3VtLnNocmluayArPSBub2RlLnNocmluaztcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3VtLndpZHRoIC0gc3VtLnNocmluayA+IGxpbmVMZW5ndGgpIHtcbiAgICAgICAgICAgIGlmIChwb3NpdGlvbiA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGxldCBqID0gaSA9PT0gMCA/IGkgKyAxIDogaTtcbiAgICAgICAgICAgICAgICB3aGlsZSAoaiA8IHN1Ym5vZGVzLmxlbmd0aCAmJlxuICAgICAgICAgICAgICAgICAgICAoc3Vibm9kZXNbal0udHlwZSA9PT0gJ2dsdWUnIHx8IHN1Ym5vZGVzW2pdLnR5cGUgPT09ICdwZW5hbHR5JykpIHtcbiAgICAgICAgICAgICAgICAgICAgaisrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwb3NpdGlvbiA9IGogLSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vZGUudHlwZSA9PT0gJ3BlbmFsdHknIHx8IG5vZGUudHlwZSA9PT0gJ2dsdWUnKSB7XG4gICAgICAgICAgICBjb25zdCByYXRpbyA9IGNhbGN1bGF0ZVJhdGlvKG5vZGUpO1xuICAgICAgICAgICAgY29uc3QgcGVuYWx0eSA9IG5vZGUudHlwZSA9PT0gJ3BlbmFsdHknID8gbm9kZS5wZW5hbHR5IDogMDtcbiAgICAgICAgICAgIGNvbnN0IGJhZG5lc3MgPSAxMDAgKiBNYXRoLmFicyhyYXRpbykgKiogMyArIHBlbmFsdHk7XG4gICAgICAgICAgICBpZiAobWluaW11bUJhZG5lc3MgPj0gYmFkbmVzcykge1xuICAgICAgICAgICAgICAgIHBvc2l0aW9uID0gaTtcbiAgICAgICAgICAgICAgICBtaW5pbXVtQmFkbmVzcyA9IGJhZG5lc3M7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHN1bS53aWR0aCAtIHN1bS5zaHJpbmsgPiBsaW5lTGVuZ3RoID8gcG9zaXRpb24gOiBudWxsO1xufTtcbmNvbnN0IGFwcGx5QmVzdEZpdCA9IChub2Rlcywgd2lkdGhzKSA9PiB7XG4gICAgbGV0IGNvdW50ID0gMDtcbiAgICBsZXQgbGluZU51bWJlciA9IDA7XG4gICAgbGV0IHN1Ym5vZGVzID0gbm9kZXM7XG4gICAgY29uc3QgYnJlYWtwb2ludHMgPSBbMF07XG4gICAgd2hpbGUgKHN1Ym5vZGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgY29uc3QgYnJlYWtwb2ludCA9IGdldE5leHRCcmVha3BvaW50KHN1Ym5vZGVzLCB3aWR0aHMsIGxpbmVOdW1iZXIpO1xuICAgICAgICBpZiAoYnJlYWtwb2ludCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgY291bnQgKz0gYnJlYWtwb2ludDtcbiAgICAgICAgICAgIGJyZWFrcG9pbnRzLnB1c2goY291bnQpO1xuICAgICAgICAgICAgc3Vibm9kZXMgPSBzdWJub2Rlcy5zbGljZShicmVha3BvaW50ICsgMSwgc3Vibm9kZXMubGVuZ3RoKTtcbiAgICAgICAgICAgIGNvdW50Kys7XG4gICAgICAgICAgICBsaW5lTnVtYmVyKys7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzdWJub2RlcyA9IFtdO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBicmVha3BvaW50cztcbn07XG5cbi8qIGVzbGludC1kaXNhYmxlIG1heC1jbGFzc2VzLXBlci1maWxlICovXG5jbGFzcyBMaW5rZWRMaXN0Tm9kZSB7XG4gICAgZGF0YTtcbiAgICBwcmV2O1xuICAgIG5leHQ7XG4gICAgY29uc3RydWN0b3IoZGF0YSkge1xuICAgICAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgICAgICB0aGlzLnByZXYgPSBudWxsO1xuICAgICAgICB0aGlzLm5leHQgPSBudWxsO1xuICAgIH1cbn1cbmNsYXNzIExpbmtlZExpc3Qge1xuICAgIHN0YXRpYyBOb2RlID0gTGlua2VkTGlzdE5vZGU7XG4gICAgaGVhZDtcbiAgICB0YWlsO1xuICAgIGxpc3RTaXplO1xuICAgIGxpc3RMZW5ndGg7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuaGVhZCA9IG51bGw7XG4gICAgICAgIHRoaXMudGFpbCA9IG51bGw7XG4gICAgICAgIHRoaXMubGlzdFNpemUgPSAwO1xuICAgICAgICB0aGlzLmxpc3RMZW5ndGggPSAwO1xuICAgIH1cbiAgICBpc0xpbmtlZChub2RlKSB7XG4gICAgICAgIHJldHVybiAhKChub2RlICYmXG4gICAgICAgICAgICBub2RlLnByZXYgPT09IG51bGwgJiZcbiAgICAgICAgICAgIG5vZGUubmV4dCA9PT0gbnVsbCAmJlxuICAgICAgICAgICAgdGhpcy50YWlsICE9PSBub2RlICYmXG4gICAgICAgICAgICB0aGlzLmhlYWQgIT09IG5vZGUpIHx8XG4gICAgICAgICAgICB0aGlzLmlzRW1wdHkoKSk7XG4gICAgfVxuICAgIHNpemUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxpc3RTaXplO1xuICAgIH1cbiAgICBpc0VtcHR5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5saXN0U2l6ZSA9PT0gMDtcbiAgICB9XG4gICAgZmlyc3QoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhlYWQ7XG4gICAgfVxuICAgIGxhc3QoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxhc3Q7XG4gICAgfVxuICAgIGZvckVhY2goY2FsbGJhY2spIHtcbiAgICAgICAgbGV0IG5vZGUgPSB0aGlzLmhlYWQ7XG4gICAgICAgIHdoaWxlIChub2RlICE9PSBudWxsKSB7XG4gICAgICAgICAgICBjYWxsYmFjayhub2RlKTtcbiAgICAgICAgICAgIG5vZGUgPSBub2RlLm5leHQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXQoaSkge1xuICAgICAgICBsZXQgbm9kZSA9IHRoaXMuaGVhZDtcbiAgICAgICAgbGV0IGluZGV4ID0gMDtcbiAgICAgICAgaWYgKGkgPj0gdGhpcy5saXN0TGVuZ3RoIHx8IGkgPCAwKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAobm9kZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKGkgPT09IGluZGV4KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBub2RlID0gbm9kZS5uZXh0O1xuICAgICAgICAgICAgaW5kZXggKz0gMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaW5zZXJ0QWZ0ZXIobm9kZSwgbmV3Tm9kZSkge1xuICAgICAgICBpZiAoIXRoaXMuaXNMaW5rZWQobm9kZSkpXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgbmV3Tm9kZS5wcmV2ID0gbm9kZTtcbiAgICAgICAgbmV3Tm9kZS5uZXh0ID0gbm9kZS5uZXh0O1xuICAgICAgICBpZiAobm9kZS5uZXh0ID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLnRhaWwgPSBuZXdOb2RlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbm9kZS5uZXh0LnByZXYgPSBuZXdOb2RlO1xuICAgICAgICB9XG4gICAgICAgIG5vZGUubmV4dCA9IG5ld05vZGU7XG4gICAgICAgIHRoaXMubGlzdFNpemUgKz0gMTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGluc2VydEJlZm9yZShub2RlLCBuZXdOb2RlKSB7XG4gICAgICAgIGlmICghdGhpcy5pc0xpbmtlZChub2RlKSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICBuZXdOb2RlLnByZXYgPSBub2RlLnByZXY7XG4gICAgICAgIG5ld05vZGUubmV4dCA9IG5vZGU7XG4gICAgICAgIGlmIChub2RlLnByZXYgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuaGVhZCA9IG5ld05vZGU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBub2RlLnByZXYubmV4dCA9IG5ld05vZGU7XG4gICAgICAgIH1cbiAgICAgICAgbm9kZS5wcmV2ID0gbmV3Tm9kZTtcbiAgICAgICAgdGhpcy5saXN0U2l6ZSArPSAxO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgcHVzaChub2RlKSB7XG4gICAgICAgIGlmICh0aGlzLmhlYWQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMudW5zaGlmdChub2RlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuaW5zZXJ0QWZ0ZXIodGhpcy50YWlsLCBub2RlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgdW5zaGlmdChub2RlKSB7XG4gICAgICAgIGlmICh0aGlzLmhlYWQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuaGVhZCA9IG5vZGU7XG4gICAgICAgICAgICB0aGlzLnRhaWwgPSBub2RlO1xuICAgICAgICAgICAgbm9kZS5wcmV2ID0gbnVsbDtcbiAgICAgICAgICAgIG5vZGUubmV4dCA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLmxpc3RTaXplICs9IDE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmluc2VydEJlZm9yZSh0aGlzLmhlYWQsIG5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICByZW1vdmUobm9kZSkge1xuICAgICAgICBpZiAoIXRoaXMuaXNMaW5rZWQobm9kZSkpXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgaWYgKG5vZGUucHJldiA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5oZWFkID0gbm9kZS5uZXh0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbm9kZS5wcmV2Lm5leHQgPSBub2RlLm5leHQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vZGUubmV4dCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy50YWlsID0gbm9kZS5wcmV2O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbm9kZS5uZXh0LnByZXYgPSBub2RlLnByZXY7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5saXN0U2l6ZSAtPSAxO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG59XG5cbi8qKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIG5ldyBCU0QgTGljZW5zZS5cbiAqIENvcHlyaWdodCAyMDA5LTIwMTAsIEJyYW0gU3RlaW5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKi9cbmZ1bmN0aW9uIGJyZWFrcG9pbnQocG9zaXRpb24sIGRlbWVyaXRzLCBsaW5lLCBmaXRuZXNzQ2xhc3MsIHRvdGFscywgcHJldmlvdXMpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBwb3NpdGlvbixcbiAgICAgICAgZGVtZXJpdHMsXG4gICAgICAgIGxpbmUsXG4gICAgICAgIGZpdG5lc3NDbGFzcyxcbiAgICAgICAgdG90YWxzOiB0b3RhbHMgfHwge1xuICAgICAgICAgICAgd2lkdGg6IDAsXG4gICAgICAgICAgICBzdHJldGNoOiAwLFxuICAgICAgICAgICAgc2hyaW5rOiAwLFxuICAgICAgICB9LFxuICAgICAgICBwcmV2aW91cyxcbiAgICB9O1xufVxuZnVuY3Rpb24gY29tcHV0ZUNvc3Qobm9kZXMsIGxpbmVMZW5ndGhzLCBzdW0sIGVuZCwgYWN0aXZlLCBjdXJyZW50TGluZSkge1xuICAgIGxldCB3aWR0aCA9IHN1bS53aWR0aCAtIGFjdGl2ZS50b3RhbHMud2lkdGg7XG4gICAgbGV0IHN0cmV0Y2ggPSAwO1xuICAgIGxldCBzaHJpbmsgPSAwO1xuICAgIC8vIElmIHRoZSBjdXJyZW50IGxpbmUgaW5kZXggaXMgd2l0aGluIHRoZSBsaXN0IG9mIGxpbmVsZW5ndGhzLCB1c2UgaXQsIG90aGVyd2lzZSB1c2VcbiAgICAvLyB0aGUgbGFzdCBsaW5lIGxlbmd0aCBvZiB0aGUgbGlzdC5cbiAgICBjb25zdCBsaW5lTGVuZ3RoID0gY3VycmVudExpbmUgPCBsaW5lTGVuZ3Rocy5sZW5ndGhcbiAgICAgICAgPyBsaW5lTGVuZ3Roc1tjdXJyZW50TGluZSAtIDFdXG4gICAgICAgIDogbGluZUxlbmd0aHNbbGluZUxlbmd0aHMubGVuZ3RoIC0gMV07XG4gICAgaWYgKG5vZGVzW2VuZF0udHlwZSA9PT0gJ3BlbmFsdHknKSB7XG4gICAgICAgIHdpZHRoICs9IG5vZGVzW2VuZF0ud2lkdGg7XG4gICAgfVxuICAgIC8vIENhbGN1bGF0ZSB0aGUgc3RyZXRjaCByYXRpb1xuICAgIGlmICh3aWR0aCA8IGxpbmVMZW5ndGgpIHtcbiAgICAgICAgc3RyZXRjaCA9IHN1bS5zdHJldGNoIC0gYWN0aXZlLnRvdGFscy5zdHJldGNoO1xuICAgICAgICBpZiAoc3RyZXRjaCA+IDApIHtcbiAgICAgICAgICAgIHJldHVybiAobGluZUxlbmd0aCAtIHdpZHRoKSAvIHN0cmV0Y2g7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxpbmVicmVhay5pbmZpbml0eTtcbiAgICB9XG4gICAgLy8gQ2FsY3VsYXRlIHRoZSBzaHJpbmsgcmF0aW9cbiAgICBpZiAod2lkdGggPiBsaW5lTGVuZ3RoKSB7XG4gICAgICAgIHNocmluayA9IHN1bS5zaHJpbmsgLSBhY3RpdmUudG90YWxzLnNocmluaztcbiAgICAgICAgaWYgKHNocmluayA+IDApIHtcbiAgICAgICAgICAgIHJldHVybiAobGluZUxlbmd0aCAtIHdpZHRoKSAvIHNocmluaztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbGluZWJyZWFrLmluZmluaXR5O1xuICAgIH1cbiAgICAvLyBwZXJmZWN0IG1hdGNoXG4gICAgcmV0dXJuIDA7XG59XG4vLyBBZGQgd2lkdGgsIHN0cmV0Y2ggYW5kIHNocmluayB2YWx1ZXMgZnJvbSB0aGUgY3VycmVudFxuLy8gYnJlYWsgcG9pbnQgdXAgdG8gdGhlIG5leHQgYm94IG9yIGZvcmNlZCBwZW5hbHR5LlxuZnVuY3Rpb24gY29tcHV0ZVN1bShub2Rlcywgc3VtLCBicmVha1BvaW50SW5kZXgpIHtcbiAgICBjb25zdCByZXN1bHQgPSB7XG4gICAgICAgIHdpZHRoOiBzdW0ud2lkdGgsXG4gICAgICAgIHN0cmV0Y2g6IHN1bS5zdHJldGNoLFxuICAgICAgICBzaHJpbms6IHN1bS5zaHJpbmssXG4gICAgfTtcbiAgICBmb3IgKGxldCBpID0gYnJlYWtQb2ludEluZGV4OyBpIDwgbm9kZXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgY29uc3Qgbm9kZSA9IG5vZGVzW2ldO1xuICAgICAgICBpZiAobm9kZS50eXBlID09PSAnZ2x1ZScpIHtcbiAgICAgICAgICAgIHJlc3VsdC53aWR0aCArPSBub2RlLndpZHRoO1xuICAgICAgICAgICAgcmVzdWx0LnN0cmV0Y2ggKz0gbm9kZS5zdHJldGNoO1xuICAgICAgICAgICAgcmVzdWx0LnNocmluayArPSBub2RlLnNocmluaztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChub2RlLnR5cGUgPT09ICdib3gnIHx8XG4gICAgICAgICAgICAobm9kZS50eXBlID09PSAncGVuYWx0eScgJiZcbiAgICAgICAgICAgICAgICBub2RlLnBlbmFsdHkgPT09IC1saW5lYnJlYWsuaW5maW5pdHkgJiZcbiAgICAgICAgICAgICAgICBpID4gYnJlYWtQb2ludEluZGV4KSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGZpbmRCZXN0QnJlYWtwb2ludHMoYWN0aXZlTm9kZXMpIHtcbiAgICBjb25zdCBicmVha3BvaW50cyA9IFtdO1xuICAgIGlmIChhY3RpdmVOb2Rlcy5zaXplKCkgPT09IDApXG4gICAgICAgIHJldHVybiBbXTtcbiAgICBsZXQgdG1wID0geyBkYXRhOiB7IGRlbWVyaXRzOiBJbmZpbml0eSB9IH07XG4gICAgLy8gRmluZCB0aGUgYmVzdCBhY3RpdmUgbm9kZSAodGhlIG9uZSB3aXRoIHRoZSBsZWFzdCB0b3RhbCBkZW1lcml0cy4pXG4gICAgYWN0aXZlTm9kZXMuZm9yRWFjaCgobm9kZSkgPT4ge1xuICAgICAgICBpZiAobm9kZS5kYXRhLmRlbWVyaXRzIDwgdG1wLmRhdGEuZGVtZXJpdHMpIHtcbiAgICAgICAgICAgIHRtcCA9IG5vZGU7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICB3aGlsZSAodG1wICE9PSBudWxsKSB7XG4gICAgICAgIGJyZWFrcG9pbnRzLnB1c2godG1wLmRhdGEucG9zaXRpb24pO1xuICAgICAgICB0bXAgPSB0bXAuZGF0YS5wcmV2aW91cztcbiAgICB9XG4gICAgcmV0dXJuIGJyZWFrcG9pbnRzLnJldmVyc2UoKTtcbn1cbi8qKlxuICogQHBhcmFtIG5vZGVzXG4gKiBAcGFyYW0gYXZhaWxhYmxlV2lkdGhzXG4gKiBAcGFyYW0gdG9sZXJhbmNlXG4gKiBAcHJlc2VydmUgS251dGggYW5kIFBsYXNzIGxpbmUgYnJlYWtpbmcgYWxnb3JpdGhtIGluIEphdmFTY3JpcHRcbiAqL1xuY29uc3QgbGluZWJyZWFrID0gKG5vZGVzLCBhdmFpbGFibGVXaWR0aHMsIHRvbGVyYW5jZSkgPT4ge1xuICAgIC8vIERlbWVyaXRzIGFyZSB1c2VkIGFzIGEgd2F5IHRvIHBlbmFsaXplIGJhZCBsaW5lIGJyZWFrc1xuICAgIC8vICAtIGxpbmU6IGFwcGxpZWQgdG8gZWFjaCBsaW5lLCBkZXBlbmRpbmcgb24gaG93IG11Y2ggc3BhY2VzIG5lZWQgdG8gc3RyZXRjaCBvciBzaHJpbmtcbiAgICAvLyAgLSBmbGFnZ2VkOiBhcHBsaWVkIHdoZW4gY29uc2VjdXRpdmUgbGluZXMgZW5kIGluIGh5cGhlbmF0aW9uXG4gICAgLy8gIC0gZml0bmVzczogYWxnb3JpdGhtIGdyb3VwcyBsaW5lcyBpbnRvIGZpdG5lc3MgY2xhc3NlcyBiYXNlZCBvbiBob3cgbG9vc2Ugb3IgdGlnaHQgdGhlIHNwYWNpbmcgaXMuXG4gICAgLy8gICAgICAgICAgICAgaWYgYSBwYXJhZ3JhcGggaGFzIGNvbnNlY3V0aXZlIGxpbmVzIGZyb20gZGlmZmVyZW50IGZpdG5lc3MgY2xhc3NlcyxcbiAgICAvLyAgICAgICAgICAgICBhIGZpdG5lc3MgZGVtZXJpdCBpcyBhcHBsaWVkIHRvIG1haW50YWluIHZpc3VhbCBjb25zaXN0ZW5jeS5cbiAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgICBkZW1lcml0czogeyBsaW5lOiAxMCwgZmxhZ2dlZDogMTAwLCBmaXRuZXNzOiAzMDAwIH0sXG4gICAgICAgIHRvbGVyYW5jZTogdG9sZXJhbmNlIHx8IDMsXG4gICAgfTtcbiAgICBjb25zdCBhY3RpdmVOb2RlcyA9IG5ldyBMaW5rZWRMaXN0KCk7XG4gICAgY29uc3Qgc3VtID0geyB3aWR0aDogMCwgc3RyZXRjaDogMCwgc2hyaW5rOiAwIH07XG4gICAgY29uc3QgbGluZUxlbmd0aHMgPSBhdmFpbGFibGVXaWR0aHM7XG4gICAgLy8gQWRkIGFuIGFjdGl2ZSBub2RlIGZvciB0aGUgc3RhcnQgb2YgdGhlIHBhcmFncmFwaC5cbiAgICBhY3RpdmVOb2Rlcy5wdXNoKG5ldyBMaW5rZWRMaXN0Lk5vZGUoYnJlYWtwb2ludCgwLCAwLCAwLCAwLCB1bmRlZmluZWQsIG51bGwpKSk7XG4gICAgLy8gVGhlIG1haW4gbG9vcCBvZiB0aGUgYWxnb3JpdGhtXG4gICAgZnVuY3Rpb24gbWFpbkxvb3Aobm9kZSwgaW5kZXgsIG5vZGVzKSB7XG4gICAgICAgIGxldCBhY3RpdmUgPSBhY3RpdmVOb2Rlcy5maXJzdCgpO1xuICAgICAgICAvLyBUaGUgaW5uZXIgbG9vcCBpdGVyYXRlcyB0aHJvdWdoIGFsbCB0aGUgYWN0aXZlIG5vZGVzIHdpdGggbGluZSA8IGN1cnJlbnRMaW5lIGFuZCB0aGVuXG4gICAgICAgIC8vIGJyZWFrcyBvdXQgdG8gaW5zZXJ0IHRoZSBuZXcgYWN0aXZlIG5vZGUgY2FuZGlkYXRlcyBiZWZvcmUgbG9va2luZyBhdCB0aGUgbmV4dCBhY3RpdmVcbiAgICAgICAgLy8gbm9kZXMgZm9yIHRoZSBuZXh0IGxpbmVzLiBUaGUgcmVzdWx0IG9mIHRoaXMgaXMgdGhhdCB0aGUgYWN0aXZlIG5vZGUgbGlzdCBpcyBhbHdheXNcbiAgICAgICAgLy8gc29ydGVkIGJ5IGxpbmUgbnVtYmVyLlxuICAgICAgICB3aGlsZSAoYWN0aXZlICE9PSBudWxsKSB7XG4gICAgICAgICAgICBsZXQgY3VycmVudExpbmUgPSAwO1xuICAgICAgICAgICAgLy8gQ2FuZGlkYXRlcyBmbyBlYWNoIGZpdG5lc3MgY2xhc3NcbiAgICAgICAgICAgIGNvbnN0IGNhbmRpZGF0ZXMgPSBbXG4gICAgICAgICAgICAgICAgeyBhY3RpdmU6IHVuZGVmaW5lZCwgZGVtZXJpdHM6IEluZmluaXR5IH0sXG4gICAgICAgICAgICAgICAgeyBhY3RpdmU6IHVuZGVmaW5lZCwgZGVtZXJpdHM6IEluZmluaXR5IH0sXG4gICAgICAgICAgICAgICAgeyBhY3RpdmU6IHVuZGVmaW5lZCwgZGVtZXJpdHM6IEluZmluaXR5IH0sXG4gICAgICAgICAgICAgICAgeyBhY3RpdmU6IHVuZGVmaW5lZCwgZGVtZXJpdHM6IEluZmluaXR5IH0sXG4gICAgICAgICAgICBdO1xuICAgICAgICAgICAgLy8gSXRlcmF0ZSB0aHJvdWdoIHRoZSBsaW5rZWQgbGlzdCBvZiBhY3RpdmUgbm9kZXMgdG8gZmluZCBuZXcgcG90ZW50aWFsIGFjdGl2ZSBub2RlcyBhbmQgZGVhY3RpdmF0ZSBjdXJyZW50IGFjdGl2ZSBub2Rlcy5cbiAgICAgICAgICAgIHdoaWxlIChhY3RpdmUgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50TGluZSA9IGFjdGl2ZS5kYXRhLmxpbmUgKyAxO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJhdGlvID0gY29tcHV0ZUNvc3Qobm9kZXMsIGxpbmVMZW5ndGhzLCBzdW0sIGluZGV4LCBhY3RpdmUuZGF0YSwgY3VycmVudExpbmUpO1xuICAgICAgICAgICAgICAgIC8vIERlYWN0aXZlIG5vZGVzIHdoZW4gdGhlIGRpc3RhbmNlIGJldHdlZW4gdGhlIGN1cnJlbnQgYWN0aXZlIG5vZGUgYW5kIHRoZVxuICAgICAgICAgICAgICAgIC8vIGN1cnJlbnQgbm9kZSBiZWNvbWVzIHRvbyBsYXJnZSAoaS5lLiBpdCBleGNlZWRzIHRoZSBzdHJldGNoIGxpbWl0IGFuZCB0aGUgc3RyZXRjaFxuICAgICAgICAgICAgICAgIC8vIHJhdGlvIGJlY29tZXMgbmVnYXRpdmUpIG9yIHdoZW4gdGhlIGN1cnJlbnQgbm9kZSBpcyBhIGZvcmNlZCBicmVhayAoaS5lLiB0aGUgZW5kXG4gICAgICAgICAgICAgICAgLy8gb2YgdGhlIHBhcmFncmFwaCB3aGVuIHdlIHdhbnQgdG8gcmVtb3ZlIGFsbCBhY3RpdmUgbm9kZXMsIGJ1dCBwb3NzaWJseSBoYXZlIGEgZmluYWxcbiAgICAgICAgICAgICAgICAvLyBjYW5kaWRhdGUgYWN0aXZlIG5vZGUtLS1pZiB0aGUgcGFyYWdyYXBoIGNhbiBiZSBzZXQgdXNpbmcgdGhlIGdpdmVuIHRvbGVyYW5jZSB2YWx1ZS4pXG4gICAgICAgICAgICAgICAgaWYgKHJhdGlvIDwgLTEgfHxcbiAgICAgICAgICAgICAgICAgICAgKG5vZGUudHlwZSA9PT0gJ3BlbmFsdHknICYmIG5vZGUucGVuYWx0eSA9PT0gLWxpbmVicmVhay5pbmZpbml0eSkpIHtcbiAgICAgICAgICAgICAgICAgICAgYWN0aXZlTm9kZXMucmVtb3ZlKGFjdGl2ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIElmIHRoZSByYXRpbyBpcyB3aXRoaW4gdGhlIHZhbGlkIHJhbmdlIG9mIC0xIDw9IHJhdGlvIDw9IHRvbGVyYW5jZSBjYWxjdWxhdGUgdGhlXG4gICAgICAgICAgICAgICAgLy8gdG90YWwgZGVtZXJpdHMgYW5kIHJlY29yZCBhIGNhbmRpZGF0ZSBhY3RpdmUgbm9kZS5cbiAgICAgICAgICAgICAgICBpZiAocmF0aW8gPj0gLTEgJiYgcmF0aW8gPD0gb3B0aW9ucy50b2xlcmFuY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYmFkbmVzcyA9IDEwMCAqIE1hdGgucG93KE1hdGguYWJzKHJhdGlvKSwgMyk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBkZW1lcml0cyA9IDA7XG4gICAgICAgICAgICAgICAgICAgIC8vIFBvc2l0aXZlIHBlbmFsdHlcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUudHlwZSA9PT0gJ3BlbmFsdHknICYmIG5vZGUucGVuYWx0eSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZW1lcml0cyA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgTWF0aC5wb3cob3B0aW9ucy5kZW1lcml0cy5saW5lICsgYmFkbmVzcywgMikgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBNYXRoLnBvdyhub2RlLnBlbmFsdHksIDIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTmVnYXRpdmUgcGVuYWx0eSBidXQgbm90IGEgZm9yY2VkIGJyZWFrXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAobm9kZS50eXBlID09PSAncGVuYWx0eScgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUucGVuYWx0eSAhPT0gLWxpbmVicmVhay5pbmZpbml0eSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVtZXJpdHMgPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIE1hdGgucG93KG9wdGlvbnMuZGVtZXJpdHMubGluZSArIGJhZG5lc3MsIDIpIC1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTWF0aC5wb3cobm9kZS5wZW5hbHR5LCAyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFsbCBvdGhlciBjYXNlc1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVtZXJpdHMgPSBNYXRoLnBvdyhvcHRpb25zLmRlbWVyaXRzLmxpbmUgKyBiYWRuZXNzLCAyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS50eXBlID09PSAncGVuYWx0eScgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVzW2FjdGl2ZS5kYXRhLnBvc2l0aW9uXS50eXBlID09PSAncGVuYWx0eScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbWVyaXRzICs9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5kZW1lcml0cy5mbGFnZ2VkICpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5mbGFnZ2VkICpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBub2RlIGlzIHBlbmFsdHkgaGVyZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2Rlc1thY3RpdmUuZGF0YS5wb3NpdGlvbl0uZmxhZ2dlZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBDYWxjdWxhdGUgdGhlIGZpdG5lc3MgY2xhc3MgZm9yIHRoaXMgY2FuZGlkYXRlIGFjdGl2ZSBub2RlLlxuICAgICAgICAgICAgICAgICAgICBsZXQgY3VycmVudENsYXNzO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmF0aW8gPCAtMC41KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50Q2xhc3MgPSAwO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHJhdGlvIDw9IDAuNSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudENsYXNzID0gMTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChyYXRpbyA8PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50Q2xhc3MgPSAyO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudENsYXNzID0gMztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBBZGQgYSBmaXRuZXNzIHBlbmFsdHkgdG8gdGhlIGRlbWVyaXRzIGlmIHRoZSBmaXRuZXNzIGNsYXNzZXMgb2YgdHdvIGFkamFjZW50IGxpbmVzIGRpZmZlciB0b28gbXVjaC5cbiAgICAgICAgICAgICAgICAgICAgaWYgKE1hdGguYWJzKGN1cnJlbnRDbGFzcyAtIGFjdGl2ZS5kYXRhLmZpdG5lc3NDbGFzcykgPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZW1lcml0cyArPSBvcHRpb25zLmRlbWVyaXRzLmZpdG5lc3M7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gQWRkIHRoZSB0b3RhbCBkZW1lcml0cyBvZiB0aGUgYWN0aXZlIG5vZGUgdG8gZ2V0IHRoZSB0b3RhbCBkZW1lcml0cyBvZiB0aGlzIGNhbmRpZGF0ZSBub2RlLlxuICAgICAgICAgICAgICAgICAgICBkZW1lcml0cyArPSBhY3RpdmUuZGF0YS5kZW1lcml0cztcbiAgICAgICAgICAgICAgICAgICAgLy8gT25seSBzdG9yZSB0aGUgYmVzdCBjYW5kaWRhdGUgZm9yIGVhY2ggZml0bmVzcyBjbGFzc1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGVtZXJpdHMgPCBjYW5kaWRhdGVzW2N1cnJlbnRDbGFzc10uZGVtZXJpdHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbmRpZGF0ZXNbY3VycmVudENsYXNzXSA9IHsgYWN0aXZlLCBkZW1lcml0cyB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGFjdGl2ZSA9IGFjdGl2ZS5uZXh0O1xuICAgICAgICAgICAgICAgIC8vIFN0b3AgaXRlcmF0aW5nIHRocm91Z2ggYWN0aXZlIG5vZGVzIHRvIGluc2VydCBuZXcgY2FuZGlkYXRlIGFjdGl2ZSBub2RlcyBpbiB0aGUgYWN0aXZlIGxpc3RcbiAgICAgICAgICAgICAgICAvLyBiZWZvcmUgbW92aW5nIG9uIHRvIHRoZSBhY3RpdmUgbm9kZXMgZm9yIHRoZSBuZXh0IGxpbmUuXG4gICAgICAgICAgICAgICAgLy8gVE9ETzogVGhlIEtudXRoIGFuZCBQbGFzcyBwYXBlciBzdWdnZXN0cyBhIGNvbmRpdGlvbmFsIGZvciBjdXJyZW50TGluZSA8IGowLiBUaGlzIG1lYW5zIHBhcmFncmFwaHNcbiAgICAgICAgICAgICAgICAvLyB3aXRoIGlkZW50aWNhbCBsaW5lIGxlbmd0aHMgd2lsbCBub3QgYmUgc29ydGVkIGJ5IGxpbmUgbnVtYmVyLiBGaW5kIG91dCBpZiB0aGF0IGlzIGEgZGVzaXJhYmxlIG91dGNvbWUuXG4gICAgICAgICAgICAgICAgLy8gRm9yIG5vdyBJIGxlZnQgdGhpcyBvdXQsIGFzIGl0IG9ubHkgYWRkcyBtaW5pbWFsIG92ZXJoZWFkIHRvIHRoZSBhbGdvcml0aG0gYW5kIGtlZXBpbmcgdGhlIGFjdGl2ZSBub2RlXG4gICAgICAgICAgICAgICAgLy8gbGlzdCBzb3J0ZWQgaGFzIGEgaGlnaGVyIHByaW9yaXR5LlxuICAgICAgICAgICAgICAgIGlmIChhY3RpdmUgIT09IG51bGwgJiYgYWN0aXZlLmRhdGEubGluZSA+PSBjdXJyZW50TGluZSkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB0bXBTdW0gPSBjb21wdXRlU3VtKG5vZGVzLCBzdW0sIGluZGV4KTtcbiAgICAgICAgICAgIGZvciAobGV0IGZpdG5lc3NDbGFzcyA9IDA7IGZpdG5lc3NDbGFzcyA8IGNhbmRpZGF0ZXMubGVuZ3RoOyBmaXRuZXNzQ2xhc3MgKz0gMSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNhbmRpZGF0ZSA9IGNhbmRpZGF0ZXNbZml0bmVzc0NsYXNzXTtcbiAgICAgICAgICAgICAgICBpZiAoY2FuZGlkYXRlLmRlbWVyaXRzID09PSBJbmZpbml0eSlcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV3Tm9kZSA9IG5ldyBMaW5rZWRMaXN0Lk5vZGUoYnJlYWtwb2ludChpbmRleCwgY2FuZGlkYXRlLmRlbWVyaXRzLCBjYW5kaWRhdGUuYWN0aXZlLmRhdGEubGluZSArIDEsIGZpdG5lc3NDbGFzcywgdG1wU3VtLCBjYW5kaWRhdGUuYWN0aXZlKSk7XG4gICAgICAgICAgICAgICAgaWYgKGFjdGl2ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBhY3RpdmVOb2Rlcy5pbnNlcnRCZWZvcmUoYWN0aXZlLCBuZXdOb2RlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGFjdGl2ZU5vZGVzLnB1c2gobmV3Tm9kZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIG5vZGVzLmZvckVhY2goKG5vZGUsIGluZGV4LCBub2RlcykgPT4ge1xuICAgICAgICBpZiAobm9kZS50eXBlID09PSAnYm94Jykge1xuICAgICAgICAgICAgc3VtLndpZHRoICs9IG5vZGUud2lkdGg7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vZGUudHlwZSA9PT0gJ2dsdWUnKSB7XG4gICAgICAgICAgICBjb25zdCBwcmVjZWRlc0JveCA9IGluZGV4ID4gMCAmJiBub2Rlc1tpbmRleCAtIDFdLnR5cGUgPT09ICdib3gnO1xuICAgICAgICAgICAgaWYgKHByZWNlZGVzQm94KVxuICAgICAgICAgICAgICAgIG1haW5Mb29wKG5vZGUsIGluZGV4LCBub2Rlcyk7XG4gICAgICAgICAgICBzdW0ud2lkdGggKz0gbm9kZS53aWR0aDtcbiAgICAgICAgICAgIHN1bS5zdHJldGNoICs9IG5vZGUuc3RyZXRjaDtcbiAgICAgICAgICAgIHN1bS5zaHJpbmsgKz0gbm9kZS5zaHJpbms7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vZGUudHlwZSA9PT0gJ3BlbmFsdHknICYmIG5vZGUucGVuYWx0eSAhPT0gbGluZWJyZWFrLmluZmluaXR5KSB7XG4gICAgICAgICAgICBtYWluTG9vcChub2RlLCBpbmRleCwgbm9kZXMpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGZpbmRCZXN0QnJlYWtwb2ludHMoYWN0aXZlTm9kZXMpO1xufTtcbmxpbmVicmVhay5pbmZpbml0eSA9IDEwMDAwO1xubGluZWJyZWFrLmdsdWUgPSAod2lkdGgsIHN0YXJ0LCBlbmQsIHN0cmV0Y2gsIHNocmluaykgPT4gKHtcbiAgICB0eXBlOiAnZ2x1ZScsXG4gICAgc3RhcnQsXG4gICAgZW5kLFxuICAgIHdpZHRoLFxuICAgIHN0cmV0Y2gsXG4gICAgc2hyaW5rLFxufSk7XG5saW5lYnJlYWsuYm94ID0gKHdpZHRoLCBzdGFydCwgZW5kLCBoeXBoZW5hdGVkID0gZmFsc2UpID0+ICh7XG4gICAgdHlwZTogJ2JveCcsXG4gICAgd2lkdGgsXG4gICAgc3RhcnQsXG4gICAgZW5kLFxuICAgIGh5cGhlbmF0ZWQsXG59KTtcbmxpbmVicmVhay5wZW5hbHR5ID0gKHdpZHRoLCBwZW5hbHR5LCBmbGFnZ2VkKSA9PiAoe1xuICAgIHR5cGU6ICdwZW5hbHR5JyxcbiAgICB3aWR0aCxcbiAgICBwZW5hbHR5LFxuICAgIGZsYWdnZWQsXG59KTtcblxuLyoqXG4gKiBBZGQgc2NhbGFyIHRvIHJ1blxuICpcbiAqIEBwYXJhbSBpbmRleCAtIFNjYWxhclxuICogQHBhcmFtIHJ1biAtIFJ1blxuICogQHJldHVybnMgQWRkZWQgcnVuXG4gKi9cbmNvbnN0IGFkZCA9IChpbmRleCwgcnVuKSA9PiB7XG4gICAgY29uc3Qgc3RhcnQgPSBydW4uc3RhcnQgKyBpbmRleDtcbiAgICBjb25zdCBlbmQgPSBydW4uZW5kICsgaW5kZXg7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIHJ1biwgeyBzdGFydCwgZW5kIH0pO1xufTtcblxuLyoqXG4gKiBHZXQgcnVuIGxlbmd0aFxuICpcbiAqIEBwYXJhbSBydW4gLSBSdW5cbiAqIEByZXR1cm5zIExlbmd0aFxuICovXG5jb25zdCBsZW5ndGggPSAocnVuKSA9PiB7XG4gICAgcmV0dXJuIHJ1bi5lbmQgLSBydW4uc3RhcnQ7XG59O1xuXG4vKipcbiAqIENvbmNhdHMgdHdvIHJ1bnMgaW50byBvbmVcbiAqXG4gKiBAcGFyYW0gcnVuQSAtIEZpcnN0IHJ1blxuICogQHBhcmFtIHJ1bkIgLSBTZWNvbmQgcnVuXG4gKiBAcmV0dXJucyBDb25jYXRlbmF0ZWQgcnVuXG4gKi9cbmNvbnN0IGNvbmNhdCA9IChydW5BLCBydW5CKSA9PiB7XG4gICAgY29uc3QgZW5kID0gcnVuQS5lbmQgKyBsZW5ndGgocnVuQik7XG4gICAgY29uc3QgZ2x5cGhzID0gKHJ1bkEuZ2x5cGhzIHx8IFtdKS5jb25jYXQocnVuQi5nbHlwaHMgfHwgW10pO1xuICAgIGNvbnN0IHBvc2l0aW9ucyA9IChydW5BLnBvc2l0aW9ucyB8fCBbXSkuY29uY2F0KHJ1bkIucG9zaXRpb25zIHx8IFtdKTtcbiAgICBjb25zdCBhdHRyaWJ1dGVzID0gT2JqZWN0LmFzc2lnbih7fSwgcnVuQS5hdHRyaWJ1dGVzLCBydW5CLmF0dHJpYnV0ZXMpO1xuICAgIGNvbnN0IHJ1bkFJbmRpY2VzID0gcnVuQS5nbHlwaEluZGljZXMgfHwgW107XG4gICAgY29uc3QgcnVuQUxhc3RJbmRleCA9IGxhc3QocnVuQUluZGljZXMpIHx8IDA7XG4gICAgY29uc3QgcnVuQkluZGljZXMgPSAocnVuQi5nbHlwaEluZGljZXMgfHwgW10pLm1hcCgoaSkgPT4gaSArIHJ1bkFMYXN0SW5kZXggKyAxKTtcbiAgICBjb25zdCBnbHlwaEluZGljZXMgPSBub3JtYWxpemUocnVuQUluZGljZXMuY29uY2F0KHJ1bkJJbmRpY2VzKSk7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIHJ1bkEsIHtcbiAgICAgICAgZW5kLFxuICAgICAgICBnbHlwaHMsXG4gICAgICAgIHBvc2l0aW9ucyxcbiAgICAgICAgYXR0cmlidXRlcyxcbiAgICAgICAgZ2x5cGhJbmRpY2VzLFxuICAgIH0pO1xufTtcblxuLyoqXG4gKiBJbnNlcnQgZ2x5cGggdG8gcnVuIGluIHRoZSBnaXZlbiBpbmRleFxuICpcbiAqIEBwYXJhbSBpbmRleCAtIEluZGV4XG4gKiBAcGFyYW0gZ2x5cGggLSBHbHlwaFxuICogQHBhcmFtIHJ1biAtIFJ1blxuICogQHJldHVybnMgUnVuIHdpdGggZ2x5cGhcbiAqL1xuY29uc3QgaW5zZXJ0R2x5cGgkMSA9IChpbmRleCwgZ2x5cGgsIHJ1bikgPT4ge1xuICAgIGlmICghZ2x5cGgpXG4gICAgICAgIHJldHVybiBydW47XG4gICAgLy8gU3BsaXQgcmVzb2x2ZXMgbGlnYXR1cmUgc3BsaXR0aW5nIGluIGNhc2UgbmV3IGdseXBoIGJyZWFrcyBzb21lXG4gICAgY29uc3QgbGVhZGluZ1J1biA9IHNsaWNlJDEoMCwgaW5kZXgsIHJ1bik7XG4gICAgY29uc3QgdHJhaWxpbmdSdW4gPSBzbGljZSQxKGluZGV4LCBJbmZpbml0eSwgcnVuKTtcbiAgICByZXR1cm4gY29uY2F0KGFwcGVuZCQxKGdseXBoLCBsZWFkaW5nUnVuKSwgdHJhaWxpbmdSdW4pO1xufTtcbi8qKlxuICogSW5zZXJ0IGVpdGhlciBnbHlwaCBvciBjb2RlIHBvaW50IHRvIHJ1biBpbiB0aGUgZ2l2ZW4gaW5kZXhcbiAqXG4gKiBAcGFyYW0gaW5kZXggLSBJbmRleFxuICogQHBhcmFtIHZhbHVlIC0gR2x5cGggb3IgY29kZVBvaW50XG4gKiBAcGFyYW0gcnVuIC0gUnVuXG4gKiBAcmV0dXJucyBSdW4gd2l0aCBnbHlwaFxuICovXG5jb25zdCBpbnNlcnQgPSAoaW5kZXgsIHZhbHVlLCBydW4pID0+IHtcbiAgICBjb25zdCBmb250ID0gZ2V0Rm9udChydW4pO1xuICAgIGNvbnN0IGdseXBoID0gaXNOdW1iZXIodmFsdWUpID8gZnJvbUNvZGVQb2ludCh2YWx1ZSwgZm9udCkgOiB2YWx1ZTtcbiAgICByZXR1cm4gaW5zZXJ0R2x5cGgkMShpbmRleCwgZ2x5cGgsIHJ1bik7XG59O1xuXG4vKipcbiAqIEdldCBydW4gaW5kZXggYXQgY2hhciBpbmRleFxuICpcbiAqIEBwYXJhbSBpbmRleCAtIENoYXIgaW5kZXhcbiAqIEBwYXJhbSBhdHRyaWJ1dGVkU3RyaW5nIC0gQXR0cmlidXRlZCBzdHJpbmdcbiAqIEByZXR1cm5zIFJ1biBpbmRleFxuICovXG5jb25zdCBydW5JbmRleEF0ID0gKGluZGV4LCBhdHRyaWJ1dGVkU3RyaW5nKSA9PiB7XG4gICAgcmV0dXJuIHJ1bkluZGV4QXQkMShpbmRleCwgYXR0cmlidXRlZFN0cmluZy5ydW5zKTtcbn07XG5cbi8qKlxuICogSW5zZXJ0IGdseXBoIGludG8gYXR0cmlidXRlZCBzdHJpbmdcbiAqXG4gKiBAcGFyYW0gaW5kZXggLSBJbmRleFxuICogQHBhcmFtIGdseXBoIC0gR2x5cGggb3IgY29kZSBwb2ludFxuICogQHBhcmFtIGF0dHJpYnV0ZWRTdHJpbmcgLSBBdHRyaWJ1dGVkIHN0cmluZ1xuICogQHJldHVybnMgQXR0cmlidXRlZCBzdHJpbmcgd2l0aCBuZXcgZ2x5cGhcbiAqL1xuY29uc3QgaW5zZXJ0R2x5cGggPSAoaW5kZXgsIGdseXBoLCBhdHRyaWJ1dGVkU3RyaW5nKSA9PiB7XG4gICAgY29uc3QgcnVuSW5kZXggPSBydW5JbmRleEF0KGluZGV4LCBhdHRyaWJ1dGVkU3RyaW5nKTtcbiAgICAvLyBBZGQgZ2x5cGggdG8gdGhlIGVuZCBpZiBydW4gaW5kZXggaW52YWxpZFxuICAgIGlmIChydW5JbmRleCA9PT0gLTEpXG4gICAgICAgIHJldHVybiBhcHBlbmQoZ2x5cGgsIGF0dHJpYnV0ZWRTdHJpbmcpO1xuICAgIGNvbnN0IGNvZGVQb2ludHMgPSBbZ2x5cGhdIDtcbiAgICBjb25zdCBzdHJpbmcgPSBhdHRyaWJ1dGVkU3RyaW5nLnN0cmluZy5zbGljZSgwLCBpbmRleCkgK1xuICAgICAgICBzdHJpbmdGcm9tQ29kZVBvaW50cyhjb2RlUG9pbnRzKSArXG4gICAgICAgIGF0dHJpYnV0ZWRTdHJpbmcuc3RyaW5nLnNsaWNlKGluZGV4KTtcbiAgICBjb25zdCBydW5zID0gYXR0cmlidXRlZFN0cmluZy5ydW5zLm1hcCgocnVuLCBpKSA9PiB7XG4gICAgICAgIGlmIChpID09PSBydW5JbmRleClcbiAgICAgICAgICAgIHJldHVybiBpbnNlcnQoaW5kZXggLSBydW4uc3RhcnQsIGdseXBoLCBydW4pO1xuICAgICAgICBpZiAoaSA+IHJ1bkluZGV4KVxuICAgICAgICAgICAgcmV0dXJuIGFkZChjb2RlUG9pbnRzLmxlbmd0aCwgcnVuKTtcbiAgICAgICAgcmV0dXJuIHJ1bjtcbiAgICB9KTtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgYXR0cmlidXRlZFN0cmluZywgeyBzdHJpbmcsIHJ1bnMgfSk7XG59O1xuXG4vKipcbiAqIEFkdmFuY2Ugd2lkdGggYmV0d2VlbiB0d28gc3RyaW5nIGluZGljZXNcbiAqXG4gKiBAcGFyYW0gc3RhcnQgLSBHbHlwaCBpbmRleFxuICogQHBhcmFtIGVuZCAtIEdseXBoIGluZGV4XG4gKiBAcGFyYW0gcnVuIC0gUnVuXG4gKiBAcmV0dXJucyBBZHZhbmNlZCB3aWR0aCBydW5cbiAqL1xuY29uc3QgYWR2YW5jZVdpZHRoQmV0d2VlbiQxID0gKHN0YXJ0LCBlbmQsIHJ1bikgPT4ge1xuICAgIGNvbnN0IHJ1blN0YXJ0ID0gcnVuLnN0YXJ0IHx8IDA7XG4gICAgY29uc3QgZ2x5cGhTdGFydEluZGV4ID0gTWF0aC5tYXgoMCwgZ2x5cGhJbmRleEF0KHN0YXJ0IC0gcnVuU3RhcnQsIHJ1bikpO1xuICAgIGNvbnN0IGdseXBoRW5kSW5kZXggPSBNYXRoLm1heCgwLCBnbHlwaEluZGV4QXQoZW5kIC0gcnVuU3RhcnQsIHJ1bikpO1xuICAgIGNvbnN0IHBvc2l0aW9ucyA9IChydW4ucG9zaXRpb25zIHx8IFtdKS5zbGljZShnbHlwaFN0YXJ0SW5kZXgsIGdseXBoRW5kSW5kZXgpO1xuICAgIHJldHVybiBhZHZhbmNlV2lkdGgkMihwb3NpdGlvbnMpO1xufTtcblxuLyoqXG4gKiBBZHZhbmNlIHdpZHRoIGJldHdlZW4gc3RhcnQgYW5kIGVuZFxuICogRG9lcyBub3QgY29uc2lkZXIgbGlnYXR1cmUgc3BsaXR0aW5nIGZvciB0aGUgbW9tZW50LlxuICogQ2hlY2sgcGVyZm9ybWFuY2UgaW1wYWN0IG9uIHN1cHBvcnRpbmcgdGhpc1xuICpcbiAqIEBwYXJhbSBzdGFydCAtIFN0YXJ0IG9mZnNldFxuICogQHBhcmFtIGVuZCAtIEVuZCBvZmZzZXRcbiAqIEBwYXJhbSBhdHRyaWJ1dGVkU3RyaW5nXG4gKiBAcmV0dXJucyBBZHZhbmNlIHdpZHRoXG4gKi9cbmNvbnN0IGFkdmFuY2VXaWR0aEJldHdlZW4gPSAoc3RhcnQsIGVuZCwgYXR0cmlidXRlZFN0cmluZykgPT4ge1xuICAgIGNvbnN0IHJ1bnMgPSBmaWx0ZXIoc3RhcnQsIGVuZCwgYXR0cmlidXRlZFN0cmluZy5ydW5zKTtcbiAgICByZXR1cm4gcnVucy5yZWR1Y2UoKGFjYywgcnVuKSA9PiBhY2MgKyBhZHZhbmNlV2lkdGhCZXR3ZWVuJDEoc3RhcnQsIGVuZCwgcnVuKSwgMCk7XG59O1xuXG5jb25zdCBIWVBIRU4gPSAweDAwMmQ7XG5jb25zdCBUT0xFUkFOQ0VfU1RFUFMgPSA1O1xuY29uc3QgVE9MRVJBTkNFX0xJTUlUID0gNTA7XG5jb25zdCBvcHRzID0ge1xuICAgIHdpZHRoOiAzLFxuICAgIHN0cmV0Y2g6IDYsXG4gICAgc2hyaW5rOiA5LFxufTtcbi8qKlxuICogU2xpY2UgYXR0cmlidXRlZCBzdHJpbmcgdG8gbWFueSBsaW5lc1xuICpcbiAqIEBwYXJhbSBhdHRyaWJ1dGVkU3RyaW5nIC0gQXR0cmlidXRlZCBzdHJpbmdcbiAqIEBwYXJhbSBub2Rlc1xuICogQHBhcmFtIGJyZWFrc1xuICogQHJldHVybnMgQXR0cmlidXRlZCBzdHJpbmdzXG4gKi9cbmNvbnN0IGJyZWFrTGluZXMgPSAoYXR0cmlidXRlZFN0cmluZywgbm9kZXMsIGJyZWFrcykgPT4ge1xuICAgIGxldCBzdGFydCA9IDA7XG4gICAgbGV0IGVuZCA9IG51bGw7XG4gICAgY29uc3QgbGluZXMgPSBicmVha3MucmVkdWNlKChhY2MsIGJyZWFrUG9pbnQpID0+IHtcbiAgICAgICAgY29uc3Qgbm9kZSA9IG5vZGVzW2JyZWFrUG9pbnRdO1xuICAgICAgICBjb25zdCBwcmV2Tm9kZSA9IG5vZGVzW2JyZWFrUG9pbnQgLSAxXTtcbiAgICAgICAgLy8gTGFzdCBicmVha3BvaW50IGNvcnJlc3BvbmRzIHRvIEsmUCBtYW5kYXRvcnkgZmluYWwgZ2x1ZVxuICAgICAgICBpZiAoYnJlYWtQb2ludCA9PT0gbm9kZXMubGVuZ3RoIC0gMSlcbiAgICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgIGxldCBsaW5lO1xuICAgICAgICBpZiAobm9kZS50eXBlID09PSAncGVuYWx0eScpIHtcbiAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgcGVuYWx0eSBub2RlIHdpbGwgYWx3YXlzIHByZWNlZWQgYm94IG9yIGdsdWUgbm9kZVxuICAgICAgICAgICAgZW5kID0gcHJldk5vZGUuZW5kO1xuICAgICAgICAgICAgbGluZSA9IHNsaWNlKHN0YXJ0LCBlbmQsIGF0dHJpYnV0ZWRTdHJpbmcpO1xuICAgICAgICAgICAgbGluZSA9IGluc2VydEdseXBoKGxpbmUuc3RyaW5nLmxlbmd0aCwgSFlQSEVOLCBsaW5lKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGVuZCA9IG5vZGUuZW5kO1xuICAgICAgICAgICAgbGluZSA9IHNsaWNlKHN0YXJ0LCBlbmQsIGF0dHJpYnV0ZWRTdHJpbmcpO1xuICAgICAgICB9XG4gICAgICAgIHN0YXJ0ID0gZW5kO1xuICAgICAgICByZXR1cm4gWy4uLmFjYywgbGluZV07XG4gICAgfSwgW10pO1xuICAgIC8vIExhc3QgbGluZVxuICAgIGxpbmVzLnB1c2goc2xpY2Uoc3RhcnQsIGF0dHJpYnV0ZWRTdHJpbmcuc3RyaW5nLmxlbmd0aCwgYXR0cmlidXRlZFN0cmluZykpO1xuICAgIHJldHVybiBsaW5lcztcbn07XG4vKipcbiAqIFJldHVybiBLbnV0aCAmIFBsYXNzIG5vZGVzIGJhc2VkIG9uIGxpbmUgYW5kIHByZXZpb3VzbHkgY2FsY3VsYXRlZCBzeWxsYWJsZXNcbiAqXG4gKiBAcGFyYW0gYXR0cmlidXRlZFN0cmluZyAtIEF0dHJpYnV0ZWQgc3RyaW5nXG4gKiBAcGFyYW0gYXR0cmlidXRlcyAtIEF0dHJpYnV0ZXNcbiAqIEBwYXJhbSBvcHRpb25zIC0gTGF5b3V0IG9wdGlvbnNcbiAqIEByZXR1cm5zID9cbiAqL1xuY29uc3QgZ2V0Tm9kZXMgPSAoYXR0cmlidXRlZFN0cmluZywgeyBhbGlnbiB9LCBvcHRpb25zKSA9PiB7XG4gICAgbGV0IHN0YXJ0ID0gMDtcbiAgICBjb25zdCBoeXBoZW5XaWR0aCA9IDU7XG4gICAgY29uc3QgeyBzeWxsYWJsZXMgfSA9IGF0dHJpYnV0ZWRTdHJpbmc7XG4gICAgY29uc3QgaHlwaGVuUGVuYWx0eSA9IG9wdGlvbnMuaHlwaGVuYXRpb25QZW5hbHR5IHx8IChhbGlnbiA9PT0gJ2p1c3RpZnknID8gMTAwIDogNjAwKTtcbiAgICBjb25zdCByZXN1bHQgPSBzeWxsYWJsZXMucmVkdWNlKChhY2MsIHMsIGluZGV4KSA9PiB7XG4gICAgICAgIGNvbnN0IHdpZHRoID0gYWR2YW5jZVdpZHRoQmV0d2VlbihzdGFydCwgc3RhcnQgKyBzLmxlbmd0aCwgYXR0cmlidXRlZFN0cmluZyk7XG4gICAgICAgIGlmIChzLnRyaW0oKSA9PT0gJycpIHtcbiAgICAgICAgICAgIGNvbnN0IHN0cmV0Y2ggPSAod2lkdGggKiBvcHRzLndpZHRoKSAvIG9wdHMuc3RyZXRjaDtcbiAgICAgICAgICAgIGNvbnN0IHNocmluayA9ICh3aWR0aCAqIG9wdHMud2lkdGgpIC8gb3B0cy5zaHJpbms7XG4gICAgICAgICAgICBjb25zdCBlbmQgPSBzdGFydCArIHMubGVuZ3RoO1xuICAgICAgICAgICAgLy8gQWRkIGdsdWUgbm9kZS4gR2x1ZSBub2RlcyBhcmUgdXNlZCB0byBmaWxsIHRoZSBzcGFjZSBiZXR3ZWVuIHdvcmRzLlxuICAgICAgICAgICAgYWNjLnB1c2gobGluZWJyZWFrLmdsdWUod2lkdGgsIHN0YXJ0LCBlbmQsIHN0cmV0Y2gsIHNocmluaykpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgaHlwaGVuYXRlZCA9IHN5bGxhYmxlc1tpbmRleCArIDFdICE9PSAnICc7XG4gICAgICAgICAgICBjb25zdCBlbmQgPSBzdGFydCArIHMubGVuZ3RoO1xuICAgICAgICAgICAgLy8gQWRkIGJveCBub2RlLiBCb3ggbm9kZXMgYXJlIHVzZWQgdG8gcmVwcmVzZW50IHdvcmRzLlxuICAgICAgICAgICAgYWNjLnB1c2gobGluZWJyZWFrLmJveCh3aWR0aCwgc3RhcnQsIGVuZCwgaHlwaGVuYXRlZCkpO1xuICAgICAgICAgICAgaWYgKHN5bGxhYmxlc1tpbmRleCArIDFdICYmIGh5cGhlbmF0ZWQpIHtcbiAgICAgICAgICAgICAgICAvLyBBZGQgcGVuYWx0eSBub2RlLiBQZW5hbHR5IG5vZGVzIGFyZSB1c2VkIHRvIHJlcHJlc2VudCBoeXBoZW5hdGlvbiBwb2ludHMuXG4gICAgICAgICAgICAgICAgYWNjLnB1c2gobGluZWJyZWFrLnBlbmFsdHkoaHlwaGVuV2lkdGgsIGh5cGhlblBlbmFsdHksIDEpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzdGFydCArPSBzLmxlbmd0aDtcbiAgICAgICAgcmV0dXJuIGFjYztcbiAgICB9LCBbXSk7XG4gICAgLy8gQWRkIG1hbmRhdG9yeSBmaW5hbCBnbHVlXG4gICAgcmVzdWx0LnB1c2gobGluZWJyZWFrLmdsdWUoMCwgc3RhcnQsIHN0YXJ0LCBsaW5lYnJlYWsuaW5maW5pdHksIDApKTtcbiAgICByZXN1bHQucHVzaChsaW5lYnJlYWsucGVuYWx0eSgwLCAtbGluZWJyZWFrLmluZmluaXR5LCAxKSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG4vKipcbiAqIEBwYXJhbSBhdHRyaWJ1dGVkU3RyaW5nIC0gQXR0cmlidXRlZCBzdHJpbmdcbiAqIEByZXR1cm5zIEF0dHJpYnV0ZXNcbiAqL1xuY29uc3QgZ2V0QXR0cmlidXRlcyA9IChhdHRyaWJ1dGVkU3RyaW5nKSA9PiB7XG4gICAgcmV0dXJuIGF0dHJpYnV0ZWRTdHJpbmcucnVucz8uWzBdPy5hdHRyaWJ1dGVzIHx8IHt9O1xufTtcbi8qKlxuICogUGVyZm9ybXMgS251dGggJiBQbGFzcyBsaW5lIGJyZWFraW5nIGFsZ29yaXRobVxuICogRmFsbGJhY2tzIHRvIGJlc3QgZml0IGFsZ29yaXRobSBpZiBsYXR0ZXIgbm90IHN1Y2Nlc3NmdWxcbiAqXG4gKiBAcGFyYW0gb3B0aW9ucyAtIExheW91dCBvcHRpb25zXG4gKi9cbmNvbnN0IGxpbmVicmVha2VyID0gKG9wdGlvbnMpID0+IHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gYXR0cmlidXRlZFN0cmluZyAtIEF0dHJpYnV0ZWQgc3RyaW5nXG4gICAgICogQHBhcmFtIGF2YWlsYWJsZVdpZHRocyAtIEF2YWlsYWJsZSB3aWR0aHNcbiAgICAgKiBAcmV0dXJucyBBdHRyaWJ1dGVkIHN0cmluZ1xuICAgICAqL1xuICAgIHJldHVybiAoYXR0cmlidXRlZFN0cmluZywgYXZhaWxhYmxlV2lkdGhzKSA9PiB7XG4gICAgICAgIGxldCB0b2xlcmFuY2UgPSBvcHRpb25zLnRvbGVyYW5jZSB8fCA0O1xuICAgICAgICBjb25zdCBhdHRyaWJ1dGVzID0gZ2V0QXR0cmlidXRlcyhhdHRyaWJ1dGVkU3RyaW5nKTtcbiAgICAgICAgY29uc3Qgbm9kZXMgPSBnZXROb2RlcyhhdHRyaWJ1dGVkU3RyaW5nLCBhdHRyaWJ1dGVzLCBvcHRpb25zKTtcbiAgICAgICAgbGV0IGJyZWFrcyA9IGxpbmVicmVhayhub2RlcywgYXZhaWxhYmxlV2lkdGhzLCB0b2xlcmFuY2UpO1xuICAgICAgICAvLyBUcnkgYWdhaW4gd2l0aCBhIGhpZ2hlciB0b2xlcmFuY2UgaWYgdGhlIGxpbmUgYnJlYWtpbmcgZmFpbGVkLlxuICAgICAgICB3aGlsZSAoYnJlYWtzLmxlbmd0aCA9PT0gMCAmJiB0b2xlcmFuY2UgPCBUT0xFUkFOQ0VfTElNSVQpIHtcbiAgICAgICAgICAgIHRvbGVyYW5jZSArPSBUT0xFUkFOQ0VfU1RFUFM7XG4gICAgICAgICAgICBicmVha3MgPSBsaW5lYnJlYWsobm9kZXMsIGF2YWlsYWJsZVdpZHRocywgdG9sZXJhbmNlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYnJlYWtzLmxlbmd0aCA9PT0gMCB8fCAoYnJlYWtzLmxlbmd0aCA9PT0gMSAmJiBicmVha3NbMF0gPT09IDApKSB7XG4gICAgICAgICAgICBicmVha3MgPSBhcHBseUJlc3RGaXQobm9kZXMsIGF2YWlsYWJsZVdpZHRocyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJyZWFrTGluZXMoYXR0cmlidXRlZFN0cmluZywgbm9kZXMsIGJyZWFrcy5zbGljZSgxKSk7XG4gICAgfTtcbn07XG5cbnZhciBEaXJlY3Rpb247XG4oZnVuY3Rpb24gKERpcmVjdGlvbikge1xuICAgIERpcmVjdGlvbltEaXJlY3Rpb25bXCJHUk9XXCJdID0gMF0gPSBcIkdST1dcIjtcbiAgICBEaXJlY3Rpb25bRGlyZWN0aW9uW1wiU0hSSU5LXCJdID0gMV0gPSBcIlNIUklOS1wiO1xufSkoRGlyZWN0aW9uIHx8IChEaXJlY3Rpb24gPSB7fSkpO1xuY29uc3QgV0hJVEVTUEFDRV9QUklPUklUWSA9IDE7XG5jb25zdCBMRVRURVJfUFJJT1JJVFkgPSAyO1xuY29uc3QgRVhQQU5EX1dISVRFU1BBQ0VfRkFDVE9SID0ge1xuICAgIGJlZm9yZTogMC41LFxuICAgIGFmdGVyOiAwLjUsXG4gICAgcHJpb3JpdHk6IFdISVRFU1BBQ0VfUFJJT1JJVFksXG4gICAgdW5jb25zdHJhaW5lZDogZmFsc2UsXG59O1xuY29uc3QgRVhQQU5EX0NIQVJfRkFDVE9SID0ge1xuICAgIGJlZm9yZTogMC4xNDQ1MzEyNSwgLy8gMzcvMjU2XG4gICAgYWZ0ZXI6IDAuMTQ0NTMxMjUsXG4gICAgcHJpb3JpdHk6IExFVFRFUl9QUklPUklUWSxcbiAgICB1bmNvbnN0cmFpbmVkOiBmYWxzZSxcbn07XG5jb25zdCBTSFJJTktfV0hJVEVTUEFDRV9GQUNUT1IgPSB7XG4gICAgYmVmb3JlOiAtMC4wNDI5Njg3NSwgLy8gLTExLzI1NlxuICAgIGFmdGVyOiAtMC4wNDI5Njg3NSxcbiAgICBwcmlvcml0eTogV0hJVEVTUEFDRV9QUklPUklUWSxcbiAgICB1bmNvbnN0cmFpbmVkOiBmYWxzZSxcbn07XG5jb25zdCBTSFJJTktfQ0hBUl9GQUNUT1IgPSB7XG4gICAgYmVmb3JlOiAtMC4wNDI5Njg3NSxcbiAgICBhZnRlcjogLTAuMDQyOTY4NzUsXG4gICAgcHJpb3JpdHk6IExFVFRFUl9QUklPUklUWSxcbiAgICB1bmNvbnN0cmFpbmVkOiBmYWxzZSxcbn07XG5jb25zdCBnZXRDaGFyRmFjdG9yID0gKGRpcmVjdGlvbiwgb3B0aW9ucykgPT4ge1xuICAgIGNvbnN0IGV4cGFuZENoYXJGYWN0b3IgPSBvcHRpb25zLmV4cGFuZENoYXJGYWN0b3IgfHwge307XG4gICAgY29uc3Qgc2hyaW5rQ2hhckZhY3RvciA9IG9wdGlvbnMuc2hyaW5rQ2hhckZhY3RvciB8fCB7fTtcbiAgICByZXR1cm4gZGlyZWN0aW9uID09PSBEaXJlY3Rpb24uR1JPV1xuICAgICAgICA/IE9iamVjdC5hc3NpZ24oe30sIEVYUEFORF9DSEFSX0ZBQ1RPUiwgZXhwYW5kQ2hhckZhY3RvcilcbiAgICAgICAgOiBPYmplY3QuYXNzaWduKHt9LCBTSFJJTktfQ0hBUl9GQUNUT1IsIHNocmlua0NoYXJGYWN0b3IpO1xufTtcbmNvbnN0IGdldFdoaXRlc3BhY2VGYWN0b3IgPSAoZGlyZWN0aW9uLCBvcHRpb25zKSA9PiB7XG4gICAgY29uc3QgZXhwYW5kV2hpdGVzcGFjZUZhY3RvciA9IG9wdGlvbnMuZXhwYW5kV2hpdGVzcGFjZUZhY3RvciB8fCB7fTtcbiAgICBjb25zdCBzaHJpbmtXaGl0ZXNwYWNlRmFjdG9yID0gb3B0aW9ucy5zaHJpbmtXaGl0ZXNwYWNlRmFjdG9yIHx8IHt9O1xuICAgIHJldHVybiBkaXJlY3Rpb24gPT09IERpcmVjdGlvbi5HUk9XXG4gICAgICAgID8gT2JqZWN0LmFzc2lnbih7fSwgRVhQQU5EX1dISVRFU1BBQ0VfRkFDVE9SLCBleHBhbmRXaGl0ZXNwYWNlRmFjdG9yKVxuICAgICAgICA6IE9iamVjdC5hc3NpZ24oe30sIFNIUklOS19XSElURVNQQUNFX0ZBQ1RPUiwgc2hyaW5rV2hpdGVzcGFjZUZhY3Rvcik7XG59O1xuY29uc3QgZmFjdG9yID0gKGRpcmVjdGlvbiwgb3B0aW9ucykgPT4gKGdseXBocykgPT4ge1xuICAgIGNvbnN0IGNoYXJGYWN0b3IgPSBnZXRDaGFyRmFjdG9yKGRpcmVjdGlvbiwgb3B0aW9ucyk7XG4gICAgY29uc3Qgd2hpdGVzcGFjZUZhY3RvciA9IGdldFdoaXRlc3BhY2VGYWN0b3IoZGlyZWN0aW9uLCBvcHRpb25zKTtcbiAgICBjb25zdCBmYWN0b3JzID0gW107XG4gICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IGdseXBocy5sZW5ndGg7IGluZGV4ICs9IDEpIHtcbiAgICAgICAgbGV0IGY7XG4gICAgICAgIGNvbnN0IGdseXBoID0gZ2x5cGhzW2luZGV4XTtcbiAgICAgICAgaWYgKGlzV2hpdGVTcGFjZShnbHlwaCkpIHtcbiAgICAgICAgICAgIGYgPSBPYmplY3QuYXNzaWduKHt9LCB3aGl0ZXNwYWNlRmFjdG9yKTtcbiAgICAgICAgICAgIGlmIChpbmRleCA9PT0gZ2x5cGhzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICBmLmJlZm9yZSA9IDA7XG4gICAgICAgICAgICAgICAgaWYgKGluZGV4ID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBmYWN0b3JzW2luZGV4IC0gMV0uYWZ0ZXIgPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChnbHlwaC5pc01hcmsgJiYgaW5kZXggPiAwKSB7XG4gICAgICAgICAgICBmID0gT2JqZWN0LmFzc2lnbih7fSwgZmFjdG9yc1tpbmRleCAtIDFdKTtcbiAgICAgICAgICAgIGYuYmVmb3JlID0gMDtcbiAgICAgICAgICAgIGZhY3RvcnNbaW5kZXggLSAxXS5hZnRlciA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmID0gT2JqZWN0LmFzc2lnbih7fSwgY2hhckZhY3Rvcik7XG4gICAgICAgIH1cbiAgICAgICAgZmFjdG9ycy5wdXNoKGYpO1xuICAgIH1cbiAgICByZXR1cm4gZmFjdG9ycztcbn07XG5jb25zdCBnZXRGYWN0b3JzID0gKGdhcCwgbGluZSwgb3B0aW9ucykgPT4ge1xuICAgIGNvbnN0IGRpcmVjdGlvbiA9IGdhcCA+IDAgPyBEaXJlY3Rpb24uR1JPVyA6IERpcmVjdGlvbi5TSFJJTks7XG4gICAgY29uc3QgZ2V0RmFjdG9yID0gZmFjdG9yKGRpcmVjdGlvbiwgb3B0aW9ucyk7XG4gICAgY29uc3QgZmFjdG9ycyA9IGxpbmUucnVucy5yZWR1Y2UoKGFjYywgcnVuKSA9PiB7XG4gICAgICAgIHJldHVybiBhY2MuY29uY2F0KGdldEZhY3RvcihydW4uZ2x5cGhzKSk7XG4gICAgfSwgW10pO1xuICAgIGZhY3RvcnNbMF0uYmVmb3JlID0gMDtcbiAgICBmYWN0b3JzW2ZhY3RvcnMubGVuZ3RoIC0gMV0uYWZ0ZXIgPSAwO1xuICAgIHJldHVybiBmYWN0b3JzO1xufTtcblxuY29uc3QgS0FTSElEQV9QUklPUklUWSA9IDA7XG5jb25zdCBOVUxMX1BSSU9SSVRZID0gMztcbmNvbnN0IGdldERpc3RhbmNlcyA9IChnYXAsIGZhY3RvcnMpID0+IHtcbiAgICBsZXQgdG90YWwgPSAwO1xuICAgIGNvbnN0IHByaW9yaXRpZXMgPSBbXTtcbiAgICBjb25zdCB1bmNvbnN0cmFpbmVkID0gW107XG4gICAgZm9yIChsZXQgcHJpb3JpdHkgPSBLQVNISURBX1BSSU9SSVRZOyBwcmlvcml0eSA8PSBOVUxMX1BSSU9SSVRZOyBwcmlvcml0eSArPSAxKSB7XG4gICAgICAgIHByaW9yaXRpZXNbcHJpb3JpdHldID0gdW5jb25zdHJhaW5lZFtwcmlvcml0eV0gPSAwO1xuICAgIH1cbiAgICAvLyBzdW0gdGhlIGZhY3RvcnMgYXQgZWFjaCBwcmlvcml0eVxuICAgIGZvciAobGV0IGogPSAwOyBqIDwgZmFjdG9ycy5sZW5ndGg7IGogKz0gMSkge1xuICAgICAgICBjb25zdCBmID0gZmFjdG9yc1tqXTtcbiAgICAgICAgY29uc3Qgc3VtID0gZi5iZWZvcmUgKyBmLmFmdGVyO1xuICAgICAgICB0b3RhbCArPSBzdW07XG4gICAgICAgIHByaW9yaXRpZXNbZi5wcmlvcml0eV0gKz0gc3VtO1xuICAgICAgICBpZiAoZi51bmNvbnN0cmFpbmVkKSB7XG4gICAgICAgICAgICB1bmNvbnN0cmFpbmVkW2YucHJpb3JpdHldICs9IHN1bTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBjaG9vc2UgdGhlIHByaW9yaXRpZXMgdGhhdCBuZWVkIHRvIGJlIGFwcGxpZWRcbiAgICBsZXQgaGlnaGVzdFByaW9yaXR5ID0gLTE7XG4gICAgbGV0IGhpZ2hlc3RQcmlvcml0eVN1bSA9IDA7XG4gICAgbGV0IHJlbWFpbmluZ0dhcCA9IGdhcDtcbiAgICBsZXQgcHJpb3JpdHk7XG4gICAgZm9yIChwcmlvcml0eSA9IEtBU0hJREFfUFJJT1JJVFk7IHByaW9yaXR5IDw9IE5VTExfUFJJT1JJVFk7IHByaW9yaXR5ICs9IDEpIHtcbiAgICAgICAgY29uc3QgcHJpb3JpdHlTdW0gPSBwcmlvcml0aWVzW3ByaW9yaXR5XTtcbiAgICAgICAgaWYgKHByaW9yaXR5U3VtICE9PSAwKSB7XG4gICAgICAgICAgICBpZiAoaGlnaGVzdFByaW9yaXR5ID09PSAtMSkge1xuICAgICAgICAgICAgICAgIGhpZ2hlc3RQcmlvcml0eSA9IHByaW9yaXR5O1xuICAgICAgICAgICAgICAgIGhpZ2hlc3RQcmlvcml0eVN1bSA9IHByaW9yaXR5U3VtO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gaWYgdGhpcyBwcmlvcml0eSBjb3ZlcnMgdGhlIHJlbWFpbmluZyBnYXAsIHdlJ3JlIGRvbmVcbiAgICAgICAgICAgIGlmIChNYXRoLmFicyhyZW1haW5pbmdHYXApIDw9IE1hdGguYWJzKHByaW9yaXR5U3VtKSkge1xuICAgICAgICAgICAgICAgIHByaW9yaXRpZXNbcHJpb3JpdHldID0gcmVtYWluaW5nR2FwIC8gcHJpb3JpdHlTdW07XG4gICAgICAgICAgICAgICAgdW5jb25zdHJhaW5lZFtwcmlvcml0eV0gPSAwO1xuICAgICAgICAgICAgICAgIHJlbWFpbmluZ0dhcCA9IDA7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBtYXJrIHRoYXQgd2UgbmVlZCB0byB1c2UgMTAwJSBvZiB0aGUgYWRqdXN0bWVudCBmcm9tXG4gICAgICAgICAgICAvLyB0aGlzIHByaW9yaXR5LCBhbmQgc3VidHJhY3QgdGhlIHNwYWNlIHRoYXQgaXQgY29uc3VtZXNcbiAgICAgICAgICAgIHByaW9yaXRpZXNbcHJpb3JpdHldID0gMTtcbiAgICAgICAgICAgIHJlbWFpbmluZ0dhcCAtPSBwcmlvcml0eVN1bTtcbiAgICAgICAgICAgIC8vIGlmIHRoaXMgcHJpb3JpdHkgaGFzIHVuY29uc3RyYWluZWQgZ2x5cGhzLCBsZXQgdGhlbSBjb25zdW1lIHRoZSByZW1haW5pbmcgc3BhY2VcbiAgICAgICAgICAgIGlmICh1bmNvbnN0cmFpbmVkW3ByaW9yaXR5XSAhPT0gMCkge1xuICAgICAgICAgICAgICAgIHVuY29uc3RyYWluZWRbcHJpb3JpdHldID0gcmVtYWluaW5nR2FwIC8gdW5jb25zdHJhaW5lZFtwcmlvcml0eV07XG4gICAgICAgICAgICAgICAgcmVtYWluaW5nR2FwID0gMDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyB6ZXJvIG91dCByZW1haW5pbmcgcHJpb3JpdGllcyAoaWYgYW55KVxuICAgIGZvciAobGV0IHAgPSBwcmlvcml0eSArIDE7IHAgPD0gTlVMTF9QUklPUklUWTsgcCArPSAxKSB7XG4gICAgICAgIHByaW9yaXRpZXNbcF0gPSAwO1xuICAgICAgICB1bmNvbnN0cmFpbmVkW3BdID0gMDtcbiAgICB9XG4gICAgLy8gaWYgdGhlcmUgaXMgc3RpbGwgc3BhY2UgbGVmdCBvdmVyLCBhc3NpZ24gaXQgdG8gdGhlIGhpZ2hlc3QgcHJpb3JpdHkgdGhhdCB3ZSBzYXcuXG4gICAgLy8gdGhpcyB2aW9sYXRlcyB0aGVpciBmYWN0b3JzLCBidXQgaXQgb25seSBoYXBwZW5zIGluIGV4dHJlbWUgY2FzZXNcbiAgICBpZiAocmVtYWluaW5nR2FwID4gMCAmJiBoaWdoZXN0UHJpb3JpdHkgPiAtMSkge1xuICAgICAgICBwcmlvcml0aWVzW2hpZ2hlc3RQcmlvcml0eV0gPVxuICAgICAgICAgICAgKGhpZ2hlc3RQcmlvcml0eVN1bSArIChnYXAgLSB0b3RhbCkpIC8gaGlnaGVzdFByaW9yaXR5U3VtO1xuICAgIH1cbiAgICAvLyBjcmVhdGUgYW5kIHJldHVybiBhbiBhcnJheSBvZiBkaXN0YW5jZXMgdG8gYWRkIHRvIGVhY2ggZ2x5cGgncyBhZHZhbmNlXG4gICAgY29uc3QgZGlzdGFuY2VzID0gW107XG4gICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IGZhY3RvcnMubGVuZ3RoOyBpbmRleCArPSAxKSB7XG4gICAgICAgIC8vIHRoZSBkaXN0YW5jZSB0byBhZGQgdG8gdGhpcyBnbHlwaCBpcyB0aGUgc3VtIG9mIHRoZSBzcGFjZSB0byBhZGRcbiAgICAgICAgLy8gYWZ0ZXIgdGhpcyBnbHlwaCwgYW5kIHRoZSBzcGFjZSB0byBhZGQgYmVmb3JlIHRoZSBuZXh0IGdseXBoXG4gICAgICAgIGNvbnN0IGYgPSBmYWN0b3JzW2luZGV4XTtcbiAgICAgICAgY29uc3QgbmV4dCA9IGZhY3RvcnNbaW5kZXggKyAxXTtcbiAgICAgICAgbGV0IGRpc3QgPSBmLmFmdGVyICogcHJpb3JpdGllc1tmLnByaW9yaXR5XTtcbiAgICAgICAgaWYgKG5leHQpIHtcbiAgICAgICAgICAgIGRpc3QgKz0gbmV4dC5iZWZvcmUgKiBwcmlvcml0aWVzW25leHQucHJpb3JpdHldO1xuICAgICAgICB9XG4gICAgICAgIC8vIGlmIHRoaXMgZ2x5cGggaXMgdW5jb25zdHJhaW5lZCwgYWRkIHRoZSB1bmNvbnN0cmFpbmVkIGRpc3RhbmNlIGFzIHdlbGxcbiAgICAgICAgaWYgKGYudW5jb25zdHJhaW5lZCkge1xuICAgICAgICAgICAgZGlzdCArPSBmLmFmdGVyICogdW5jb25zdHJhaW5lZFtmLnByaW9yaXR5XTtcbiAgICAgICAgICAgIGlmIChuZXh0KSB7XG4gICAgICAgICAgICAgICAgZGlzdCArPSBuZXh0LmJlZm9yZSAqIHVuY29uc3RyYWluZWRbbmV4dC5wcmlvcml0eV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZGlzdGFuY2VzLnB1c2goZGlzdCk7XG4gICAgfVxuICAgIHJldHVybiBkaXN0YW5jZXM7XG59O1xuXG4vKipcbiAqIEFkanVzdCBydW4gcG9zaXRpb25zIGJ5IGdpdmVuIGRpc3RhbmNlc1xuICpcbiAqIEBwYXJhbSBkaXN0YW5jZXNcbiAqIEBwYXJhbSBsaW5lXG4gKiBAcmV0dXJucyBMaW5lXG4gKi9cbmNvbnN0IGp1c3RpZnlMaW5lID0gKGRpc3RhbmNlcywgbGluZSkgPT4ge1xuICAgIGxldCBpbmRleCA9IDA7XG4gICAgZm9yIChjb25zdCBydW4gb2YgbGluZS5ydW5zKSB7XG4gICAgICAgIGZvciAoY29uc3QgcG9zaXRpb24gb2YgcnVuLnBvc2l0aW9ucykge1xuICAgICAgICAgICAgcG9zaXRpb24ueEFkdmFuY2UgKz0gZGlzdGFuY2VzW2luZGV4KytdO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBsaW5lO1xufTtcbi8qKlxuICogQSBKdXN0aWZpY2F0aW9uRW5naW5lIGlzIHVzZWQgYnkgYSBUeXBlc2V0dGVyIHRvIHBlcmZvcm0gbGluZSBmcmFnbWVudFxuICoganVzdGlmaWNhdGlvbi4gVGhpcyBpbXBsZW1lbnRhdGlvbiBpcyBiYXNlZCBvbiBhIGRlc2NyaXB0aW9uIG9mIEFwcGxlJ3NcbiAqIGp1c3RpZmljYXRpb24gYWxnb3JpdGhtIGZyb20gYSBQREYgaW4gdGhlIEFwcGxlIEZvbnQgVG9vbHMgcGFja2FnZS5cbiAqXG4gKiBAcGFyYW0gb3B0aW9ucyAtIExheW91dCBvcHRpb25zXG4gKi9cbmNvbnN0IGp1c3RpZmljYXRpb24gPSAob3B0aW9ucykgPT4ge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSBsaW5lXG4gICAgICogQHJldHVybnMgTGluZVxuICAgICAqL1xuICAgIHJldHVybiAobGluZSkgPT4ge1xuICAgICAgICBjb25zdCBnYXAgPSBsaW5lLmJveC53aWR0aCAtIGFkdmFuY2VXaWR0aChsaW5lKTtcbiAgICAgICAgaWYgKGdhcCA9PT0gMClcbiAgICAgICAgICAgIHJldHVybiBsaW5lOyAvLyBFeGFjdCBmaXRcbiAgICAgICAgY29uc3QgZmFjdG9ycyA9IGdldEZhY3RvcnMoZ2FwLCBsaW5lLCBvcHRpb25zKTtcbiAgICAgICAgY29uc3QgZGlzdGFuY2VzID0gZ2V0RGlzdGFuY2VzKGdhcCwgZmFjdG9ycyk7XG4gICAgICAgIHJldHVybiBqdXN0aWZ5TGluZShkaXN0YW5jZXMsIGxpbmUpO1xuICAgIH07XG59O1xuXG4vKipcbiAqIFJldHVybnMgYXR0cmlidXRlZCBzdHJpbmcgYXNjZW50XG4gKlxuICogQHBhcmFtIGF0dHJpYnV0ZWRTdHJpbmcgLSBBdHRyaWJ1dGVkIHN0cmluZ1xuICogQHJldHVybnMgQXNjZW50XG4gKi9cbmNvbnN0IGFzY2VudCA9IChhdHRyaWJ1dGVkU3RyaW5nKSA9PiB7XG4gICAgY29uc3QgcmVkdWNlciA9IChhY2MsIHJ1bikgPT4gTWF0aC5tYXgoYWNjLCBhc2NlbnQkMShydW4pKTtcbiAgICByZXR1cm4gYXR0cmlidXRlZFN0cmluZy5ydW5zLnJlZHVjZShyZWR1Y2VyLCAwKTtcbn07XG5cbi8vIFRoZSBiYXNlIGZvbnQgc2l6ZSB1c2VkIGZvciBjYWxjdWxhdGluZyB1bmRlcmxpbmUgdGhpY2tuZXNzLlxuY29uc3QgQkFTRV9GT05UX1NJWkUgPSAxMjtcbi8qKlxuICogQSBUZXh0RGVjb3JhdGlvbkVuZ2luZSBpcyB1c2VkIGJ5IGEgVHlwZXNldHRlciB0byBnZW5lcmF0ZVxuICogRGVjb3JhdGlvbkxpbmVzIGZvciBhIGxpbmUgZnJhZ21lbnQsIGluY2x1ZGluZyB1bmRlcmxpbmVzXG4gKiBhbmQgc3RyaWtlcy5cbiAqL1xuY29uc3QgdGV4dERlY29yYXRpb24gPSAoKSA9PiAobGluZSkgPT4ge1xuICAgIGxldCB4ID0gbGluZS5vdmVyZmxvd0xlZnQgfHwgMDtcbiAgICBjb25zdCBvdmVyZmxvd1JpZ2h0ID0gbGluZS5vdmVyZmxvd1JpZ2h0IHx8IDA7XG4gICAgY29uc3QgbWF4WCA9IGFkdmFuY2VXaWR0aChsaW5lKSAtIG92ZXJmbG93UmlnaHQ7XG4gICAgbGluZS5kZWNvcmF0aW9uTGluZXMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpbmUucnVucy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBjb25zdCBydW4gPSBsaW5lLnJ1bnNbaV07XG4gICAgICAgIGNvbnN0IHdpZHRoID0gTWF0aC5taW4obWF4WCAtIHgsIGFkdmFuY2VXaWR0aCQxKHJ1bikpO1xuICAgICAgICBjb25zdCB0aGlja25lc3MgPSBNYXRoLm1heCgwLjUsIE1hdGguZmxvb3IocnVuLmF0dHJpYnV0ZXMuZm9udFNpemUgLyBCQVNFX0ZPTlRfU0laRSkpO1xuICAgICAgICBpZiAocnVuLmF0dHJpYnV0ZXMudW5kZXJsaW5lKSB7XG4gICAgICAgICAgICBjb25zdCByZWN0ID0ge1xuICAgICAgICAgICAgICAgIHgsXG4gICAgICAgICAgICAgICAgeTogYXNjZW50KGxpbmUpICsgdGhpY2tuZXNzICogMixcbiAgICAgICAgICAgICAgICB3aWR0aCxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IHRoaWNrbmVzcyxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCBkZWNvcmF0aW9uTGluZSA9IHtcbiAgICAgICAgICAgICAgICByZWN0LFxuICAgICAgICAgICAgICAgIG9wYWNpdHk6IHJ1bi5hdHRyaWJ1dGVzLm9wYWNpdHksXG4gICAgICAgICAgICAgICAgY29sb3I6IHJ1bi5hdHRyaWJ1dGVzLnVuZGVybGluZUNvbG9yIHx8ICdibGFjaycsXG4gICAgICAgICAgICAgICAgc3R5bGU6IHJ1bi5hdHRyaWJ1dGVzLnVuZGVybGluZVN0eWxlIHx8ICdzb2xpZCcsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgbGluZS5kZWNvcmF0aW9uTGluZXMucHVzaChkZWNvcmF0aW9uTGluZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJ1bi5hdHRyaWJ1dGVzLnN0cmlrZSkge1xuICAgICAgICAgICAgY29uc3QgeSA9IGFzY2VudChsaW5lKSAtIGFzY2VudCQxKHJ1bikgLyAzO1xuICAgICAgICAgICAgY29uc3QgcmVjdCA9IHsgeCwgeSwgd2lkdGgsIGhlaWdodDogdGhpY2tuZXNzIH07XG4gICAgICAgICAgICBjb25zdCBkZWNvcmF0aW9uTGluZSA9IHtcbiAgICAgICAgICAgICAgICByZWN0LFxuICAgICAgICAgICAgICAgIG9wYWNpdHk6IHJ1bi5hdHRyaWJ1dGVzLm9wYWNpdHksXG4gICAgICAgICAgICAgICAgY29sb3I6IHJ1bi5hdHRyaWJ1dGVzLnN0cmlrZUNvbG9yIHx8ICdibGFjaycsXG4gICAgICAgICAgICAgICAgc3R5bGU6IHJ1bi5hdHRyaWJ1dGVzLnN0cmlrZVN0eWxlIHx8ICdzb2xpZCcsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgbGluZS5kZWNvcmF0aW9uTGluZXMucHVzaChkZWNvcmF0aW9uTGluZSk7XG4gICAgICAgIH1cbiAgICAgICAgeCArPSB3aWR0aDtcbiAgICB9XG4gICAgcmV0dXJuIGxpbmU7XG59O1xuXG5jb25zdCBpZ25vcmVkU2NyaXB0cyA9IFsnQ29tbW9uJywgJ0luaGVyaXRlZCcsICdVbmtub3duJ107XG4vKipcbiAqIFJlc29sdmVzIHVuaWNvZGUgc2NyaXB0IGluIHJ1bnMsIGdyb3VwaW5nIGVxdWFsIHJ1bnMgdG9nZXRoZXJcbiAqL1xuY29uc3Qgc2NyaXB0SXRlbWl6ZXIgPSAoKSA9PiB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIGF0dHJpYnV0ZWRTdHJpbmcgLSBBdHRyaWJ1dGVkIHN0cmluZ1xuICAgICAqIEByZXR1cm5zIEF0dHJpYnV0ZWQgc3RyaW5nXG4gICAgICovXG4gICAgcmV0dXJuIChhdHRyaWJ1dGVkU3RyaW5nKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgc3RyaW5nIH0gPSBhdHRyaWJ1dGVkU3RyaW5nO1xuICAgICAgICBsZXQgbGFzdFNjcmlwdCA9ICdVbmtub3duJztcbiAgICAgICAgbGV0IGxhc3RJbmRleCA9IDA7XG4gICAgICAgIGxldCBpbmRleCA9IDA7XG4gICAgICAgIGNvbnN0IHJ1bnMgPSBbXTtcbiAgICAgICAgaWYgKCFzdHJpbmcpXG4gICAgICAgICAgICByZXR1cm4gZW1wdHkoKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHJpbmcubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgIGNvbnN0IGNoYXIgPSBzdHJpbmdbaV07XG4gICAgICAgICAgICBjb25zdCBjb2RlUG9pbnQgPSBjaGFyLmNvZGVQb2ludEF0KDApO1xuICAgICAgICAgICAgY29uc3Qgc2NyaXB0ID0gdW5pY29kZS5nZXRTY3JpcHQoY29kZVBvaW50KTtcbiAgICAgICAgICAgIGlmIChzY3JpcHQgIT09IGxhc3RTY3JpcHQgJiYgIWlnbm9yZWRTY3JpcHRzLmluY2x1ZGVzKHNjcmlwdCkpIHtcbiAgICAgICAgICAgICAgICBpZiAobGFzdFNjcmlwdCAhPT0gJ1Vua25vd24nKSB7XG4gICAgICAgICAgICAgICAgICAgIHJ1bnMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydDogbGFzdEluZGV4LFxuICAgICAgICAgICAgICAgICAgICAgICAgZW5kOiBpbmRleCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHsgc2NyaXB0OiBsYXN0U2NyaXB0IH0sXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsYXN0SW5kZXggPSBpbmRleDtcbiAgICAgICAgICAgICAgICBsYXN0U2NyaXB0ID0gc2NyaXB0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaW5kZXggKz0gY2hhci5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxhc3RJbmRleCA8IHN0cmluZy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJ1bnMucHVzaCh7XG4gICAgICAgICAgICAgICAgc3RhcnQ6IGxhc3RJbmRleCxcbiAgICAgICAgICAgICAgICBlbmQ6IHN0cmluZy5sZW5ndGgsXG4gICAgICAgICAgICAgICAgYXR0cmlidXRlczogeyBzY3JpcHQ6IGxhc3RTY3JpcHQgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHsgc3RyaW5nLCBydW5zOiBydW5zIH07XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbn07XG5cbmNvbnN0IFNPRlRfSFlQSEVOID0gJ1xcdTAwYWQnO1xuY29uc3QgaHlwaGVuYXRvciA9IGh5cGhlbihwYXR0ZXJuKTtcbi8qKlxuICogQHBhcmFtIHdvcmRcbiAqIEByZXR1cm5zIFdvcmQgcGFydHNcbiAqL1xuY29uc3Qgc3BsaXRIeXBoZW4gPSAod29yZCkgPT4ge1xuICAgIHJldHVybiB3b3JkLnNwbGl0KFNPRlRfSFlQSEVOKTtcbn07XG5jb25zdCBjYWNoZSA9IHt9O1xuLyoqXG4gKiBAcGFyYW0gd29yZFxuICogQHJldHVybnMgV29yZCBwYXJ0c1xuICovXG5jb25zdCBnZXRQYXJ0cyA9ICh3b3JkKSA9PiB7XG4gICAgY29uc3QgYmFzZSA9IHdvcmQuaW5jbHVkZXMoU09GVF9IWVBIRU4pID8gd29yZCA6IGh5cGhlbmF0b3Iod29yZCk7XG4gICAgcmV0dXJuIHNwbGl0SHlwaGVuKGJhc2UpO1xufTtcbmNvbnN0IHdvcmRIeXBoZW5hdGlvbiA9ICgpID0+IHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gd29yZCAtIFdvcmRcbiAgICAgKiBAcmV0dXJucyBXb3JkIHBhcnRzXG4gICAgICovXG4gICAgcmV0dXJuICh3b3JkKSA9PiB7XG4gICAgICAgIGNvbnN0IGNhY2hlS2V5ID0gYF8ke3dvcmR9YDtcbiAgICAgICAgaWYgKGlzTmlsKHdvcmQpKVxuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICBpZiAoY2FjaGVbY2FjaGVLZXldKVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlW2NhY2hlS2V5XTtcbiAgICAgICAgY2FjaGVbY2FjaGVLZXldID0gZ2V0UGFydHMod29yZCk7XG4gICAgICAgIHJldHVybiBjYWNoZVtjYWNoZUtleV07XG4gICAgfTtcbn07XG5cbmNvbnN0IElHTk9SRURfQ09ERV9QT0lOVFMgPSBbMTczXTtcbmNvbnN0IGdldEZvbnRTaXplID0gKHJ1bikgPT4gcnVuLmF0dHJpYnV0ZXMuZm9udFNpemUgfHwgMTI7XG5jb25zdCBwaWNrRm9udEZyb21Gb250U3RhY2sgPSAoY29kZVBvaW50LCBmb250U3RhY2ssIGxhc3RGb250KSA9PiB7XG4gICAgY29uc3QgZm9udFN0YWNrV2l0aEZhbGxiYWNrID0gWy4uLmZvbnRTdGFjaywgbGFzdEZvbnRdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZm9udFN0YWNrV2l0aEZhbGxiYWNrLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGNvbnN0IGZvbnQgPSBmb250U3RhY2tXaXRoRmFsbGJhY2tbaV07XG4gICAgICAgIGlmICghSUdOT1JFRF9DT0RFX1BPSU5UUy5pbmNsdWRlcyhjb2RlUG9pbnQpICYmXG4gICAgICAgICAgICBmb250ICYmXG4gICAgICAgICAgICBmb250Lmhhc0dseXBoRm9yQ29kZVBvaW50ICYmXG4gICAgICAgICAgICBmb250Lmhhc0dseXBoRm9yQ29kZVBvaW50KGNvZGVQb2ludCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmb250O1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmb250U3RhY2suYXQoLTEpO1xufTtcbmNvbnN0IGZvbnRTdWJzdGl0dXRpb24gPSAoKSA9PiAoeyBzdHJpbmcsIHJ1bnMgfSkgPT4ge1xuICAgIGxldCBsYXN0Rm9udCA9IG51bGw7XG4gICAgbGV0IGxhc3RGb250U2l6ZSA9IG51bGw7XG4gICAgbGV0IGxhc3RJbmRleCA9IDA7XG4gICAgbGV0IGluZGV4ID0gMDtcbiAgICBjb25zdCByZXMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJ1bnMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgY29uc3QgcnVuID0gcnVuc1tpXTtcbiAgICAgICAgaWYgKHN0cmluZy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICBzdGFydDogMCxcbiAgICAgICAgICAgICAgICBlbmQ6IDAsXG4gICAgICAgICAgICAgICAgYXR0cmlidXRlczogeyBmb250OiBydW4uYXR0cmlidXRlcy5mb250IH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNoYXJzID0gc3RyaW5nLnNsaWNlKHJ1bi5zdGFydCwgcnVuLmVuZCk7XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgY2hhcnMubGVuZ3RoOyBqICs9IDEpIHtcbiAgICAgICAgICAgIGNvbnN0IGNoYXIgPSBjaGFyc1tqXTtcbiAgICAgICAgICAgIGNvbnN0IGNvZGVQb2ludCA9IGNoYXIuY29kZVBvaW50QXQoMCk7XG4gICAgICAgICAgICAvLyBJZiB0aGUgZGVmYXVsdCBmb250IGRvZXMgbm90IGhhdmUgYSBnbHlwaCBhbmQgdGhlIGZhbGxiYWNrIGZvbnQgZG9lcywgd2UgdXNlIGl0XG4gICAgICAgICAgICBjb25zdCBmb250ID0gcGlja0ZvbnRGcm9tRm9udFN0YWNrKGNvZGVQb2ludCwgcnVuLmF0dHJpYnV0ZXMuZm9udCwgbGFzdEZvbnQpO1xuICAgICAgICAgICAgY29uc3QgZm9udFNpemUgPSBnZXRGb250U2l6ZShydW4pO1xuICAgICAgICAgICAgLy8gSWYgYW55dGhpbmcgdGhhdCB3b3VsZCBpbXBhY3QgcmVzIGhhcyBjaGFuZ2VkLCB1cGRhdGUgaXRcbiAgICAgICAgICAgIGlmIChmb250ICE9PSBsYXN0Rm9udCB8fFxuICAgICAgICAgICAgICAgIGZvbnRTaXplICE9PSBsYXN0Rm9udFNpemUgfHxcbiAgICAgICAgICAgICAgICBmb250LnVuaXRzUGVyRW0gIT09IGxhc3RGb250LnVuaXRzUGVyRW0pIHtcbiAgICAgICAgICAgICAgICBpZiAobGFzdEZvbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IGxhc3RJbmRleCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuZDogaW5kZXgsXG4gICAgICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9udDogW2xhc3RGb250XSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY2FsZTogbGFzdEZvbnRTaXplIC8gbGFzdEZvbnQudW5pdHNQZXJFbSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsYXN0Rm9udCA9IGZvbnQ7XG4gICAgICAgICAgICAgICAgbGFzdEZvbnRTaXplID0gZm9udFNpemU7XG4gICAgICAgICAgICAgICAgbGFzdEluZGV4ID0gaW5kZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpbmRleCArPSBjaGFyLmxlbmd0aDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAobGFzdEluZGV4IDwgc3RyaW5nLmxlbmd0aCkge1xuICAgICAgICBjb25zdCBmb250U2l6ZSA9IGdldEZvbnRTaXplKGxhc3QocnVucykpO1xuICAgICAgICByZXMucHVzaCh7XG4gICAgICAgICAgICBzdGFydDogbGFzdEluZGV4LFxuICAgICAgICAgICAgZW5kOiBzdHJpbmcubGVuZ3RoLFxuICAgICAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgICAgICAgIGZvbnQ6IFtsYXN0Rm9udF0sXG4gICAgICAgICAgICAgICAgc2NhbGU6IGZvbnRTaXplIC8gbGFzdEZvbnQudW5pdHNQZXJFbSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4geyBzdHJpbmcsIHJ1bnM6IHJlcyB9O1xufTtcblxuZXhwb3J0IHsgYmlkaUVuZ2luZSBhcyBiaWRpLCBsYXlvdXRFbmdpbmUgYXMgZGVmYXVsdCwgZm9udFN1YnN0aXR1dGlvbiwgZnJvbUZyYWdtZW50cywganVzdGlmaWNhdGlvbiwgbGluZWJyZWFrZXIsIHNjcmlwdEl0ZW1pemVyLCB0ZXh0RGVjb3JhdGlvbiwgd29yZEh5cGhlbmF0aW9uIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@react-pdf+textkit@6.0.0/node_modules/@react-pdf/textkit/lib/textkit.js\n");

/***/ })

};
;